\chapter{Background}
\label{background}
{}The use of components in software is a natural extension when build of systems, as it allows software engineers to so many benefits that other engineering diciplines have.
{}The critical problem of having component be a "natural" concept is that the specific definition of what a sotfware component is, remains ambigious.
This leads to many disagreements of what a component is, and what a software unit requires to be upgraded to "component".
For instance Szyperski and Meyer in Dr. Dobbs magazine discuss over a series of articles what a component is and this leads to disagreements even amoung the leaders in the field. %TODO cite dobbs

{}To avoid these issues of semantics, we will first define a component in an egotistical way, in the terms of the problem we are trying to solve.
We give examples of such components and their models that fit our definition, this may not be exactly what other people have defined.
For the purposes of consistency, when we refeer to "software component" or "component" we refer to our definition.

We then take a few examples of such component models, OSGi and Debian Packages, and describe them in more depth, looking at their similarities and differences of the symantics of their models.

We then go over the background of this, component evolution and component system evolution.
Finally, we discuss the development and use of component dependency resolution in current component models.

\section{What is a Component?}
%%%Discuss what a component is in relation to our problem. Give a few examples of 

A component is most broadly defined as
\quote{A unit that can be composed}
This is a complete, but useless definition, as it encompasses to large a range of possiblilities. 
Szyperski noted, a natural concept such as component is best defined by the properties required to attain it's goals. %TODO

The goals a component requires in this study are that of being able to be evolved.

Give examples of OSGi Bundles, Eclipse Plugins, DS
Spring DM
Debian Packages
Maven POM
CUDF

Discuss differences and commonalities
Multiple package installations Maven Debain No, OSGi Eclipse DS and CUDF yes
Focus on interface not implementation dependence, Maven no, Debian Community defined virtual packages, 
OSGi kind of package name space related to installation, Eclipse Yes DS Yes.
Version Control, All Yes
Run time replacement Dynamic Dependence, Maven no (no runtime), Eclipse Kind of a bit buggy requires restarts,
OSGI DS Debian Yes, CUDF is abstract so has no real implementation
Conflicts, Maven?, Spring and DS no,  OSGi Singleton, Debian and CUDF are Expressive
Reccommendation, ??

\section{Component Models}
%%%We are focusing on two of the most popular component models, the OSGi and Debian component models

\subsection{Debian}
%%%The debian component model

%%%Some feel that this is not truly a component model as it has no formal definition of composition

\subsection{OSGi}
%%%OSGi is an increasingly popular

\section{Component Evolution}
%%%Component evolution, changing components to newer versions
Versioning is the main mechanism in which components evolve.
There is also branching, and environment specific altering.

Versioning components has significant research behind it.

Branching is when a difference in opinion or idealogy on how a component should proceed into the future
causes the project to take two different routes given the same base code or idea.

Spring DM takes libraries and makes them OSGi compatable, 
Debian package can be compiled for different CPU architectures.


\section{Component System Evolution}
%%%Changing the component in the component systems, talk about DLL Hell, and the problems it has caused
Version and Dynamic dependence, with focus on interface give extensive tools to the composer 
Add, remove, upgrade, downgrade components in the system while it is running.

There are some problems that must be solved within the component model like making sure that during the change,
the system is never invalid or unstable. 
This is a scheduling problem as described by %TODO

The composer must also make sure that all dependencies are meet

\section{Component Dependency Resolution}
%%%The problems caused when Evolving component systems can be solved with Component Dependency Resolution.
%%%These have been used at Development time and Run time, some examples


\section{Current Dependency Resolvers}
%%%We break the set of implementations into 2 groups, design time dependency resolvers, and run time dependency resolvers.

\subsection{Apache Maven}
%%%Maven is a design time project and build automation tool, that can resolve library dependencies

\subsection{Nuget} 
%%%-- C\#

\subsection{RubyGems bundler}
%%% Bundler is a package dependency manager for RUBY gems, similar to 


\subsection{Paremus Nimble}
%%%Nimble is a OSGi bundle resolver, built to alter systems at runtime

\subsection{OSGi Bundle Repostiory}
%%%The OBR proposed by Peter Kriens and Richard Hall, is a meta data format for OSGi bundle resolution

\subsection{Apt-get}
%%%Apt-get is the core application for package management in Debian based GNU/linux distributions

\subsection{Aptitude}
%%%Aptitude is a competitor to apt-get which has some more advanced features

