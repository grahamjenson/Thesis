\chapter{Background}
\label{background}
{}Component-based software engineering is considered by many to be the future for development of software systems \cite{Szyperski2002},
{}where instead of developing a monolithic system, 
{}many small reusable units of execution are developed and composed into a single system.
{}The specification of how these components are defined and used to create a system is given in the \textbf{component model}.
{}This model can also support the evolution of the component systems by defining mechanisms to add, remove and replace components in that system.

%%%Manually evolving a system can be tedious, so we use component dependency resolution
Evolving a system through individually adding and removing components can be tedious task 
as components can have dependencies on other components which also need to be satisfied.
Therefore, after the user has identified the wanted components, 
those components' dependencies must be satisfied with other components, which themselves can have dependencies.
Satisfying all these dependencies manually is a recursive, time-consuming and error-prone task to accomplish.
However, as most modern component models require components to explicitly state their dependencies; 
this enables component dependency resolution to build systems where all dependencies are satisfied.

%%%A small example of such a problem.

In this chapter we go over the what a component is, and the difficulty in defining it.
We then discuss what a component model is, giving and comparing current examples of them.
Then discuss the evolution of individual components and component-based systems.
We then discuss component dependency resolution, giving a broad view of its goals and use cases for component systems.
Finally we give and compare different examples of component dependency resolvers for design-time and run-time, used in academia 
 
 
\section{What is a Component?}
%%%Some history to software components mentioning McIlroy's 1969 paper \cite{McIlroy1969}
Software components ideals can be traced to M. D. McIlroy's paper \cite{McIlroy1969}, where he described his ideas industrializing software engineering through a software component sub-industry. 
These components are made through the decomposition of software into discreet units with explicitly stated interfaces and behaviours.
However there is still much debate over how to define what a software component is, and what features it should have.\\

%%%Discussion of articles where Szyperski and Meyers discuss give their versions of what a component is.
Dr Dobb's magazine published a set of articles by two leading researchers in software engineering, Bertrand Meyer, originator of the design by contract methodology, 
and Clemens Szyperski, author of ``Component Software: Beyond Object-Oriented Programming''. 
These articles \cite{szyperski_components_2000, szyperski_point_2000, meyer_what_2000,meyer_significance_1999} discuss the
definitions of what a software component is as and how to use them.\\ 
Szyperski defined components in the first edition of his book, \cite{szyperski_component_2002} as having three characteristic properties:
\begin{enumerate}
  \item a unit of independent deployment
  \item a unit of third party composition
  \item has no externally observable state
\end{enumerate}

In the Dr Dobb's articles Szyperski defended his position against Meyers own enumeration of what a software components should be:
\begin{enumerate}
  \item May be used by other software elements (clients)
  \item May be used by clients without the intervention of the components
  developers
  \item Includes a specification of all dependencies (hardware and software
  platform, versions, other components)
  \item Includes a precision specification of the functionality it offers
  \item Is usable on the sole basis of that specification
  \item Is composable with other components
  \item Can be integrated into a system quickly and smoothly
\end{enumerate}

%%%It is difficult to define a natural concept such as component with a set of fixed enumerable features.
%%%Our egotistical view of components is defined with relation to Component Dependency Resolution.\\
{}As noted by Szyperski in \cite{Szyperski2002}, 
{}formal concept analysis \cite{Ganter1999} is the observation that it is impossible to
{}``enumerate a fixed agreeable set of features that is necessary and sufficient for a natural concept such as component.'' 
{}A definition can be found however, not by feature enumeration, but through stating the intention for the concept and exploring the technically inevitable consequences. 
{}As our intention is to investigate component dependency resolution, we will define what a component is with respect our goal of using component dependency resolution.

%%%This will not fit all views of what a component is (no definition will), but it eliminates unnecessary arguments so we can focus on CDR
This view of a software components definition will not agree with every persons view of what a software component is, but then no view can.
By only looking at aspects that are necessary for our topic we eliminate arguments over unnecessary semantics to focus on the core aspects of component dependency resolution. 

\subsection{A Software Component with respect to Component Dependency Resolution}
For component dependency resolution to be used the component model must require the explicit definition of dependencies of all components
and include mechanisms in which the composition of components can be altered.
This definition leaves undefined many aspects in the space of component software, however these are superfluous when discussing dependency resolution therefore are ignored.

%%%A component must have explict (computer readable) requirements on the context in which it can be used. Different from COTS requirements which are meant to be human readable.
The core requirement of a component that enables the use of component dependency resolution, is the explicit definition of what context a component can be executed under.
 
%%%The component model should specifiy mechanisms to support evolution of the system; e.g. the addition and removal of components from a composition.
Being able to use dependencies in order to find a system that fulfils all component requirements is not entirely useful unless there exists mechanisms in which to build or change a system.

%%%Aspects such as semantics of composition, distribution, development, are outside the scope of CDR, therefore ignored in this definition (that is not to say they are unimportant).    
Composition can be ignored because although the dependencies express a semantic purpose, that is not necessary for the resolver to know.
How the components are distributed is also superfluous, as the selection of the component is where we live

\section{Component Models}
%%%We go over some component models with their goals, syntax, semantics but end focusing on the component models, OSGi, Debian and CUDF
With respect to our definition of a software component, we examine some current component models, focusing on to popular models OSGi and Debian.

%%%Fractal

%%%Maven POM

%%%JavaBeans

%%%RPM

\subsection{Debian}
%%%The debian component model is used in Debain based GNU/Linux distributions

%%%Some feel that this is not truly a component model as it has no formal definition of composition.\\

%%%However it fits our criteria of a component as given in previous sections

\subsection{OSGi}
{}OSGi is a mature component model from the OSGi Alliance that has a significant presence in industry \cite{Kriens2008} 
{}from organizations like the Eclipse Foundation with their Equinox framework and Apache with Felix.

\subsection{CUDF}
%%%Here we give a brief introduction to CUDF, later in chapter \ref{implementation} we describe it more in depth

\subsection{Comparison}
%%%The comparison of component models focusses on their semantic definitions of dependencies and requirements,
%%%and the mechanisms by which a composition change.

\section{Evolution}
%%%Evolution is an important core aspect of Software Engineering and examining it in realtion to Component Systems is beneficial to the community\\
{}A software engineers goals towards software is to have continual satisfactory execution with maximum confidence at minimal cost and delay in this changing world \cite{Lehman2006}, 
{}while maintaining intellectual control over the complexity of design \cite{Brooks1975}.
{}Component systems aim to manage complexity through decomposition of systems into well defined components, and the evolution of such components through well defined mechanisms.

%%%Evolving a component system requires less change when compared to evolving a monolithic system.
Evolving component-based software requires only altering a minimal set of parts of the system, 
where as evolving a monolithic piece of software is achieved by replacing the entire system.
This comparison is described by Szyperski \cite{Szyperski2002} as ``evolution not revolution''.
As introducing change to a system introduces significant risk,
minimising change during evolution lowers the risk of component-based systems compared to monolithic systems. 
This risk occurs due to side effects that are caused by change, 
and changing large parts of a system incurs more side effects versus altering only specific parts of a system.
Therefore, lessening the change lowers the risk, and this is a very attractive feature of using and developing component-based software.

%%%A component model should support the evolution of individual components, and the evolution and change of the entire system

{}In this section we first discuss the support provided by a component model through the evolution of individual components and component systems.

\subsection{Component Evolution}
%%%Component evolution, i.e. the modification of components to create newer versions or branch existing versions.\\

%%%What is a version?
A version is the mechanism through which individual components evolve.
It is a unique marker which is compariable to other versions such that they are ordered.
As with the evolution of entire software systems, evolution of components requires constant maintenance.
Bugs can be found, features can be added, and code can be refactored all which make the component better.

%%%How are components versioned?
The syntax and semantics of a version is usually defined within the component model.
This forces all components that are developed for this model to follow the same general guidelines.

%%%Versions between components?
Although component must be versioned to conform to a versioning model defined by the component model, 
the way in which a developer uses this model to version their component is not usually strictly defined.
Each component is designed to be an independent unit, as such developers of components are separate from one another,
and the way in which they version their components can be different.
Therefore, version comparison is only useful between different versions of the same component;
e.g. a spell-checker component can be version 10 but a separate and superior spell-checker component may be only version 1.
This makes using component versions to decide between components impossible.

%%%A version of a component that is greater than another version of that component is assumed to be better in some way.
A newer version exists because the component has changed to be better in some way.
This may be through a bug being fixed, a security hole being patched, or the functionality being extended.
Having a newer version of a component in the system, may also make all of the other components that depend on it better as well,
causing a propagation of system improvement with the upgrading of one component.

In Belief Revision, one must maintain the newest set of information while only changing the minimal amount of previous knowledge. 

The change to the system that is caused when a newer version is installed may cause harm to your system.
In the same way that a version upgrade can propagate benefits through the system, 
friction or errors can propagate and cause a faulty or not functional system.

%%%Drawbacks of versions, they don't tell what changes
A common approach to selecting an optimal solution is to
maximise the versions of components while minimising the number of components.
The problem with the first criterion is that the version information does not tell us what quality improves, 
how much it improves or if that quality is relevant to the user or system.
Optimising for fewer components in a solution can be against many component system goals, like reuse or extensibility.
For example, this heuristics optimal solution would be a monolithic component with redundant functionality, over 
a set of more specific components. 


Versioning is the main mechanism in which components evolve.
There is also branching, and environment specific altering.

Versioning components has significant research behind it.

Branching is when a difference in opinion or idealogy on how a component should proceed into the future
causes the project to take two different routes given the same base code or idea.

Spring DM takes libraries and makes them OSGi compatable, 
Debian package can be compiled for different CPU architectures.


\subsection{Component System Evolution}
%%%Changing the component in the component systems by adding removeing components to support evolution\\
Version and Dynamic dependence, with focus on interface give extensive tools to the composer 
Add, remove, upgrade, downgrade components in the system while it is running.

%%%How is this achieved?

%%%Problems with versioning a component system is different combinations of components, with different versions.

There are some problems that must be solved within the component model like making sure that during the change,
the system is never invalid or unstable. 
This is a scheduling problem as described by %TODO

The composer must also make sure that all dependencies are meet

\section{Component Dependency Resolution}
%%%The tedious nature of satisfying component dependencies during component system evolution can be automated into a function called Component Dependency Resolution.
Manually satisfying all component dependencies while evolving a component system can be a tedious, time consuming task.
This process can be automated into the function Component Dependency Resolution (CDR) \cite{Jenson2010}.
This takes advantage of the explicitly declared requirements of components to find a system where all component constraints are satisfied.

%%%CDR can be used at design-time and run-time on component models.
CDR can be used at design time to determine the required dependencies to build and test a project (as in Apache Maven \cite{casey_better_2008}),
at run time to evolve or extend a component-based system (as in Eclipse P2 \cite{leBerre2010}),
or it can be used to build and restructure software product lines \cite{savolainen_analyzing_2007}.
CDR is also used in package management systems, like apt-get \cite{Barth2005},
for adding, removing and updating components in package based operating systems like Ubuntu\footnote{http://www.ubuntu.com}. 

%%%Talk about dependency hell and how that it is largely mitigated via dependency resolvers

\section{Boolean Satisfiability (SAT) Solvers}
%%%The definition of SAT has been around for a while, it was the first problem to be given the complexity NP-Complete

%%%SAT solvers have been investigated and found as a common good solution to CDR (EDOS PAPER)
Dependency Resolution is a NP-Complete problem, and NP-Hard given criteria to find an optimal solution.
This problem has been found in many areas, and there have been efforts to standardise the solution in an extensible way.
The EDOS project did a review of using SAT solvers, modified for optimisation, to solve dependecy resolution, and suggested that they were a satisfactory solution.
Today, most solvers use a SAT solver as they represent a quick extendible way to implement this functionality.

%%%SAT solvers are used to solve many problems, scheduling, model validity\ldots

%%%SAT solvers are very good at solving these kinds of problems because they are tested for performance against each other, to find what works empirically   

%%%We will breifly discuss their implementation and the algorithms associated, as it is the mechanism which we use to solve CDR problems

\subsection{Davis-Putnam-Logemann-Loveland algorithm for SAT Solvers}
%%%A successful algorithm for solving SAT problems is the DPLL algorithm, here we describe it in overview

%%%Some improvements over the core algorithm have been appended over the years since DPLL was first proposed.

\subsection{CHAFF Watched Literals}
%%%Through having clauses watch the literals, rather than the other way around, the most expencive step, the propogation, can be reduced significantly.
%TODO cite

\subsection{Conflict Learning}
%%%Simple resolution as proposed by Stallman was an effecient means to stop thrashing(looking at the same subtree repeatedly)

%%%Improvement of this resolution can be made by finding smaller constraints, this can be accomplished by eliminating literals in a constraint

%%%Further improvement can be made by searching for the smallest constraint through such variable elimination

\subsection{Literal Order}
%%%The order in which the literals are assumed in the DPLL algorithm, is heuristically accomplished

%%%The selection of a literal can be broken into two stages for modularity;
%%%first selecting a variable that is very volatile,
%%%second selecting a phase (negative or positive)

\subsection{Pseudo-Boolean Optimisation of SAT Solvers}
%%%Optimisation of SAT solvers is typically done through extending their possible constraints to include Psuedo Boolean inequalities

%%%Then through repeatdly finding a solution then adding a constraint to ensure the next solution is at least as good, the best solution is found

%%%Further optimisation can be made through quickly finding a satisfactory solution, this reduces the space in which to find a better solution

\subsection{Other Methods}
\subsubsection{Integer Programming}
%%%Discussion of this method as the best MISC solver uses this, it has a very complex implementation
\subsubsection{SMT Solvers}
%%%SMT Solver, a slightly higher logic than SAT uses; it has to broad a definition when SAT suffices
\subsubsection{Constraint Solver}
%%%We could just use Prolog, like SMT I think it is too broad when there are good SAT solvers

\section{Common Upgradeability Description Format}
%%%Here we give an introduction to the CUDF format from Mancoosi, this format is used as a standard for Dependency Resolution problems
{}\cite{treinen2009common}

%%%It was made to standardise the problem, for two reasons, to make building solvers generalisable, and to compete solvers in the MISC competetions to compare solutions.

%%%In both regards it has succeded, there have been many competitions run, 
%%%and their creation of a Modular Package Manager(MPM) is currently moving through the Debian stages into their core repository

\subsection{CUDF Syntax}
%%%The CUDF syntax is made to resemble similar CDR meta-data through using key-value pairs (not XML, too verbose?)

%%%Package Formulas are the standard mechanism of dependence

%%%Versions as Integers

%%%The Syntax has been defined to be extensible within the language, so additional model specific information can be included without increasing the size of the standard

\subsection{CUDF Semantics}
%%%As CUDF was a format the was supposed to be open to allow people to build differnt solvers for it, and be used as a real package manager, it walked a fine line.

%%%It must be simple enough so that developers can quickly understand it to build or modify existing solvers capable of competing in MISC competitions

%%%It must be broad enough to define and solve real world problems


\section{Design Time Dependency Resolvers}
%%%Design time dependency resolvers benefits the software engineer building a large complex system that can involve many libraries with complex relationships.

\subsection{Apache Maven}
%%%Maven is a design time project and build automation tool, that can resolve library dependencies from a repository (https://oss.sonatype.org/content/repositories/)

\subsection{Nuget} 
%%%A new distribution model from microsfot for .Net libraries (http://nuget.codeplex.com/)

\subsection{RubyGems bundler}
%%% Bundler is a package dependency manager for RUBY gems (http://gembundler.com/)

\section{Run Time Dependency Resolvers}
%%%Run time dependency resolvers benefit users of the component system, who would rather use a systems functionality than maintain a complex system of interacting components.

\subsection{OSGi Bundle Repostiory}
%%%The OBR proposed by Peter Kriens and Richard Hall, is a meta data format for OSGi bundle resolution
Peter Kriens \cite{kriens_osgi_2008}, 
a primary author of the OBR \cite{the_osgi_alliance_rfc-0112_2006}, described a use of a component repository within a resource constrained environment.
When a device registers, 
through the repository, the driver for that device is loaded and then used, until the device is no longer available
then to conserve resources the driver is uninstalled dynamically. 
This demonstrates two requirements for a component repository, dynamic installation and uninstallation and being scalable to small devices.

For the OBR, we reviewed the standard \cite{the_osgi_alliance_rfc-0112_2006}, 
contacted both authors \cite{kriens_osgi_2008, richard_s._hall_obr_2008} 
and downloaded the open source Apache Felix OBR implementation and reviewed the source code.
OBR was our most completely reviewed repository.

OSGi is a 
mature standard component model from the OSGi Alliance that has seen a recent uptake in industry \cite{kriens_osgi_2008} 
from organizations like the Eclipse Foundation with their Equinox framework and Apache with Felix. This has multiplied the 
number of available bundles \cite{the_osgi_alliance_rfc-0112_2006}. OSGi Bundle Repository (OBR) was initially defined by 
Richard S. Hall, and later Peter Kriens, to help with the distribution of components, and is proposed in 
RFC-0112 \cite{the_osgi_alliance_rfc-0112_2006}. The design follows a federation of repositories each describing 
the capabilities and requirements of it's components and providing a URL to access it. Search is done using syntax with OSGi filter 
based expressions. This repository can also resolve dependencies and install these composites into a system. \\
OBR has been seen as a solution to to simplify deployment of OSGi applications
\cite{jung_integrating_2007}, distribution and deployment to embedded
ubiquitous systems \cite{jung_embedded_2006}, smart home applications \cite{gouin-vallerand_managing_2007} and 
dynamic distribution of drivers \cite{kriens_osgi_2008}. It is the only easily available deployment 
architecture available for OSGi, others have been developed to either extend or compete \cite{frnot_component_2005} with OBR, 
but are either in development, have been abandoned or are proprietary.\\ 
The most mature implementation of OBR client is offered by Apache, it is bundled with their core OSGi framework, Felix. 
The largest public OBR implementation is the federated repository provided by the OSGi alliance,
currently (as of 6 January 2009) aggregating components from Apache (32 bundles) and Eclipse (1534 bundles).
There are also many private repositories, some discussed with as much as 5000 bundles involved \cite{kriens_osgi_2008}.\\  

\subsection{OSGi Declarative Services}
%%%DS is standardised in the OSGi standards

\subsection{Spring Dynamic Modules}
%%%Spring is a competitor to DS, such that it resolves service level dependencies

\subsection{yum}
%%%Red hat package manager

\subsection{Apt-get}
%%%Apt-get is the core application for package management in Debian based GNU/linux distributions

Debian is a free and open source GNU/Linux based operating system. 
Debian's package system (dpkg) is used to install, remove and provide information about the operating system packages. 
APT is a repository client built on top of dpkg and simplifies it's functionality.\\
Aptitude is an application that adds a basic user interface to APT and also increases functionality in aspects like 
locating and removing redundant packages. 
Search of a package repository is done using regular expressions mixed with a
custom set of search terms that increase expressiveness. Using a simple
constraint-directed best-first search algorithm with some basic conflict
tracking Aptitude resolves dependencies between packages, and generates
composites to install.\\ 
There are many public and private implementations of this repository system. 
The largest public implementation is the Debian public repository, with 28078 packages in the ``Lenny'' stable repository.
With the most popular Debian distribution Ubuntu\footnote{http://www.ubuntu.com} having ten million users \cite{vance_software_2009} the user base for this repository is massive.
This repository has many regulations to publish and distribute, enumerated in the Debian Developers Reference \cite{andreas_barth_debian_2008}. 
User and automated testing is recommended, and if any critical bugs are found they are removed from the repository. 
This very manual way of publication and
distribution has its drawbacks, mostly the long community process that must be followed.\\

\subsection{Aptitude}
%%%Aptitude is a competitor to apt-get which has some more advanced features
Aptitude with APT, has immense amounts of information free on-line, the hardest part was reviewing as much as possible.
We also used and read the help documentation, contacted the author of the software \cite{burrows_modelling_2005} and
the Debian developers reference for the specific implementation of the Debian repository.

\subsection{Mancoosi MPM}
%%%The mancoosi Modular Package Manager uses CUDF, currently going through the process in the Debian component repository

\subsection{Eclipse P2}
%%%The Eclipse P2 Solver, by Le Berre and Rapicault

For the Eclipse P2 repository system there was extensive literature provided by the Eclipse foundation in the form of a developer forum.
We also reviewed an early implementation through use of the software within the Eclipse environment.
Due to its recent release there is no literature reviewing or discussing this software.

Eclipse P2
is the new provisioning system for the Eclipse IDE platform.
It provides an update manager, the functionality to component pool, and a new dependency resolver.\\
The update manager is what most users will be familiar with, being the primary interface to the P2 functionality. 
A public repository, called a site, is added, and can be searched for components and their dependencies to install, and run.
This simplifies the evolution of Eclipse based applications to a simple user interface.\\
Component or bundle pooling uses a centralised set of components to run different applications.
This comes from the common problem of running multiple Eclipse based applications on the same system with different combinations of components.
A file is used to describe what components should be used in each particular application and P2 builds the composition into an application.\\
The dependency resolver of P2 is based on SAT4J\footnote{http://www.sat4j.org/} technology, a SAT resolver, which finds an optimal solution based on
a provided fitness function, if a solution exists it is guaranteed to find it.\\  
Eclipse already is
the core of many applications with its Rich Client Platform. This is a large base of applications that already support and can integrate with P2.

\subsubsection{P2CUDF implementation}
%%%Our implementation is based off of Daniel Le Berre and Rapicult P2CUDF, which uses SAT4J a SAT and PB solver, tested and validated in competitions.
The Mancoosi organisation who have created the CUDF standard have also organised competitions for the solvers.
One implementation of note is the P2CUDF implementation, that uses SAT

\section{Comparison of functionality}
%%%The comparisons of these resolvers will focus on the functionality that they provide given their component model (we will not compare their implementations)

%%%Multiple package installations 
%Maven Debain No, OSGi Eclipse DS and CUDF yes

%%%Focus on interface not implementation dependence 
%Maven no, Debian Community defined virtual packages, 

%%%Version Control

%%%Run time replacement Dynamic Dependence
%Maven no (no runtime), Eclipse Kind of a bit buggy requires restarts,
%OSGI DS Debian Yes, CUDF is abstract so has no real implementation

%%%Conflicts
%Maven?, Spring and DS no,  OSGi Singleton, Debian and CUDF are Expressive

%%%Reccommendation System, soft dependency (is this even a good idea)
