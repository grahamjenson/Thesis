\chapter{Background}
\label{background}
\epigraph{
In order to agree to talk, we just have to agree we are talking about roughly the same thing.
}
{\textit{The Feynman Lectures on Physics, Motion, Richard Feynman, 1961.}}

%%%What is Software Evolution
Software evolution \citep{lehman1980} is the process of repeated change made to a software system to maintain it or to extend its functionality over the system's lifetime.
This evolution process is necessary as any system must adapt to the changing software environment, accommodate new user requirements, 
fix errors and/or prevent errors from occurring in the future \citep{IsoIec2006}.
Software maintenance and evolution are often used interchangeably \citep{Godfrey2008}, however some differences exist.
One difference is that maintenance has connotations of a planned activity, where evolution is the gradual refinement of a system \citep{lehman1980}.
That is, software maintenance is a range of activities through which software is changed, and software evolves as the system is repeatedly changed.
This is similar to the definition given in \citep{lehman1980}.

%%%What is component system evolution
A component system is created out of a set of components combined into a functioning system by a composer (or assembler) \citep{Szyperski2002}.
Apart from creating the systems, composers are also responsible for changing their systems.
This change can be motivated by the same forces as software change, e.g. new system requirements.   
As a composer makes changes to their component system over time, the component system is said to \textit{evolve}.
Such a relationship between component system change and CSE is similar to the relationship between software maintenance and software evolution.

%%%In this chapter\ldots
This chapter illustrates the histories and presents the state of the art of software evolution, component systems, and CSE.
Section \ref{background.histories} first describes the history and connections between domains. 
Section \ref{background.componentsystemevolution} explores the separation of the evolution of individual components and the evolution of component systems.
The definitions of software components and component models used in this thesis are then presented in section \ref{background.components}.
To conclude this chapter, examples of various component models that fit the given definitions are discussed in section \ref{background.models}.

\section{Software Evolution and Component-Based Software Engineering}
\label{background.histories}
The foundations for software evolution, software components, and component systems were established in the late 1960's.
Software evolution was first described by Lehman in 1969\footnote{In \cite{Lehman1969} this process was not referred to as evolution}.
The concept of software components was proposed by \cite{McIlroy1969}.
The operating system Unix \citep{raymond2003art}, whose core philosophy is a modular system, was developed in 1969.

The domains of software engineering, software evolution and component-based software engineering have gone through many advancements since their inceptions.
This section describes these advancements, building up to a discussion about CSE.

\subsection{Software Evolution}
\cite{Brooks1975} states that over 90\% of the cost of a system occurs after deployment in the maintenance phase,
and that any successful piece of software will inevitably be maintained.
This realisation, that software requires significant expense to maintain, led researches to study how software changed after deployment.
This is the study of software evolution \citep{lehman1980}.

In 1980, two fundamental empirical studies on the emerging domain of software evolution were published.
The first study by \cite{Lientz1980} explored the activities that occur during software maintenance (later formalised in ISO/IEC 14764 \citep{IsoIec2006});
\begin{enumerate}
	\item \textit{Adaptive Maintenance}: adapting to new system or technical requirements.
	\item \textit{Perfective Maintenance}: adapting to new user requirements.
	\item \textit{Corrective Maintenance}: fixing errors and bugs.
	\item \textit{Preventive Maintenance}\footnote{later added in taxonomies such as \citep{iee1990ieee}}: adapting to prevent future problems.
\end{enumerate}

This study showed that around 75\% of the maintenance effort was on the first two types, and corrective maintenance took about 21\% of the effort.

The second study by \cite{lehman1980} explored how evolution affected software.
In this publication, Lehman described a set of laws that characterise software evolution:
\begin{enumerate}
  \item \textit{Continuing Change:} Software systems\footnote{E-type systems: software implemented in a real-world computing context \citep{lehman1980}} must be continually adapted 
  otherwise, they become progressively less satisfactory.
  \item \textit{Increasing Complexity:} As the system evolves its complexity increases unless work is done to reduce it.
  \item \textit{Self Regulation:} The system evolves with statistically determinable trends and invariences.
  \item \textit{Conservation of Organisational Stability:} The average effective activity rate to evolve a system is invariant over its lifetime.
  \item \textit{Conservation of Familiarity:} As the system evolves, its incremental growth remains invariant to ensure users maintain mastery over the system.
  \item \textit{Continuing Growth:} The system must continually grow to maintain user satisfaction.
  \item \textit{Declining Quality:} The quality of the system will decline unless rigorously maintained.
  \item \textit{Feedback System:} The function a system performs is changed by the effect it has on its environment.
\end{enumerate}

%%%These laws describe the fact that it is impossible to create a single satisfactory system, and an iterative approach is best to strive for continual satisfaction
Both these studies from \cite{Lientz1980} and the laws from \citep{lehman1980} argue that
the software engineer's objective of creating a satisfactory system is difficult, expensive, and not always achievable.
They state that the continual evolution of a software system is necessary, and this evolution reduces quality, increases complexity, and is costly.

From the perspective of software evolution, the software engineer's goal is then to create a system that can be quickly altered to adapt to a changing environment 
while working to reduce the inevitable complexity caused by changing software.
Towards such goals, iterative development processes have been created, such as the spiral development method \citep{Boehm1988}.
This process describes the stages of development as communication, planning, modeling, construction, and deployment. 
These stages are continually iterated until the software project is no longer actively maintained. 

The practical problems of software evolution can be seen in the struggle with legacy software \citep{Bennett1995}.
Legacy software is functional software that is old and outdated, but it has not been replaced due to its critical status, not being well understood, or the cost of redesigning.
A piece of software is described as ``legacy'' if it cannot be maintained  (due to its complexity or size) within an acceptable cost \citep{Bisbal1999}.
As a legacy system does not evolve, new user and technical requirements cannot be fulfilled, and the satisfaction with the system will decrease over time.
This has led the problem of legacy software to be described as enduring \citep{Bennett2000}. 

Software evolution is still seen at a young field \citep{Godfrey2008} as many open questions remain unanswered.
Recent empirical studies that explore the cost of software evolution are summarised by \cite{Grubb2003}, 
showing that the costs of software maintenance range from 49\% to 75\%, and that these costs have not fallen since the 1970's. 
To lower the cost of software evolution, various methods and tools have been proposed.
For example, agile software development methodologies \citep{beck2001manifesto} are defined to encourage rapid and flexible responses to change,
and refactoring tools \citep{fowler1999refactoring} have been developed to restructure code to decrease complexity and increase maintainability. 
Another way of lowering costs of the software evolution process is to create systems from encapsulated units called \textit{software components} \citep{Szyperski2002}.

Current explorations of the history, and state-of-the-art, of software evolution are presented by \cite{Bennett2000}, \cite{Lehman2003}, and \cite{Godfrey2008}.
In all these papers, the importance of software evolution is emphasised, and the need for more knowledge about the evolution process and its properties is discussed.

\subsection{Component-Based Software Engineering}
The concept of Component-Based Software Engineering (CBSE) was first outlined by \cite{McIlroy1969}, 
by describing the idea of a software components subindustry which created components to be used to in software.
This report is an expansion on an earlier idea for \textit{pipes} \citep{mcilroy1964pipes}, 
where McIlroy described designing software to fit together, like screwing a hose to a tap.

The reuse of code in order to decrease development time, was originally the major perceived benefit of using software components.
Later, other benefits of constructing systems from modular components were identified by \cite{Parnas1972}:
\begin{itemize}
  \item \textit{Managerial Separation}: develop components in separate groups with little communication
  \item \textit{Product Flexibility}: make drastic changes to one component, without changing others
  \item \textit{Comprehensibility}: be able to study the system one module at a time
\end{itemize}

The ``software component'' concept was soon picked up by other researchers such as \cite{Yourdon1976}, where they described their ideas on \textit{structured design} as:
\begin{itemize}
  \item the art of designing the components of a system and the interrelationship between those components in the best possible way.
  \item the process of deciding which components are interconnected in which way to solve some well-specified problem.
\end{itemize}
\cite{Yourdon1976} list the goals of structured design as efficiency, maintainability, modifiability, generality, flexibility, and utility.
These goals are aimed to be achieved by dividing the system into functional units that can be treated independently.
Each unit corresponds to exactly one small well-defined piece of the system, and the units relationship corresponds to a relationship between pieces of the system.

As the number of software component grew, a problem emerged of selecting the set of components that satisfy the requirements of the system.
\cite{PrietoDiaz1987} described this as the \textbf{selection problem}, where a composer can have many alternative compositions of components to select from.
This increases the effort required to use software components as each possible combination must be examined and ranked based on how well they match the composer's specifications.
Current research into solutions to the selection problem looks at the questions:
\begin{itemize}
  \item how to describe a component and its attributes \citep{treinen2009common,Xinjuan2007}?
  \item how to search for compositions that fit a set of requirements \citep{abate2011,Kwong2010,Treinen2009,DeAlmeida2004}?
  \item how to rank a particular composition \citep{Chen2011,Aleti2009}?
\end{itemize}

The current state of CBSE is fractured, where there are many different component frameworks (some presented in section \ref{background.models}),
each with different goals and attributes.
Additionally, the original concept of a software component subindustry has never truly come to fruition \citep{Szyperski2002}.
A possibility for this is the unsure definitions of what software components are \citep{Crnkovic2011}.
The hope for CBSE, as described by \cite{Crnkovic2011}, is that the technology and research will converge, and terms and concepts in the software component domain will become standardised.
This problem is later described in section \ref{background.components}, where the software component definition in this thesis will be discussed.

\subsection{Unix and GNU/Linux Modular Operating Systems}
The research into software components by \cite{McIlroy1969} coincided with his help in the development of the operating system Unix \citep{raymond2003art}. 
McIlroy had significant impact not only on the implementation of Unix, where many of his ideas like pipes where included,
but also on the Unix philosophy. 
The Unix philosophy is summarised by McIlroy as \citep{Salus1994}:
\begin{quote}
Write programs that do one thing and do it well. Write programs to work together. 
Write programs to handle text streams, because that is a universal interface.
\end{quote}

This philosophy led to the first two rules (out of fifteen) of Unix \citep{raymond2003art}:
\begin{itemize}
  \item \textit{Rule of Modularity}: Write simple parts connected by clean interfaces.
  \item \textit{Rule of Composition}: Design programs to be connected to other programs.
\end{itemize} 

To eliminate the perceived problems of the proprietary Unix system, in 1983 Richard Stallman created the GNU project \citep{stallman1985gnu} to implement a free Unix-like operating system.
With a kernel developed by Linus Torvalds based on the MINIX \citep{tanenbaum1989minix} operating system, the GNU/Linux \citep{torvalds2002just} operating system was created.
GNU/Linux is seen as a return to the original philosophy of Unix \citep{Gancarz2003} where the creation of small modular programs that interact is central.
Aligned with this philosophy, a distribution of GNU/Linux called Debian \citep{Barth2005} was announced in 1993.
This release came with the Debian Manifesto \citep{murdock1994brief} 
that stated that Debian would be constructed from high quality components (or packages) which can be maintained by experts.

Initially, a significant amount of technical expertise was required to change the composition of packages in a Debian system.
Each package had a set of constraints that described the systems that it would be functional in
and whenever a change was made these constraints where required to be satisfied.  
Furthermore, satisfying these constraints was difficult due to the selection problem (as discussed earlier).
For example, installing a new package required satisfying all its constraints.
This may may require the installation of other packages whose constraints must also be satisfied. 

With the release of the application \textit{apt-get} in the late 1990's, the necessary technical knowledge to compose or change a Debian system was significantly reduced.
A user could request apt-get to change their system, and it would find, select then change to a new composition that satisfies the request.
This automated the search for a satisfactory solution, solving the problem which had restricted the evolution Debian systems prior to apt-get's release.
The apt-get package manager and similar applications have been called the ``single biggest advancement Linux has brought to the industry'' 
\footnote{http://ianmurdock.com/solaris/how-package-management-changed-everything/} 
because it has made it ``far easier to push new innovations out into the marketplace and generally evolve the OS''.
Such lowering of the technical knowledge required to become a composer of a component system has had other effects discussed in the next section.

\section{Component Evolution vs. Component System Evolution}
\label{background.componentsystemevolution}
Originally it was assumed that developers were the composers \citep{Parnas1972,PrietoDiaz1987} of component systems.
That is, developers would compose, verify, then release a component system to users.
However, with applications like apt-get the user has started to play the role of the composer for their systems.
A user, without technical knowledge, can now change the composition of their component system to satisfy their requirements.

The situation where the user is the composer of the system has been called system tailoring \citep{Morch1997} and end-user assembly \citep{Szyperski2002}. 
It has been noted that the potential of component systems have increased with this user composition \citep{Szyperski2002} as the user can craft solutions without requiring expert assistance.
However, a system is also more fragile as the quality of a system may not be verifiable by a potentially non-technical user.

When the user is the composer of their system, it also breaks apart two important processes,
component evolution and CSE.
The developer, no longer the composer of the component system, is now solely in charge of evolution of the components they maintain. 
With the user becoming the composer, the evolution of their component system is now their responsibility. 

In this section, the differences between, and the impact of separating, component evolution and CSE are discussed.

\subsection{Component Evolution}
%%%The core differences between software evolution and component evolution.
Component evolution is the process by which components change over time through continual maintenance.
This maintenance requires technical knowledge of the internal workings and structure of the component, therefore it must be accomplished by a developer.
This makes component evolution similar to software evolution as it is a process driven by developers.
A significant difference between software evolution and component evolution occurs because a developer has limited control over the system in which their component is used.
This difference makes validating a component difficult as testing all possible systems it can be deployed in may be practically impossible.

To give the developer a means to describe valid compositions the component will be valid in
they are typically provided a means of expressing constraints.
These constraints can describe conflicts between components, and/or dependencies on other components.
For example, if a component $a$ requires component $b$ to be included in the composition for $a$ to be functional, $a$ is said to depend on $b$.
Further, if $a$ requires that component $c$ not be in the composition, it is said that $a$ conflicts with $c$.
Such constraints are used to ensure that a component system that includes $a$ is valid. 
 
These constraints must be maintained along with the component. 
This is because the developer may not have control over the evolution of components it depends on or conflicts with.
For example, if a component $b$ is changed, and component $a$ uses $b$'s functionality, this change may effect $a$.
As the developers of $a$ do not have control over the maintenance of $b$, 
the changes must be discussed and co-ordinated to ensure that they are not detrimental to either component.

This example shows that a component may require constraints on a particular evolved state or range of evolved states of other components.
Such component states are tagged with \textit{version}s, which provide an order to the evolution of a component.
Unlike software evolution, component evolution depends on the version of components as they are often used in the constraints that describe valid compositions.
For example, a component $a$ which is version $1$, is less evolved than the component $a$ version $2$.
Further consider, $a$ version $1$ depends on $b$ version $1$, and $a$ version $2$ depends on $b$ version $2$.
This example shows that during component evolution these constraints can change and must be considered.

This discussion on component evolution describes some differences to software evolution.
It is given not as a complete exploration of this domain but an introduction into some of its consideration. 
A proper methodology for the development and evolution of software components it still being searched for \citep{Szyperski2002}.
Discussions on types of evolutionary changes with comparisons to other domains are given in \citep{Papazoglou2011},
and empirically explored by \cite{vasa2007patterns}.

\subsection{Component System Evolution}
A component system is changed by the composer by altering the composition of components contained within their component system.
The system evolves over time as these changes are made.
As described above in \citep{IsoIec2006}, these changes could be adaptive, perfective, corrective or preventive.
However, unlike the changes in software evolution or component evolution, CSE can only make architectural changes by adding or removing components that already exist.
For example, a composer could not change the system to satisfy a requirement if no component has yet been developed to satisfy that requirement.

%%%CSE must satisfy constraints, for the user to be a composer CDR must be used
Changing a component system is restricted by the constraints that components have on the composition. 
It would be very difficult for a user to alter a composition without some helping functionality provided by applications like apt-get.
In this research such functionality is called  \textbf{Component Dependency Resolution} (CDR).
CDR takes requests to change a system from the composer and component constraints and searches for systems that satisfy both.
Given some preferences, an appropriate component system is selected.
For example, a user wants to install a new text-editor component into their system, and the selected text editor has a dependency on a spell-checker.
This means a spell checker component must be installed for the text editor to be functional. 
Therefore, CDR tries to find a system that has a text-editor and a spell-checker, and that is a preferable solution.

CDR can be referred to by various names; provisioning system or dependency management in Eclipse domain \citep{leBerre2010},
or package manager in the GNU/Linux \citep{Barth2005} domain.
CDR can be used at design time to determine the required dependencies to build and test a project (as in Apache Maven \citep{casey_better_2008}),
at run time to evolve or extend a component-based system (as in Eclipse P2 \citep{leBerre2010}),
or it can be used to build and restructure software product lines \citep{savolainen_analyzing_2007}.
CDR is also used in package management systems, like apt-get \citep{Barth2005},
for adding, removing and updating components in package based operating systems like Ubuntu\footnote{http://www.ubuntu.com accessed 6/3/2012}. 

%%%How can a user change their system with CDR
The core functions that CDR provides to change component system are \textbf{install} and \textbf{remove}, these add or remove a component to or from the system.
Furthermore, the function of \textbf{upgrade} is defined to remove then install a higher version of the same component.
For example, to upgrade the components in a Debian GNU/Linux system, the command \texttt{apt-get upgrade} is all that is needed to be executed.
To extend the system to install a component \texttt{comp} the command \texttt{apt-get install comp} can be executed.
The simplicity that CDR provides enables users to become composers of their component systems.

%%%Problem with versioning componenet systems
A problem arises, during component system evolution when trying to measure the evolved state of a component system.
A component system is a set of components, where each component can have different versions.
This may make a component system impossible \textit{version}, in a way similar to how components are versioned.
For example, a system that has version $1$ of component $a$ and version $2$ of component $b$, 
is neither more or less evolved than a system with version $2$ of $a$ and version $1$ of $b$.
This can get even more complicated when considering some component models allow multiple versions of a single component installed, e.g. 
is a system with version $1$ and $2$ of $a$ installed less evolved that a system with only version $2$ of $a$ installed?

This process of component system evolution is empirically studied by \cite{fortuna2011} 
who look at the first ten releases of the Debian and compare it to the evolution within biology.
Methods to change component systems are discussed in \citep{Ryan2005} and \citep{Luo2004},
and the mitigation of the negative effects caused by such evolution is discussed in the paper \citep{Stuckenholz2007}.

A formal definition of the component system evolution is given in chapter \ref{formal}.

\section{What is a Software Component?}
\label{background.components}
How ``software component'' is defined will impact how CSE is studied and discussed.
It is difficult to find a precise definition of what a software component is, as the intuitive concept may be quite different from any model or implementation \citep{Crnkovic2011}.
Finding a definition that satisfies all parties may be an impossible task.
However, by defining a software component with respect to component system evolution, 
this process can be studied without the paralysis of finding a complete definition.
In this thesis a software component is defined to have explicitly declared constraints and include mechanisms to automatically alter the a component composition.
These two attributes are seen as sufficient to allow CDR to be used, and thus a user to be the composer and drive CSE. 

%%%What is a component in a larger context
A component is a natural concept that describes a part or element of a larger system or process.
A broad characterisation of a component is ``components can be composed together''.
They can be physical, as in electrical or mechanical components, where their properties and how they are composed are documented to be used in construction.
Typically, components can be used in many different contexts, e.g. a resistor component, they can be used in electrical systems from space stations to cellphones.   
This natural concept of what a component is has led to problems in defining the concept of a software component.

%%%Discussion of articles where Szyperski and Meyers discuss give their versions of what a component is.
A discussion between two researchers in component software, Bertrand Meyer and Clemens Szyperski, highlight the difficultly of defining ``software component''. 
They describe across multiple articles \citep{Meyer1999,Szyperski2000a, Szyperski2000, Meyer2000} their definitions of what a software component is and the importance of its features.

%%%Szyperski's definition
Szyperski defines components in \citep{Szyperski2002} as having three characteristic properties:
\begin{enumerate}
  \item a unit of independent deployment
  \item a unit of third party composition
  \item has no externally observable state
\end{enumerate}

%%%Meyers Definition
Meyer's definition of software components is enumerated as:
\begin{enumerate}
  \item May be used by other software elements (clients)
  \item May be used by clients without the intervention of the components developers
  \item Includes a specification of all dependencies (hardware and software platform, versions, other components)
  \item Includes a precision specification of the functionality it offers
  \item Is usable on the sole basis of that specification
  \item Is composable with other components
  \item Can be integrated into a system quickly and smoothly
\end{enumerate}

%%%Using a component model
Others, like \citep{heineman2001component} have stated that components must conform to a component model: 
\begin{quotation}
A software component is a software element that conforms to a component model and can be independently deployed and composed without modification according to a composition standard.
\end{quotation}

Defining a component model as:
\begin{quotation}
A component model defines a set of standards for component implementation, naming, interoperability, customization, composition, evolution, and deployment.
\end{quotation}

%%%Other differences, architectural/implementation
Exactly what is, and what is not a software component is in dispute amongst the community,
and a definitive description of a software component is elusive \citep{vasa2007patterns}.
As such, many different components models have been developed, each targeting various domains with different functionality and technical aspects.
This diversity has inspired a classification approach from \citep{Crnkovic2011}, where components and component models are classified into a scheme.
This effort highlights the difficulty in creating an exact definition of a software component. 

%%%It is difficult to define a natural concept such as component with a set of fixed enumerable features.
The problems encountered when trying to exactly define a software component may stem from the fact that ``component'' is a natural concept.
The problem, as observed from the area of formal concept analysis \citep{Ganter1999} by \citep{Szyperski2002}, is that it is impossible to

\begin{quotation} 
``enumerate a fixed agreeable set of features that is necessary and sufficient for a natural concept such as component.''
\end{quotation}

%%%Our egotistical view of components is defined with relation to Component Dependency Resolution.
However, a definition can be found, not by feature enumeration but through stating the intention for the concept
and exploring the technically inevitable consequences \citep{Szyperski2002}. 
As the intention of this study is to investigate component system evolution,
the definition of software component will be with respect to this process.

This view of a software component's definition will not agree with every persons view of what a software component is, but (as described above) no precise view can.
By only looking at aspects that are necessary for this research, the arguments over unnecessary semantics can be eliminated. 

\subsection{Software Component}
The definition of a software component is given with respect to the evolution of a component system using component dependency resolution.
Both these areas have already been discussed in this chapter and will be used to define the concept of ``software component''.
This definition specifies the type of components and component models this research can be applied to.

In this research a software component is a unit of independent deployment, and third party composition,
and a component model must:
\begin{enumerate}
  \item require the explicit definition of component constraints on compositions where they are valid 
  \item include mechanisms in which to programmatically compose or change a component system
\end{enumerate}

To enable the user to become the composer by using CDR, the component constraints must be explicitly defined and computer readable,
and an interface must be provided by the component system to be changed. 
That is, CDR should be able to calculate a valid composition, and change the system to the calculated composition.

This definition leaves undefined many aspects of a software components, as can be seen when compared to the classification from \citep{Crnkovic2011}.
Most aspects of a component model are ignored as they are superfluous to the core topic of this research.
This makes the definition in this research broadly applicable, while also being focused on CSE.

The next section explores this definition of software component by discussing different component models that conform to it.

\section{Component Models}
\label{background.models}
%%%Some core component models are described, and their dependencies and evolution are discussed
Given the definition of a software component for this research, some current component models are described and discussed.
These models come from industry (OSGi, Eclipse Plugins, Fractal, Maven), open source community (Debian, RPM) and academia (SOFA2).

%%%Meta data of component models is discussed
Firstly, for these component models to conform to the previously described definition, their components must explicitly describe their constraints.
The typical mechanism in which components from these frameworks express their constraints is through meta-data files.
These files contain what a component requires and provides, as well as other information like versions and provider details.
These meta-data files are then a core element in the description of a component model.

%%%How to change a system is discussed
As defined above, a component model must also provide a mechanism to alter the systems composition.
This is usually a low level interface, where the addition or removal of a component is the core functionality.
A CDR implementation can then use these interfaces to evolve a system.

%%%Exisiting CDR implementations are discussed
Some component models have a CDR implementation available.
These implementations are also described as they are core to the evolution of the models component systems.

To compare these component models, the example of a text editor component that depends on a spell checker component is used.
It is hoped this simple situation will highlight the similarities and differences between the various component models.

\subsection{OSGi}
%%%What OSGi is? Bundle Service
OSGi is a mature component model from the OSGi Alliance.
It has implementation from organizations like the Eclipse Foundation with their Equinox framework \citep{mcaffer2010osgi}, 
and the Apache foundation with their framework Felix\footnote{http://felix.apache.org/ accessed 6/3/2012}.

OSGi components are refereed to as bundles, each contains a meta-data file describing the bundle's constraints, and a set of Java packages and classes as implementation.
A notable difference between OSGi and other component frameworks is that it separates the unit of deployment, the bundle, and the run-time unit, the service.
These services exist on a separate layer to the bundles, each service is created at run-time and is represented by a Java object.
This service layer can also describe constraints through frameworks like Spring Dynamic Modules\footnote{http://www.springsource.org/osgi accessed 6/3/2012}.
Under the definition of component in this research, this makes both the bundle layer and the service layer software component models.
These layers are discussed here.

\subsubsection{Bundle Layer}
To show how the bundle meta-data describes constraints of a component,
an example is presented in figure \ref{osgibundle} where a text editor bundle depends on a spell checker.
\begin{figure}[htp]
\begin{center}
\begin{alltt}
Bundle-Name: TextEditor
Bundle-Vendor: Graham Jenson
Bundle-SymbolicName: nz.geek.textEditor
Bundle-Version: 0.0.1.alpha
Bundle-RequiredExecutionEnvironment: J2SE-1.4
Export-Package: nz.geek.textEditor;version="0.0.1.alpha"
Require-Bundle: nz.geek.fonts
Import-Package: nz.geek.spellchecker;version>"0.0.1"
\end{alltt}
  \caption{Example of OSGi Meta-data}
  \label{osgibundle}
\end{center}
\end{figure}

%%%OSGI Meta data description
This meta-data shows the name and version of the component, as well as the exported packages (referring to Java packages).
Also presented are constraints, such as the necessary execution environment, and the required bundles and packages in the system.
\texttt{Require-Bundle} describes the direct dependence on other bundles, and
\texttt{Import-Package} describes the dependence on a packages provided by other bundles.

\subsubsection{Service Layer}
This bundle meta-data only contains information necessary for the execution of a component.
However, for the component to be functional the service layer of OSGi is used.

The service layer is defined in the core OSGi specification \citep{osgicore2007}, however its definition does not describe any meta-data format.
To fill this gap, a number of frameworks have emerged that define service constraint meta-data, e.g
Spring Dynamic Modules\footnote{http://www.springsource.org/osgi accessed 6/3/2012}.
OSGi's compendium specification \citep{osgicompendium2007} also defines a service layer meta-data format called Declarative Services (DS).
To show how the DS meta-data can be used to express constraints on the service layer,
and example is presented in figure \ref{dsmetadata}.

\begin{figure}[htp]
\begin{center}
\begin{alltt}
<?xml version="1.0"?>
<component name="textEditor">
    <implementation class="nz.geek.textEditor.TextEditorImpl"/>
    <service>
        <provide interface="nz.geek.textEditor.TextEditor"/>
    </service>
    <reference name="spellChecker"
        interface="nz.geek.spellchecker.SpellChecker"
        bind="setSpellChecker"
        unbind="unsetSpellChecker"
        cardinality="0..1"
        policy="dynamic"/>
</component>
\end{alltt}
  \caption{Example of OSGi Declarative Services meta-data}
  \label{dsmetadata}
\end{center}
\end{figure}

This meta-data includes references to implementation elements like interfaces that are provided and required, and methods to interact with the services.
The dependency constraints can have cardinalities, e.g. a text editor can use multiple spell checkers.
The \texttt{service} tag describes the services provided, and the \texttt{reference} tag expresses a dependence on another services.

%%%DS provides no versioning
One aspect lacking in the DS meta-data is the ability to define version properties on a constraint.
Although the version of a service is implicitly defined by the version of the bundle that the service is provided by.
This may lead to problems as services evolve over a systems life-time.

\subsubsection{OSGi Change}
The programmatic evolution of an OSGi system is defined in the interfaces created by the OSGi alliance.\footnote{http://www.osgi.org/javadoc/r4v43/ accessed 6/3/2012}
The installation and removal of both the bundles and services from the OSGi system are defined as such:
 
\begin{itemize}
  \item To install a bundle:\\ \texttt{org.osgi.framework.BundleContext}\verb+#+\texttt{install}
  \item To uninstall a bundle:\\ \texttt{org.osgi.framework.Bundle}\verb+#+\texttt{uninstall}
  \item To register a service: \\ \texttt{org.osgi.framework.BundleContext}\verb+#+\texttt{registerService}
  \item To unregister a service: \\ \texttt{org.osgi.framework.ServiceRegistration}\verb+#+\texttt{unregister}
\end{itemize}

These methods can sometimes be implemented in a console, this allows a user to directly execute them to add or remove bundles.

\subsubsection{OSGi Bundle Repostiory}
%%%The OBR proposed by Peter Kriens and Richard Hall, is a meta data format for OSGi bundle resolution
A CDR implementation for OSGi was proposed by Peter Kriens and Richard S. Hall in RFC-0112 \citep{the_osgi_alliance_rfc-0112_2006}.
This is called the OSGi Bundle Repository and consists of collection of components described in an XML format and a functionality to reason about them.
To show how OBR describes component constraints an example of an OBR document is presented in figure \ref{obrmetadata}.

\begin{figure}[htp]
\begin{center}
\begin{alltt}
<repository name='OBR REP' time='123'> 
 <resource version='0.0.1' name='nz.geek.textEditor' 
 uri='nz.geek.textEditor.0.0.1.jar'> 
  <require optional='false'  multiple='false'  name='package' 
    filter='(&amp;(package=nz.geek.spellChecker)(version&gt;=1.0.0))'> 
   Import package nz.geek.spellChecker ;version=1.0.0 
  </require> 
 </resource> 

 <resource version='1.0.0' name='nz.geek.spellChecker' 
 uri='nz.geek.spellChecker-1.0.0.jar'> 
  <capability name='package'> 
    <p v='nz.geek.spellChecker' n='package'/> 
    <p v='1.0.0' t='version' n='version'/> 
  </capability> 
 </resource> 

</repository>
\end{alltt}
  \caption{Example of OSGi Bundle Repository meta-data}
  \label{obrmetadata}
\end{center}
\end{figure}

This meta-data was designed so that it can merge the bundle and service meta-data as described above.
It also ignore many of the implementation aspects of OSGi bundles.
OBR is then an abstract component model that represents the necessary elements from both OSGi bundle and service layers in order to help the user change a OSGi system. 

OBR has been seen as a solution to to simplify deployment of OSGi applications \citep{Jung2007}, 
distribution and deployment to embedded ubiquitous systems \citep{Jung2006}, 
smart home applications \citep{Gouin-Vallerand2007} and 
dynamic distribution of drivers \citep{Kriens2008}. 

The most mature implementation of an OBR client is offered by the Apache foundation, which is bundled with their core OSGi framework Apache Felix. 
This can be used with any of the large public or private OBR collections of bundles.
An example of one such public repository is the Paremus repository\footnote{http://www.osgi.org/Repository/ accessed 6/3/2012} which contains (as of December 2011) over 2000 bundles.

The specification of OBR does not define a method or parameters to select a component system.
Therefore, the solution to the selction problem is implementation specific.
The method used by the Apache OBR\footnote{http://felix.apache.org/site/apache-felix-osgi-bundle-repository.html accessed 6/12/2011} implementation 
to select a system is described on its help page as:

\begin{quotation}
OBR might have to install new bundles during an update to satisfy either new dependencies or updated dependencies that can no longer be satisfied by existing local bundles. 
In response to this type of scenario, the OBR deployment algorithm tries to favor updating existing bundles, if possible, as opposed to installing new bundles to satisfy dependencies.
\end{quotation}

This shows that when updating a system of bundles, if there are multiple systems available maintaining currently installed bundles in the system is the preference.

\subsection{Eclipse Plugins}
%%%What is Eclipse
Eclipse is a widely used IDE and an extensible plugin platform for creating Java applications.
It is built on top of the OSGi framework, but ignores OSGi's service layer and re-implements it with its own Eclipse plugin runtime.
Therefore, the distrusted components are OSGi bundles and the run time elements are plugin services.

These plugins are defined using extensions and extension points, where extensions provide a service for an extension point.
To show how plugin meta data is used to define constraints, an example is presented in figure \ref{eclipseplugin}. 

\begin{figure}[htp]
\begin{center}
\begin{alltt}
<?xml version="1.0"?>
<plugin
    name="Text Editor"
    id="nz.geek.textEditor"
    version="0.0.1.alpha"
    provider-name="Graham Jenson">
    
    <requires>
        <import plugin="nz.geek.fonts"/>
    </requires>

    <runtime>
        <library name="texteditor.jar"/>
    </runtime>
    
    <extension-point id="nz.geek.spellchecker" 
        name="Spell Checker" 
        schema="spellchecker.exsd"/>
</plugin>
\end{alltt}
  \caption{Example of an Eclipse Plugin plugin.xml meta-data file}
  \label{eclipseplugin}
\end{center}
\end{figure}

This plugin defines the name and version of the plugin, and using the tags \texttt{requires} defines the requirements of this plugin to function.
The \texttt{extension-point} tag defines not only what the plugin provides, but also the required information in order to provide it, described in a schema.
This is a special feature of the Eclipse plugin framework, as other component models generally do not specify these parameters on this type of constraint. 

The schema of an extension point, as shown in figure \ref{eclipseextensionschema}, describes the elements to use an extension.

\begin{figure}[htp]
\begin{center}
\begin{alltt}
<schema xmlns="http://www.w3.org/2001/XMLSchema">
 <element name="spellchecker">
  <complexType>
   <attribute name="spellchecker" type="string" use="required">
    <annotation>
     <appinfo>
      <meta.attribute kind="java" basedOn=":nz.geek.ISpellChecker"/>
     </appinfo>
    </annotation>
   </attribute>
  </complexType>
 </element>
</schema>
\end{alltt}
  \caption{Example of an Eclipse Plugin extension point schema file}
  \label{eclipseextensionschema}
\end{center}
\end{figure}

In this description, this extension point requires a string that describes a java class that implements \texttt{nz.geek.ISpellChecker}.
This is the only requirement for this extension point, but other parameters of types, e.g. Boolean, integer, can be defined.

\subsubsection{Eclipse Change}
The programmatic evolution of an Eclipse system is through the use of the previously OSGi methods and interaction with the plugin registry.

The extensions and extension points, for an Eclipse system, can be altered in the plugin registry.
This registry contains all references to the extensions and extension points in a system.
The methods used to add and remove these are:

\begin{itemize}
  \item add extensions and extension points described in an XML file: \\ \texttt{org.eclipse.core.runtime.IExtensionRegistry}\verb+#+\texttt{addContribution}
  \item remove extension: \\ \texttt{org.eclipse.core.runtime.IExtensionRegistry}\verb+#+\texttt{removeExtension}
  \item remove extension point:\\ \texttt{org.eclipse.core.runtime.IExtensionRegistry}\verb+#+\texttt{removeExtensionPoint}
\end{itemize}


\subsubsection{Eclipse P2}
%%%The Eclipse P2 Solver, by Le Berre and Rapicault
Eclipse P2 \citep{le_berre_dependency_2009}, \citep{leBerre2010} is the provisioning system for the Eclipse IDE platform.
It provides the CDR functionality to alter an Eclipse based component system. 
Eclipse P2 is mainly accessed through the Eclipse user interface, where the user can select to update the entire system, or install a component.

Some of the preferences used by Eclipse P2 to change the system are described in \citep{le_berre_dependency_2009} and \citep{leBerre2010}:
\begin{enumerate}
  \item minimise the amount of components installed that have no dependency to them 
  \item minimise the removal of already installed components
  \item minimise the age of the installed components
  \item minimise changing an installed component if they are unrelated to the request being made
\end{enumerate} 

These criteria are used to select a system if multiple possible systems are available. 

\subsection{Fractal}
Fractal \citep{Quma2006} is a component model developed by France Telecom R\&D and INRA.
It is a specification that is designed to be programming language independent, unlike OSGi or Eclipse that both depend on Java specific elements.
The most notable aspect, and the reason for its name, is that a components can be composed together to make a new component.
This recursive nature of composition, actually means the system of components can itself be a component.

To show how Fractal meta-data can describe component constraints an example is presented in figure \ref{fractalmetadata}.

\begin{figure}[htp]
\begin{center}
\begin{alltt}
<?xml version="1.0" encoding="ISO-8859-1" ?>
<!DOCTYPE definition PUBLIC 
    "-//objectweb.org//DTD Fractal ADL 2.0//EN" 
    "classpath://org/objectweb/fractal/adl/xml/basic.dtd">

<definition name="textEditorComponent">
  <interface name="textEditor" role = "server" 
   signature = "nz.geek.textEditor"/>
  <interface name="spellChecker" role = "client" 
   signature = "nz.geek.spellChecker"/>
  <content class="nz.geek.textEditorImpl"/>
</definition>
\end{alltt}
  \caption{Example of a simple Fractal ADL file}
  \label{fractalmetadata}
\end{center}
\end{figure}

This meta-data describes the component constraints as a metaphor between a client and a server.
The interface tag with the role attribute assigned to ``server'', defines the provided functionality of the component.
The interface tag with the role attribute assigned to ``client'' then defines the required functionality of the component.  

An example of the definition of a recursive component can be seen in figure \ref{fractalrecursve}.

\begin{figure}[htp]
\begin{center}
\begin{alltt}
<?xml version="1.0" encoding="ISO-8859-1" ?>
<!DOCTYPE definition PUBLIC 
    "-//objectweb.org//DTD Fractal ADL 2.0//EN" 
    "classpath://org/objectweb/fractal/adl/xml/basic.dtd">

<definition name="textEditorWithSpellCheckerComponent">
  <interface name="textEditorWithSpellChecker" role="server" 
   signature="nz.geek.textEditorWSC"/>
  <component name="textEditorComponent">
    <interface name="textEditor" role="server" 
     signature="nz.geek.textEditor"/>
    <interface name="spellChecker" role="client" 
     signature="nz.geek.spellChecker"/>
    <content class="nz.geek.textEditorImpl"/>
  </component>
  <component name="spellCheckerComponent">
    <interface name="spellChecker" role="server" 
     signature="nz.geek.spellChecker"/>
    <content class="nz.geek.spellChecker.SpellChecker"/>
  </component>
  <binding client="this.textEditorWithSpellChecker" 
   server="textEditorComponent.textEditor"/>
  <binding client="textEditorComponent.spellChecker" 
   server="spellCheckerComponent.spellChecker"/>
</definition>
\end{alltt}
  \caption{Example of a simple Fractal ADL file}
  \label{fractalrecursve}
\end{center}
\end{figure}

This description of a recursive component structure defines both the text editor and spell checker components, as well as their constraints.
The tag \texttt{definition} is then used to define a composition of components that provides a service of \texttt{textEditorWithSpellChecker}.
To provide this the spell checker must be bound (described in the tag \texttt{binding}) to the text editor,
and the text editors provided interface bound to the output interface. 

\subsubsection{Fractal Change}
The programmatic evolution of a Fractal component system can differ between implementations.
To simplify this, only the Java implementation is described. 
In this implementation the methods to edit the configuration are\footnote{http://fractal.ow2.org/current/doc/javadoc/fractal/ accessed 6/3/2012}:
\begin{itemize}
  \item to create a component: \\ \texttt{org.objectweb.fractal.api.factory.GenericFactory}\verb+#+\texttt{newFcInstance}
  \item to add a component to a composite: \\ \texttt{org.objectweb.fractal.api.control.ContentController}\verb+#+\texttt{addFcSubComponent}
  \item to remove a component from a composite: \\ \texttt{org.objectweb.fractal.api.control.ContentController}\verb+#+\texttt{removeFcSubComponent}
\end{itemize}

There are two points that may make the changing a Fractal component model particularly difficult,
the recursive nature of Fractal, and the lack of required version information about components and composites.

%%%Fractal requires not only the selection of components but the configuration
The recursive nature of of Fractal will make is difficult to change a system. 
Given the recursive nature of the components described, any system may provide the same functionality with the same components in a combinatorial number of configurations.
When changing a system, not only would a new system need to be selected, but the groups of components to make composites will need to be selected.
This has then made the selection problem more difficult to solve.
The simplest solution to this problem is to ignore the recursive nature of this component model
and have the changed component system be exactly one composite with all components in it.
More difficult solutions could be created by reusing user composites,
or analyzing the graph structure to extract relationships by using algorithms like the one presented in \citep{dietrich2008cluster}.
This is all speculation however, and will not be explored in this research.


Another aspect that will makes changing Fractal systems difficult, is the lack of versioning information.
Like DS, this component model does not explicitly require the version of the component and the interfaces they provide.
This may lead to problems as components and services evolve, and the dependencies on them cannot specify which component version to depend on.

\subsection{Maven}
Maven is a build automation tool, designed to be programming language agnostic, but primarily used with Java.
The core component aspect of Maven is that it can dynamically select and download files from a repository to be used to build a system.
Maven itself is built using a plugin architecture.
This architecture is built to make it easy to change and adapt the Maven application.
However, the focus in this section is on the use of Maven as a component model and not the Maven applications plugin system.

To show how the Maven Project Object Model (POM) meta-data file is used to describe constraints,
 an example given in \ref{mavenmetadata}. 

\begin{figure}[htp]
\begin{center}
\begin{alltt}
<project xmlns="http://maven.apache.org/POM/4.0.0"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
                      http://maven.apache.org/xsd/maven-4.0.0.xsd">

  <groupId>nz.geek</groupId>
  <artifactId>textEditor</artifactId>
  <version>0.0.0.alpha</version>

  <dependencies>
    <dependency>
      <groupId>nz.geek</groupId>
      <artifactId>spellChecker</artifactId>
      <version>\squarebracket0.0.1,1.0.0)</version>
      <type>jar</type>
     </dependency>
  </dependencies>
</project>
\end{alltt}
  \caption{Example of a Maven POM file}
  \label{mavenmetadata}
\end{center}
\end{figure}

This model defines the components namespace using the \texttt{groupId} tag, the name using the tag \texttt{artifactId}, and the version.
It also defines the dependencies on other projects through the \texttt{dependency} tag,
where it states that it depends on the artifact \texttt{spellChecker} from versions 0.0.1 to (but excluding) version 1.0.0.

\subsubsection{Maven Change}
The use of Maven primarily during development does not exclude it from the definition of being a component model in this study.
Maven both explicitly declares constraints and provides an interface to change its component systems. 
This unique characteristic of Maven does mean that changing a component system is done in two stages where first it is altered, then it is recompiled and replaced.

Another core difference from the other presented component models is that Maven POM objects do not declare what they provide.
For example, an OSGi bundle can declare provided packages and a Fractal component declares provided interfaces, where a Maven project can only provide itself.
This will simplify the constraints that can be described. 
However, it may go against core CBSE principles like dependency on interface or specification \citep{Szyperski2002} and not implementation.

\subsection{Debian Packages}
\label{background.debianPackages}
Debian is a GNU/Linux based operating system provided by the Debian Project \citep{Barth2005}.
This operating system most prominent feature is that it is composed of packages, a unit of deployment with explicit constraints.

The constraints of each package are defined in a control file.
To show how this control file defines such constraints two examples are presented in figures \ref{debianmetadatate} and \ref{debianmetadatasc}.

\begin{figure}[htp]
\begin{center}
\begin{alltt}
Package: textEditorPackage
Version: 0.0.1.alpha
Depends: spellChecker
Conflicts: otherTextEditorPackage
\end{alltt}
  \caption[Debian Control file for Text Editor]{Example of a Debian Control File for Text Editor}
  \label{debianmetadatate}
\end{center}
\end{figure}

\begin{figure}[htp]
\begin{center}
\begin{alltt}
Package: spellCheckerPackage
Version: 1.0.0
Provides: spellChecker
\end{alltt}
  \caption{Example of a Debian Control File for Spell Checker}
  \label{debianmetadatasc}
\end{center}
\end{figure}

These control files describe two packages, a text editor and spellChecker, they are organised into key/value pairs separated by the ``:'' character.
The text editor states using the \texttt{Depends} key that is requires a spellChecker to be installed, 
and through the \texttt{Conflicts} key states that it cannot be installed with another text editor.
The spell checker package defines that it provides a spell checker using the \texttt{Provides} key.
This spell checker is of a type called a virtual package, which has some specific semantics not described here.

One aspect that differentiates the Debian package model from the many other models, is that it does not specify the rules of composition between components.
That is, there is no formal specification of the semantics of the communication and relationships between packages.
For instance, OSGi bundles exist in a very constrained environment that manages their interactions, depending on another bundle has run-time implications.
For Debian, the dependence of one package on another has no prescribed run-time effects, other than the assumption that without satisfying the dependence the package will not be functional.
The way in which a package, uses or communicates with a depended upon package is then defined between the packages and not in the component model.

\subsubsection{Debian Change}
The application ``dpkg'' is the command line tool use to modify a Debian package system.

The commands to modify a Debian package system are:
\begin{itemize}
  \item to add a package: dpkg --install <package file>
  \item to remove a package: dpkg --remove <package>
\end{itemize}

These commands define the atomic actions to change a Debian system.
They can be executed from other applications through the command line, this makes them programming language independent and easily accessible. 

\subsubsection{apt-get}
The dpkg application can only remove and add a single component at a time, it does not resolve the dependencies of the component.
There are many applications that can resolve these dependencies on a Debian system, the default and most popular solution is through the ``apt-get'' application.
This tool is built on top of dpkg, to provide an interface to simplify and extend its functionality.
The apt-get application is a command line tool, which provides the necessary tools to efficiently allow the user to evolve their system.

Apt-get follows some basic criteria when altering the system, for example when upgrading:
\begin{itemize}
  \item under no circumstances will apt-get remove an already installed package
  \item under no circumstances will apt-get retrieve a package that is not installed
\end{itemize}
Note: apt-get defines removing a package as removing all packages with the same name, e.g. replacing a package named \texttt{text-editor} with a higher version is not ``removed'' as apt-get defines.

Another application that extends \texttt{apt-get}'s functionality is \texttt{aptitude} \citep{Burrows2005}.
This application adds a basic user interface to \texttt{apt-get} and also extends functionality in aspects like locating and removing redundant packages.
Aptitude allows some of its criteria to be user defined, for example when the flag \verb+--safe-resolver+ is used:
\begin{itemize}
  \item it attempts to preserve as many of your choices as possible.
  \item it will never remove a package
  \item it will never install a version of a package other than the package's default candidate version.
\end{itemize}

\subsection{SOFA 2.0}
Software Appliance (SOFA) is a component model developed at Charles University in Prague.
A component in the SOFA framework is defined by it's frame, which contains the meta-data of what the component requires and provides.
Like Fractal, SOFA is a recursive component model, allowing for a composite of components to be treated as a single component.

To show how SOFA meta-data describes constraints an example is presented in figure \ref{SOFAmetadata}.

\begin{figure}[htp] 
\begin{center}
\begin{alltt}
<?xml version="1.0"?>
<frame name="nz.geek.textEditor">
  <requires name="spellChecker" itf-type="sofatype://nz.geek.spellChecker"/>
</frame>

<?xml version="1.0"?>
<frame name="nz.geek.spellChecker">
  <provides name="spellChecker" itf-type="sofatype://nz.geek.spellChecker"/>
</frame>
\end{alltt}
  \caption{Example of a SOFA ADL Files}
  \label{SOFAmetadata}
\end{center}
\end{figure}

This meta-data describes two components, a text editor and a spell checker, using the tag \texttt{frame}.
The sub elements \texttt{requires} and \texttt{provides} describes the component constraints through an externally defined interface with the name-space \texttt{sofatype://nz.geek.spellChecker}.
This interface is defined using an Architecture Definition Language (ADL) and added to a repository to be re-used. 


\subsubsection{SOFA Change}
SOFA 2.0 is an extension of the SOFA framework, with new services including dynamic reconfiguration for dynamic evolution of an architecture at run-time. 
Unlike other component systems,
it only allows for controlled evolution; 
Many component models allow the change of the component system on a fine grained level of adding or removing a component.
However this model only allows more granular changes to be made to the system, these changes must conform to specified evolution patterns.
This restriction is meant to increase the manageability and predictability of a component systems evolution. 

Three evolution patterns are predefined: factory pattern, removal pattern, and service access pattern.
As its name suggests, in factory pattern a designated component serves as a component factory. 
The removal pattern serves for destroying of a component previously dynamically created.
The service access pattern allows for the access to external services.
These patterns are further discussed in \citep{Hnetynka2006}.


\subsection{Common Upgradeability Description Format}
%%%CUDF model created for compeition
Many component models share similar properties including:
\begin{itemize}
  \item a component name
  \item a component version
  \item description of what the component provides
  \item description of what the component requires
\end{itemize} 

By abstracting these common elements into a single model, the description of how a component system is changed can become component model independent.
The Common Upgradeability Description Format (CUDF) model is such an abstraction.
It is used to describe a request by a user to change a component system, and can be used by a CDR implementation to calculate the resulting system.
CUDF was created by the Mancoosi project to foster interest in this domain and to be used in a competition that compared CDR implementations.
Mancoosi is a European research project focused on the problems faced by Free and Open Source Software (FOSS) systems when being changed.

%%%No concrete components, but fits our definition
The CUDF component model has no concrete component as it was designed to be an abstract component model.
This means that there is no defined semantics to execute a CUDF component system.
In this respect it is similar to the OBR component model, as it has been created to explicitly represent the problem of changing a component system.

To show how a CUDF document describes a changing component system, an example is presented in figure \ref{CUDFmetadata}.

\begin{figure}[htp] 
\begin{center}
\begin{alltt}
package: textEditor
version: 1
depends: spellCheckerService

package: spellChecker
version: 2
provides: spellCheckerService

request:
install:textEditor

\end{alltt}
  \caption{Example of a CUDF file}
  \label{CUDFmetadata}
\end{center}
\end{figure}

A CUDF file is defined using key/value pairs, where each component is defined using the two tags \texttt{package} and \texttt{version}.
This file does not only represent the components but also the requested change with the tag \texttt{request}.
Further definition of the syntax and semantics of CUDF is in chapter \ref{formal}, as it is used extensively throughout this study.

\subsubsection{Mancoosi MPM}
%%%The mancoosi Modular Package Manager uses CUDF, currently going through the process in the Debian component repository
The CUDF component model was defined especially to compare CDR implementations, therefore many implementations exist.
In fact through this research one such implementation, GJSolver was created and compared to other implementations.
This is further discussed in the latter chapter \ref{implementation}.
Here the implementation from Mancoosi, Modular Package Manager \citep{abate2011} (MPM), is discussed.

MPM was created by the Mancoosi project to explore the possibility of using CUDF solver to evolve real systems.
In the study by \cite{abate2011}, this package manager was compared against other solvers, such as apt-get and aptitude, and shown to be an improvement in performance.
MPM also was the first to allow the user to completely specify the criteria by which the solver selects a system.
Further discussion of MPM criteria is given in chapter \ref{implementation}. 

\subsection{Comparison}
Each of the presented component models provide an explicit description of their components constraints, and a mechanism to change a component system.
This means that they are all component models w.r.t. the definition of component in this research,
as they allow the process of component system evolution where the user is the composer.

The constraints in these models fall into two groups:
\begin{enumerate}
  \item \textit{dependencies}, where one component requires what another component or what it provides.
  \item \textit{conflicts}, where one component conflicts with another component or what it provides. 
\end{enumerate} 
Typically these constraints are between pre-defined types in the component model, e.g. a service or a package.
However, OBR, Maven, and SOFA allowed the definition of a type of dependency. 
All component constraints are defined in meta-data files in either XML, or key/value pairs formats.
The constraints in these models have broadly similar semantics, though different vocabulary.
The comparison between these models is then mostly linking together vocabulary.
This comparison is summarised in the tables  \ref{background.comparisonrel} and \ref{background.comparisonmeta}.  

\begin{table}
\begin{tabular}{|l || c | c | c | }
\hline \textbf{Component Model}& \textbf{Component}& \textbf{Provides}	& \textbf{Provide/Require}\\ \hline

OSGi					& Bundle			& Package 					& Export/Require Import \\
Declarative Services	& Component			& Service 					& Provide/Reference\\
OBR						& Resource			& \textit{typed}			& Capability/Require\\
Eclipse					& Plug-in			& Extension-Point			& Extension/Requires\\
Fractal					& Component			& Interface 				& Server/Client\\
Maven					& Artifact			& \textit{typed} 			& NA/Dependency\\
Debian					& Package			& Virtual-Package 			& Provide/Depends\\
SOFA 2.0				& Frame				& \textit{typed} 			& Provide/Require\\
CUDF					& Package			& Package 					& Provides/Depends\\\hline
\end{tabular}
\caption[Summary of presented component models' constraints.]{Summary of presented component models' constraints. Note: \textit{typed} refers the ability to type a requirement.}
\label{background.comparisonrel}
\end{table}


\begin{table}
\begin{tabular}{|l || c | c | c | }
\hline \textbf{Component Model}& \textbf{Constraint Description File} & \textbf{Format}	\\\hline

OSGi					& Meta-Data				& Key/Value pairs 					\\
Declarative Services	& Component Description	& XML 								\\
OBR						& Repository			& XML								\\
Eclipse					& plugin.xml			& XML								\\
Fractal					& ADL					& XML 								\\
Maven					& POM					& XML 									\\
Debian					& control				& Key/Value pairs							\\
SOFA 2.0				& ADL					& XML 							\\
CUDF					& CUDF					& Key/Value pairs									\\\hline
\end{tabular}
\caption{Summary of presented component models' constraints description formats.}
\label{background.comparisonmeta}
\end{table}

These component models also provide mechanisms to change a component system with the exception of OBR, Maven, and CUDF.
In OBR and CUDF, the component systems are represented by the meta-data files themselves, therefore changing the component system is a matter of altering the meta-data. 
Maven component systems are also represented by the meta-data, though once the meta-data is changed the Maven application must be executed to change the system.

With the exception of SOFA 2.0, all the mechanisms to alter a component system in the remaining component models have the actions of either adding, removing and/or replacing a component.
SOFA only allows altering the system by pre-defined evolution patterns.

Most of these models have some form of CDR implementation to help evolve their component systems.
Fractal and SOFA are the only systems to not include a CDR implementation, this may be due to the difficulty in evolving hierarchical component models.
A comparison between these component model properties is presented in table \ref{background.comparisonprop}.

\begin{table}
\begin{tabular}{|l || c | c | c | }
\hline \textbf{Component Model}& \textbf{Hierarchical}& \textbf{Evolution Mechanism}	& \textbf{CDR}\\\hline

OSGi					& No			& Method/Command Line 					& OBR\\
Declarative Services	& No			& Method 								& OBR\\
OBR						& No			& NA									& OBR \\
Eclipse					& No			& Method								& Eclipse P2\\
Fractal					& Yes			& Method 								& None\\
Maven					& No			& NA 									& Maven\\
Debian					& No			& Command Line 							& apt-get\\
SOFA 2.0				& Yes			& Evolution Patterns 					& None\\
CUDF					& No			& NA 									& MPM\\\hline
\end{tabular}
\caption{Summary of presented component models' properties.}
\label{background.comparisonprop}
\end{table}

The presented comparison of these models shows that although they are aimed at different domains, they are very similar with respect to component change and therefore CSE.
This similarity motivates the research into CSE, as results may contribute to many different domains. 

\section{Summary}
In this chapter, the concepts related to CSE are explored.
The domains of software evolution, CBSE and component systems are described and the important concepts, such as software component, are defined.
Various component models are described, and the similarities between them are discussed.
In the next chapter the concepts discussed in this chapter are formally defined. 
This is the first step towards creating a simulation of CSE.

