\chapter{Background}
\label{background}
%%%What are components
{}Component-based software engineering is considered by many to be the future for development of software systems \cite{Szyperski2002}.
{}Its goal is to use many reusable units of execution that are developed and composed into a single system.
{}This replaces the idea of developing large monolithic systems that bundle all functionality into one unit, with a more modular approach.

%%%What are component models.
An important difference between software components and other modular approaches, is the \textbf{component model}.
This is the specification of how software components are described and how they interact with each other to form the system.

%%%Examples of component models
There are various component models available, these can differ by functionally, platform, or their objectives for being created.
These models have become successful in many domains, such as application frameworks, operating systems and embedded systems.

%%%What is evolution Evolution
The component model typically includes specifications assist the evolution of the component system.
This evolution is the changing of the system over time, either for maintenance or to add functionality.
To enable this evolution, the component model defines functionality that allows components to be added, removed or replaced in the system. 

%%%What is Component Dependency resolution
The relationships between components can be complex, therefore a component that is changed through this evolution may require further changes to the system.
As these changes can be extensive, the function of component dependency resolution (CDR) was created to automate them.

%%%Examples of CDRs
There are currently many successful implementations of CDR's.
These can be used in the development of a component system or at run time to alter the currently used system.

%%%How to implement CDR
The problem of finding the necessary changes to the system is NP-Complete, and as there can be many different possible solutions, optimising this problem is NP-Hard.
Therefore, the implementation of CDR requires to be robust and fast.
Recently, the use of Boolean satisfaction (SAT) solvers extended to handle pseudo Boolean constraints for optimisation, has become popular.
This method takes a set of constraints that describe the problem and using a set of powerful tools quickly finds solutions to that satisfy all constraints.

%%%How to describe all CDR problems
Many component models share similar properties but the CDR implementations are not interoperable between these models.
This comparing these implementations difficult, and reusing them outside of their component model impossible. 
To solve this, a specification from the Mancoosi organisation called CUDF has been defined to abstract this problem from the component model.
This specification contains the necessary detail to express the core problem, and an extensible syntax to allow for component model specific detail. 
This allows the description of many CDR problems in a single format, and the use of various CDR implementations to solve them. 

In this chapter; what software components, and component models, are is discussed with respect to component dependency resolvers.
The evolution of individual components and component systems is then described.
The component dependency resolution problem is described with its uses and purposed,
then examples of its implementation are given and compared.
Boolean satisfiability solvers, are described and their implementations examined, with their extension to pseudo Boolean constraints.
Finally, the CUDF specification with its syntax and semantics is described in detail.
 
\section{What is a Component?}
%%%Some history to software components mentioning McIlroy's 1969 paper \cite{McIlroy1969}
Software components ideals can be traced to \cite{McIlroy1969}, where the author describes his ideas industrializing software engineering through a software component sub-industry. 
These components are made through the decomposition of software into discreet units with explicitly stated interfaces and behaviours.
However, there is still much debate over how to define what a software component is, and what features it should have.

%%%Discussion of articles where Szyperski and Meyers discuss give their versions of what a component is.
A discussion between two leading researchers in component software, Bertrand Meyer and Clemens Szyperski, highlight this difficultly of defining exactly what a software component is. 
They describe across multiple articles \cite{Meyer1999,Szyperski2000a, Szyperski2000, Meyer2000,} the definitions of what a software component is and the importance of their use.

%%%Szyperski's definition
Szyperski defines components in \cite{Szyperski2002} as having three characteristic properties:
\begin{enumerate}
  \item a unit of independent deployment
  \item a unit of third party composition
  \item has no externally observable state
\end{enumerate}

%%%Meyers Definition
Meyer's definition of software components is enumerated as:
\begin{enumerate}
  \item May be used by other software elements (clients)
  \item May be used by clients without the intervention of the components
  developers
  \item Includes a specification of all dependencies (hardware and software
  platform, versions, other components)
  \item Includes a precision specification of the functionality it offers
  \item Is usable on the sole basis of that specification
  \item Is composable with other components
  \item Can be integrated into a system quickly and smoothly
\end{enumerate}

%%%Using a component model
Others, like Heineman and Councill \cite{heineman2001component} have stated that components must conform to a component model, 
\begin{quotation}
A software component is a software element that conforms to a component model and can be independently deployed and composed without modification according to a composition standard.
\end{quotation}

Defining a component model as:
\begin{quotation}
A component model defines a set of standards for component implementation, naming, interoperability, customization, composition, evolution, and deployment.
\end{quotation}

%%%Other differences, architectural/implementation
Exactly what is, and what is not a software component is then in dispute amongst the community.
As such, many different components models have been developed, each targeting various domains with different functionality and technical aspects.
This diversity has inspired a classification approach from \cite{Crnkovic2011}, where components and component models are classified into a scheme.
This effort highlights the difficulty in creating an exact definition of a software component. 

%%%It is difficult to define a natural concept such as component with a set of fixed enumerable features.
These problems with exactly defining a software component may stem from the fact that ``component'' is a natural concept.
Observed from the area of formal concept analysis \cite{Ganter1999} by \cite{Szyperski2002} is the problem that it is impossible to

\begin{quotation} 
``enumerate a fixed agreeable set of features that is necessary and sufficient for a natural concept such as component.'' 
\end{quotation}

%%%Our egotistical view of components is defined with relation to Component Dependency Resolution.
However, a definition can be found, not by feature enumeration but through stating the intention for the concept and exploring the technically inevitable consequences \cite{Szyperski2002}. 
As the intention of this study is to investigate component dependency resolution and evolution strategies,
the definition of software component used will be in respect to these aspects.

%%%This will not fit all views of what a component is (no definition will), but it eliminates unnecessary arguments so we can focus on CDR
This view of a software components definition will not agree with every persons view of what a software component is, but (as described above) no view can.
By only looking at aspects that are necessary for our topic, the arguments over unnecessary semantics are eliminated, leaving only the core aspects of this research. 

\subsection{Software Component}
The definition of a software component is given with respect to the evolution of the system using component dependency resolution.
This definition specifies requirements on the component model that ensure it is applicable in this research.

For CDR to be used with a component system, there are two core requirements, the component model must:
\begin{enumerate}
  \item require the explicit definition of dependencies between components
  \item include mechanisms in which to compose or evolve a component system
\end{enumerate}
This definition leaves undefined many aspects of component model, however these are ignored as they are not related to CDR of component system evolution.

%%%A component must have explict (computer readable) requirements on the context in which it can be used. Different from COTS requirements which are meant to be human readable.
To automate the resolution of dependencies between components, these dependencies must be explicitly defined and computer readable.
These dependencies constraint the environment in which the component can be executed.
As CDR requires the ability to calculate systems that will function, this requirement is necessary.

%%%The component model should specifiy mechanisms to support evolution of the system; e.g. the addition and removal of components from a composition.
The creation or evolution of a component system must be able to be automated for CDR to be usable.
This means that CDR should have the ability to add, remove and replace components in a system, and create a functioning system.
These actions can occur at either at compile-time or run-time of the system.

%%%Aspects such as semantics of composition, distribution, development, are outside the scope of CDR, therefore ignored in this definition (that is not to say they are unimportant).
The classification, from \cite{Crnkovic2011}, of a component model is partially described as:
\begin{itemize}
  \item Lifecycle 
  		\begin{itemize}
	  		\item Modelling
	  		\item Implementation
	  		\item Packaging
	  		\item Deployment
		\end{itemize}
	\item Construction
		\begin{itemize}
	  		\item Interface Specification
	  		\item Binding
	  		\item Interactions 
		\end{itemize}
	\item Extra Functional Specifications
		\begin{itemize}
	  		\item Management
	  		\item Specification
	  		\item Composability
		\end{itemize}	
\end{itemize}  
This list displays the complexity in defining a component model.
In this classification scheme, the two aspects that are included in this definition are lifecycle deployment for the evolution of a component system, 
and construction interface specification for the explicitly defined dependencies.
All the other aspects that practically must be defined, are here ignored as their definition is superfluous to the core topic of this research.

\section{Component Models}
%%%Some core component models are described, and their dependencies and evolution are discussed
Given the definition of a software component for this research, some current component models are described and discussed.
These models come from industry (OSGi, Eclipse Plugins, Fractal, Maven), open source community (Debian, RPM) and academia (Software appliances).

\subsection{OSGi} 
OSGi is a mature component model from the OSGi Alliance that has a significant presence in industry \cite{Kriens2008} 
from organizations like the Eclipse Foundation with their Equinox framework and Apache with Felix.

\begin{figure}[htp]
\begin{center}
\begin{alltt}
Bundle-Name: TextEditor
Bundle-Vendor: Graham Jenson
Bundle-SymbolicName: nz.geek.maori.textEditor
Bundle-Version: 0.0.1.alpha
Bundle-RequiredExecutionEnvironment: J2SE-1.4
Export-Package: nz.geek.maori.textEditor;version="0.0.1.alpha"
Require-Bundle: nz.geek.maori.fonts
Import-Package: nz.geek.maori.spellchecker
\end{alltt}
  \caption[OSGi Meta-data]{Example of OSGi Meta-data}
  \label{osgibundle}
\end{center}
\end{figure}

\begin{figure}[htp]
\begin{center}
\begin{alltt}
\ldots
---Controlling Bundles---
    install - install and optionally start bundle from the given URL
    uninstall - uninstall the specified bundle(s)
    start - start the specified bundle(s)
    stop - stop the specified bundle(s)
    refresh - refresh the packages of the specified bundles
    update - update the specified bundle(s)
\ldots
\end{alltt}
  \caption[OSGi functionality extract]{Extract from the Equinox OSGi console that lists functionality provided}
  \label{osgibundle}
\end{center}
\end{figure}



\subsection{Eclipse Plugins}

\begin{figure}[htp]
\begin{center}
\begin{alltt}
<?xml version="1.0"?>
<plugin
    name="Text Editor"
    id="nz.geek.maori.textEditor"
    version="0.0.1.alpha"
    provider-name="Graham Jenson">
    
    <requires>
        <import plugin="nz.geek.maori.fonts"/>
    </requires>

    <runtime>
        <library name="texteditor.jar"/>
    </runtime>
    
    <extension-point id="nz.geek.maori.spellchecker" 
        name="Spell Checker" 
        schema="spellchecker.exsd"/>
</plugin>
\end{alltt}
  \caption[Eclipse Plugin meta-data]{Example of an Eclipse Plugin plugin.xml meta-data file}
  \label{osgibundle}
\end{center}
\end{figure}

\begin{figure}[htp]
\begin{center}
\begin{alltt}
<schema targetNamespace="null" xmlns="http://www.w3.org/2001/XMLSchema">
 <element name="spellchecker">
  <complexType>
   <attribute name="spellchecker" type="string" use="required">
    <annotation>
     <appinfo>
      <meta.attribute kind="java" basedOn=":nz.geek.maori.ISpellChecker"/>
     </appinfo>
    </annotation>
   </attribute>
  </complexType>
 </element>
</schema>
\end{alltt}
  \caption[Eclipse Plugin extension point schema]{Example of an Eclipse Plugin extension point schema file}
  \label{osgibundle}
\end{center}
\end{figure}

\subsection{Fractal}

\begin{figure}[htp]
\begin{center}
\begin{alltt}
<?xml version="1.0" encoding="ISO-8859-1" ?>
<!DOCTYPE definition PUBLIC 
    "-//objectweb.org//DTD Fractal ADL 2.0//EN" 
    "classpath://org/objectweb/fractal/adl/xml/basic.dtd">

<definition name="textEditorComponent">
  <interface name="textEditor" role="server" signature="nz.geek.maori.textEditor"/>
  <interface name="spellChecker" role="client" signature="nz.geek.maori.spellChecker"/>
  <content class="nz.geek.maori.textEditorImpl"/>
</definition>
\end{alltt}
  \caption[Fractal ADL Example]{Example of a simple Fractal ADL file}
  \label{osgibundle}
\end{center}
\end{figure}

\subsection{Maven}

\begin{figure}[htp]
\begin{center}
\begin{alltt}
<project xmlns="http://maven.apache.org/POM/4.0.0"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
                      http://maven.apache.org/xsd/maven-4.0.0.xsd">

  <groupId>nz.geek.maori</groupId>
  <artifactId>textEditor</artifactId>
  <version>0.0.0.alpha</version>

    <dependencies>
        <dependency>
          <groupId>nz.geek.maori</groupId>
          <artifactId>spellChecker</artifactId>
          <version>1.0</version>
          <type>jar</type>
        </dependency>
  </dependencies>
</project>
\end{alltt}
  \caption[Maven POM file]{Example of a Maven POM file}
  \label{osgibundle}
\end{center}
\end{figure}

\subsection{Debain Packages}

\begin{figure}[htp]
\begin{center}
\begin{alltt}
Package: textEditorPackage
Version: 0.0.1.alpha
Depends: spellChecker

Package: spellCheckerPackage
Version: 1.0.0
Provides: spellChecker

\end{alltt}
  \caption[Debian Control file]{Example of a Debian Control File}
  \label{osgibundle}
\end{center}
\end{figure}


%%%The debian component model is used in Debain based GNU/Linux distributions

%%%Some feel that this is not truly a component model as it has no formal definition of composition.\\

%%%However it fits our criteria of a component as given in previous sections

\subsection{Red Hat Packages}    


\subsection{SOFA 2}

\begin{figure}[htp]
\begin{center}
\begin{alltt}
<?xml version="1.0"?>
<frame name="nz.geek.maori.textEditor">
  <requires name="spellChecker" itf-type="sofatype://nz.geek.maori.spellChecker"/>
</frame>

<?xml version="1.0"?>
<frame name="nz.geek.maori.spellChecker">
  <provides name="spellChecker" itf-type="sofatype://nz.geek.maori.spellChecker"/>
</frame>
\end{alltt}
  \caption[SOFA ADL files]{Example of a SOFA ADL Files}
  \label{osgibundle}
\end{center}
\end{figure}


\subsection{Comparison}
%%%The comparison of component models focusses on their semantic definitions of dependencies and requirements,
%%%and the mechanisms by which a composition change.

\section{Evolution}
%%%Evolution is an important core aspect of Software Engineering and examining it in realtion to Component Systems is beneficial to the community\\
{}A software engineers goals towards software is to have continual satisfactory execution with maximum confidence at minimal cost and delay in this changing world \cite{Lehman2006}, 
{}while maintaining intellectual control over the complexity of design \cite{Brooks1975}.
{}Component systems aim to manage complexity through decomposition of systems into well defined components, and the evolution of such components through well defined mechanisms.

%%%Evolving a component system requires less change when compared to evolving a monolithic system.
Evolving component-based software requires only altering a minimal set of parts of the system, 
where as evolving a monolithic piece of software is achieved by replacing the entire system.
This comparison is described by Szyperski \cite{Szyperski2002} as ``evolution not revolution''.
As introducing change to a system introduces significant risk,
minimising change during evolution lowers the risk of component-based systems compared to monolithic systems. 
This risk occurs due to side effects that are caused by change, 
and changing large parts of a system incurs more side effects versus altering only specific parts of a system.
Therefore, lessening the change lowers the risk, and this is a very attractive feature of using and developing component-based software.

%%%A component model should support the evolution of individual components, and the evolution and change of the entire system

{}In this section we first discuss the support provided by a component model through the evolution of individual components and component systems.

\subsection{Component Evolution}
%%%Component evolution, i.e. the modification of components to create newer versions or branch existing versions.\\


%%%What is a version?
A version is the mechanism through which individual components evolve.
It is a unique marker which is compariable to other versions such that they are ordered.
As with the evolution of entire software systems, evolution of components requires constant maintenance.
Bugs can be found, features can be added, and code can be refactored all which make the component better.

%%%How are components versioned?
The syntax and semantics of a version is usually defined within the component model.
This forces all components that are developed for this model to follow the same general guidelines.

%%%Versions between components?
Although component must be versioned to conform to a versioning model defined by the component model, 
the way in which a developer uses this model to version their component is not usually strictly defined.
Each component is designed to be an independent unit, as such developers of components are separate from one another,
and the way in which they version their components can be different.
Therefore, version comparison is only useful between different versions of the same component;
e.g. a spell-checker component can be version 10 but a separate and superior spell-checker component may be only version 1.
This makes using component versions to decide between components impossible.

%%%A version of a component that is greater than another version of that component is assumed to be better in some way.
A newer version exists because the component has changed to be better in some way.
This may be through a bug being fixed, a security hole being patched, or the functionality being extended.
Having a newer version of a component in the system, may also make all of the other components that depend on it better as well,
causing a propagation of system improvement with the upgrading of one component.

In Belief Revision, one must maintain the newest set of information while only changing the minimal amount of previous knowledge. 

The change to the system that is caused when a newer version is installed may cause harm to your system.
In the same way that a version upgrade can propagate benefits through the system, 
friction or errors can propagate and cause a faulty or not functional system.

%%%Drawbacks of versions, they don't tell what changes
A common approach to selecting an optimal solution is to
maximise the versions of components while minimising the number of components.
The problem with the first criterion is that the version information does not tell us what quality improves, 
how much it improves or if that quality is relevant to the user or system.
Optimising for fewer components in a solution can be against many component system goals, like reuse or extensibility.
For example, this heuristics optimal solution would be a monolithic component with redundant functionality, over 
a set of more specific components. 


Versioning is the main mechanism in which components evolve.
There is also branching, and environment specific altering.

Versioning components has significant research behind it.

Branching is when a difference in opinion or idealogy on how a component should proceed into the future
causes the project to take two different routes given the same base code or idea.

Spring DM takes libraries and makes them OSGi compatable, 
Debian package can be compiled for different CPU architectures.


\subsection{Component System Evolution}
%%%Manually evolving a system can be tedious, so we use component dependency resolution
Evolving a system through individually adding and removing components can be tedious task 
as components can have dependencies on other components which also need to be satisfied.
Therefore, after the user has identified the wanted components, 
those components' dependencies must be satisfied with other components, which themselves can have dependencies.
Satisfying all these dependencies manually is a recursive, time-consuming and error-prone task to accomplish.
However, as most modern component models require components to explicitly state their dependencies; 
this enables component dependency resolution to build systems where all dependencies are satisfied.

%%%Changing the component in the component systems by adding removeing components to support evolution\\
Version and Dynamic dependence, with focus on interface give extensive tools to the composer 
Add, remove, upgrade, downgrade components in the system while it is running.

%%%How is this achieved?

%%%Problems with versioning a component system is different combinations of components, with different versions.

There are some problems that must be solved within the component model like making sure that during the change,
the system is never invalid or unstable. 
This is a scheduling problem as described by %TODO

The composer must also make sure that all dependencies are meet

\section{Component Dependency Resolution}
%%%The tedious nature of satisfying component dependencies during component system evolution can be automated into a function called Component Dependency Resolution.
Manually satisfying all component dependencies while evolving a component system can be a tedious, time consuming task.
This process can be automated into the function Component Dependency Resolution (CDR) \cite{Jenson2010}.
This takes advantage of the explicitly declared requirements of components to find a system where all component constraints are satisfied.

%%%CDR can be used at design-time and run-time on component models.
CDR can be used at design time to determine the required dependencies to build and test a project (as in Apache Maven \cite{casey_better_2008}),
at run time to evolve or extend a component-based system (as in Eclipse P2 \cite{leBerre2010}),
or it can be used to build and restructure software product lines \cite{savolainen_analyzing_2007}.
CDR is also used in package management systems, like apt-get \cite{Barth2005},
for adding, removing and updating components in package based operating systems like Ubuntu\footnote{http://www.ubuntu.com}. 

%%%Talk about dependency hell and how that it is largely mitigated via dependency resolvers

\section{CDR Implementations}
%%%Design time dependency resolvers benefits the software engineer building a large complex system that can involve many libraries with complex relationships.

\subsection{Apache Maven}
%%%Maven is a design time project and build automation tool, that can resolve library dependencies from a repository (https://oss.sonatype.org/content/repositories/)

\subsection{Nuget} 
%%%A new distribution model from microsfot for .Net libraries (http://nuget.codeplex.com/)

\subsection{RubyGems bundler}
%%% Bundler is a package dependency manager for RUBY gems (http://gembundler.com/)


\subsection{OSGi Bundle Repostiory}
%%%The OBR proposed by Peter Kriens and Richard Hall, is a meta data format for OSGi bundle resolution
Peter Kriens \cite{kriens_osgi_2008}, 
a primary author of the OBR \cite{the_osgi_alliance_rfc-0112_2006}, described a use of a component repository within a resource constrained environment.
When a device registers, 
through the repository, the driver for that device is loaded and then used, until the device is no longer available
then to conserve resources the driver is uninstalled dynamically. 
This demonstrates two requirements for a component repository, dynamic installation and uninstallation and being scalable to small devices.

For the OBR, we reviewed the standard \cite{the_osgi_alliance_rfc-0112_2006}, 
contacted both authors \cite{kriens_osgi_2008, richard_s._hall_obr_2008} 
and downloaded the open source Apache Felix OBR implementation and reviewed the source code.
OBR was our most completely reviewed repository.

OSGi is a 
mature standard component model from the OSGi Alliance that has seen a recent uptake in industry \cite{kriens_osgi_2008} 
from organizations like the Eclipse Foundation with their Equinox framework and Apache with Felix. This has multiplied the 
number of available bundles \cite{the_osgi_alliance_rfc-0112_2006}. OSGi Bundle Repository (OBR) was initially defined by 
Richard S. Hall, and later Peter Kriens, to help with the distribution of components, and is proposed in 
RFC-0112 \cite{the_osgi_alliance_rfc-0112_2006}. The design follows a federation of repositories each describing 
the capabilities and requirements of it's components and providing a URL to access it. Search is done using syntax with OSGi filter 
based expressions. This repository can also resolve dependencies and install these composites into a system. \\
OBR has been seen as a solution to to simplify deployment of OSGi applications
\cite{jung_integrating_2007}, distribution and deployment to embedded
ubiquitous systems \cite{jung_embedded_2006}, smart home applications \cite{gouin-vallerand_managing_2007} and 
dynamic distribution of drivers \cite{kriens_osgi_2008}. It is the only easily available deployment 
architecture available for OSGi, others have been developed to either extend or compete \cite{frnot_component_2005} with OBR, 
but are either in development, have been abandoned or are proprietary.\\ 
The most mature implementation of OBR client is offered by Apache, it is bundled with their core OSGi framework, Felix. 
The largest public OBR implementation is the federated repository provided by the OSGi alliance,
currently (as of 6 January 2009) aggregating components from Apache (32 bundles) and Eclipse (1534 bundles).
There are also many private repositories, some discussed with as much as 5000 bundles involved \cite{kriens_osgi_2008}.\\  

\subsection{OSGi Declarative Services}
%%%DS is standardised in the OSGi standards

\subsection{Spring Dynamic Modules}
%%%Spring is a competitor to DS, such that it resolves service level dependencies

\subsection{yum}
%%%Red hat package manager

\subsection{Apt-get}
%%%Apt-get is the core application for package management in Debian based GNU/linux distributions

Debian is a free and open source GNU/Linux based operating system. 
Debian's package system (dpkg) is used to install, remove and provide information about the operating system packages. 
APT is a repository client built on top of dpkg and simplifies it's functionality.\\
Aptitude is an application that adds a basic user interface to APT and also increases functionality in aspects like 
locating and removing redundant packages. 
Search of a package repository is done using regular expressions mixed with a
custom set of search terms that increase expressiveness. Using a simple
constraint-directed best-first search algorithm with some basic conflict
tracking Aptitude resolves dependencies between packages, and generates
composites to install.\\ 
There are many public and private implementations of this repository system. 
The largest public implementation is the Debian public repository, with 28078 packages in the ``Lenny'' stable repository.
With the most popular Debian distribution Ubuntu\footnote{http://www.ubuntu.com} having ten million users \cite{vance_software_2009} the user base for this repository is massive.
This repository has many regulations to publish and distribute, enumerated in the Debian Developers Reference \cite{andreas_barth_debian_2008}. 
User and automated testing is recommended, and if any critical bugs are found they are removed from the repository. 
This very manual way of publication and
distribution has its drawbacks, mostly the long community process that must be followed.\\

\subsection{Aptitude}
%%%Aptitude is a competitor to apt-get which has some more advanced features
Aptitude with APT, has immense amounts of information free on-line, the hardest part was reviewing as much as possible.
We also used and read the help documentation, contacted the author of the software \cite{burrows_modelling_2005} and
the Debian developers reference for the specific implementation of the Debian repository.


\subsection{Eclipse P2}
%%%The Eclipse P2 Solver, by Le Berre and Rapicault

For the Eclipse P2 repository system there was extensive literature provided by the Eclipse foundation in the form of a developer forum.
We also reviewed an early implementation through use of the software within the Eclipse environment.
Due to its recent release there is no literature reviewing or discussing this software.

Eclipse P2
is the new provisioning system for the Eclipse IDE platform.
It provides an update manager, the functionality to component pool, and a new dependency resolver.\\
The update manager is what most users will be familiar with, being the primary interface to the P2 functionality. 
A public repository, called a site, is added, and can be searched for components and their dependencies to install, and run.
This simplifies the evolution of Eclipse based applications to a simple user interface.\\
Component or bundle pooling uses a centralised set of components to run different applications.
This comes from the common problem of running multiple Eclipse based applications on the same system with different combinations of components.
A file is used to describe what components should be used in each particular application and P2 builds the composition into an application.\\
The dependency resolver of P2 is based on SAT4J\footnote{http://www.sat4j.org/} technology, a SAT resolver, which finds an optimal solution based on
a provided fitness function, if a solution exists it is guaranteed to find it.\\  
Eclipse already is
the core of many applications with its Rich Client Platform. This is a large base of applications that already support and can integrate with P2.


\subsection{Comparison of functionality}
%%%The comparisons of these resolvers will focus on the functionality that they provide given their component model (we will not compare their implementations)

%%%Multiple package installations 
%Maven Debain No, OSGi Eclipse DS and CUDF yes

%%%Focus on interface not implementation dependence 
%Maven no, Debian Community defined virtual packages, 

%%%Version Control

%%%Run time replacement Dynamic Dependence
%Maven no (no runtime), Eclipse Kind of a bit buggy requires restarts,
%OSGI DS Debian Yes, CUDF is abstract so has no real implementation

%%%Conflicts
%Maven?, Spring and DS no,  OSGi Singleton, Debian and CUDF are Expressive

%%%Reccommendation System, soft dependency (is this even a good idea)


\section{Boolean Satisfiability (SAT) Solvers}
%%%The definition of SAT has been around for a while, it was the first problem to be given the complexity NP-Complete

%%%SAT solvers have been investigated and found as a common good solution to CDR (EDOS PAPER)
Dependency Resolution is a NP-Complete problem, and NP-Hard given criteria to find an optimal solution.
This problem has been found in many areas, and there have been efforts to standardise the solution in an extensible way.
The EDOS project did a review of using SAT solvers, modified for optimisation, to solve dependecy resolution, and suggested that they were a satisfactory solution.
Today, most solvers use a SAT solver as they represent a quick extendible way to implement this functionality.

%%%SAT solvers are used to solve many problems, scheduling, model validity\ldots

%%%SAT solvers are very good at solving these kinds of problems because they are tested for performance against each other, to find what works empirically   

%%%We will breifly discuss their implementation and the algorithms associated, as it is the mechanism which we use to solve CDR problems

\subsection{Davis-Putnam-Logemann-Loveland algorithm for SAT Solvers}
%%%A successful algorithm for solving SAT problems is the DPLL algorithm, here we describe it in overview

%%%Some improvements over the core algorithm have been appended over the years since DPLL was first proposed.

\subsection{CHAFF Watched Literals}
%%%Through having clauses watch the literals, rather than the other way around, the most expencive step, the propogation, can be reduced significantly.
%TODO cite

\subsection{Conflict Learning}
%%%Simple resolution as proposed by Stallman was an effecient means to stop thrashing(looking at the same subtree repeatedly)

%%%Improvement of this resolution can be made by finding smaller constraints, this can be accomplished by eliminating literals in a constraint

%%%Further improvement can be made by searching for the smallest constraint through such variable elimination

\subsection{Literal Order}
%%%The order in which the literals are assumed in the DPLL algorithm, is heuristically accomplished

%%%The selection of a literal can be broken into two stages for modularity;
%%%first selecting a variable that is very volatile,
%%%second selecting a phase (negative or positive)

\subsection{Pseudo-Boolean Optimisation of SAT Solvers}
%%%Optimisation of SAT solvers is typically done through extending their possible constraints to include Psuedo Boolean inequalities

%%%Then through repeatdly finding a solution then adding a constraint to ensure the next solution is at least as good, the best solution is found

%%%Further optimisation can be made through quickly finding a satisfactory solution, this reduces the space in which to find a better solution

\subsection{Other Methods}
\subsubsection{Integer Programming}
%%%Discussion of this method as the best MISC solver uses this, it has a very complex implementation
\subsubsection{SMT Solvers}
%%%SMT Solver, a slightly higher logic than SAT uses; it has to broad a definition when SAT suffices
\subsubsection{Constraint Solver}
%%%We could just use Prolog, like SMT I think it is too broad when there are good SAT solvers

\section{Common Upgradeability Description Format}
%%%Here we give an introduction to the CUDF format from Mancoosi, this format is used as a standard for Dependency Resolution problems
{}\cite{treinen2009common}

%%%It was made to standardise the problem, for two reasons, to make building solvers generalisable, and to compete solvers in the MISC competetions to compare solutions.

%%%In both regards it has succeded, there have been many competitions run, 
%%%and their creation of a Modular Package Manager(MPM) is currently moving through the Debian stages into their core repository

\subsection{CUDF Syntax}
%%%The CUDF syntax is made to resemble similar CDR meta-data through using key-value pairs (not XML, too verbose?)

%%%Package Formulas are the standard mechanism of dependence

%%%Versions as Integers

%%%The Syntax has been defined to be extensible within the language, so additional model specific information can be included without increasing the size of the standard

\subsection{CUDF Semantics}
%%%As CUDF was a format the was supposed to be open to allow people to build differnt solvers for it, and be used as a real package manager, it walked a fine line.

%%%It must be simple enough so that developers can quickly understand it to build or modify existing solvers capable of competing in MISC competitions

%%%It must be broad enough to define and solve real world problems


\subsection{Mancoosi MPM}
%%%The mancoosi Modular Package Manager uses CUDF, currently going through the process in the Debian component repository


\subsubsection{P2CUDF implementation}
%%%Our implementation is based off of Daniel Le Berre and Rapicult P2CUDF, which uses SAT4J a SAT and PB solver, tested and validated in competitions.
The Mancoosi organisation who have created the CUDF standard have also organised competitions for the solvers.
One implementation of note is the P2CUDF implementation, that uses SAT


