\chapter{Background}
\label{background}
%%%What is Software Evolution
Software evolution is the necessary process of changing a system to adapt to its changing environment.
The cycle of continual evolution has been empirically studied and laws have been found that describe the nature of this process.  
Software development cycles have been described to mitigate the negative aspects of these laws, and to assist with evolution.

%%%Component Evolution
Component-based software engineering (CBSE) is considered by many to be the future for development of software systems \cite{Szyperski2002}.
It composes many encapsulated units of execution into a single system.
This replaces the idea of developing large monolithic systems that bundle all functionality into one unit, with a more modular approach.
Through its encapsulated components, and granular evolution, it provides many benefits to the process of software evolution.

%%%Broken into two parts
The evolution of a component based software can be broken into two different cycles; the evolution of the component, and the evolution of a component system. 
A component is evolved by a developer, like a typical software system, but a component system can be evolved by a user or stakeholder of the system.
The process of evolving a component system is the focus of this research.

%%%What is Component Dependency resolution
The evolution of a component system can be automated through a function called component dependency resolution.
This function uses the explicitly declared relationships between components, to evolve a system 
As these changes can be extensive, the function of component dependency resolution (CDR) was created to automate them.

%%%What is a evolutionary strategy
The purpose and user of a system will impact the evolution of a component system.

%%%Defining components
It is difficult to define exactly what a component is, as the community still disagrees over even fundamental differences.
However, a software component can be defined with respect to software evolution, in order to study the effect of component system evolution.

%%%What are component models.
An important difference between software components and other modular approaches, is the \textbf{component model}.
This is the specification of how software components are described and how they interact with each other to form the system.

%%%Examples of component models
There are various component models available, these can differ by functionally, platform, or their objectives for being created.
These models have become successful in many domains, such as application frameworks, operating systems and embedded systems.

%%%What is evolution
The component model typically includes specifications assist the evolution of the component system.
To enable this evolution, the component model defines functionality that allows components to be added, removed or replaced in the system.

%%%Examples of CDRs
There are currently many successful implementations of CDR's.
These can be used in the development of a component system or at run time to alter the currently used system.

%%%How to implement CDR
The problem of finding the necessary changes to the system is NP-Complete, and as there can be many different possible solutions, optimising this problem is NP-Hard.
Therefore, the implementation of CDR requires to be robust and fast.
Recently, the use of Boolean satisfaction (SAT) solvers extended to handle pseudo Boolean constraints for optimisation, has become popular.
This method takes a set of constraints that describe the problem and using a set of powerful tools quickly finds solutions to that satisfy all constraints.

%%%How to describe all CDR problems
Many component models share similar properties but the CDR implementations are not interoperable between these models.
This comparing these implementations difficult, and reusing them outside of their component model impossible. 
To solve this, a specification from the Mancoosi organisation called CUDF has been defined to abstract this problem from the component model.
This specification contains the necessary detail to express the core problem, and an extensible syntax to allow for component model specific detail. 
This allows the description of many CDR problems in a single format, and the use of various CDR implementations to solve them. 

In this chapter; how software components and component models are defined in this research is discussed in section \ref{background.components}.
The evolution of individual components and component systems is then discussed in section \ref{background.evolution}.
The component dependency resolution problem is described with relation to its purpose and impact on component systems in section \ref{background.cdr}.
Examples of various component models and CDR implementation are then given in sections \ref{background.models} and \ref{background.icdrs}.

The use of Boolean satisfiability solvers to implement CDR algorithms is described is described in \ref{background.SAT}.
This also includes an in-depth description of  a common SAT solver algorithm, the Davis-Putnam-Logemann-Loveland (DPLL) algorithm, 
with its extension to also use pseudo Boolean constraints.
Finally, the Common Upgradeability Description Format (CUDF) specification is described in section \ref{background.cudf}.

\section{Software Evolution}
\label{background.evolution}
Software evolution is the process of change made to software system to maintain, or to extend its functionality over the systems lifetime.
This process is necessary as the environment for which the system is developed will change.

The nature and fundamental laws of software evolution has be explored through empirical study of the software being evolved.
Some of the discovered laws of this evolution process are outlined by \cite{lehman1980} and \cite{lehman1997}:

\begin{enumerate}
  \item \textit{Continuing Change:} Systems\footnote{E-type systems: software implemented in a real-world computing context} must be continually adapted else they become progressively less satisfactory
  \item \textit{Increasing Complexity:} As the system evolves its complexity increases unless work is done to reduce it
  \item \textit{Self Regulation:} the system evolves with statistically determinable trends and invariences
  \item \textit{Conservation of Organisational Stability:} The average effective activity rate to evolve a system is invariant over its lifetime
  \item \textit{Conservation of Familiarity:} As the system evolves, its incremental growth remains invariant to ensure users maintain mastery over the system.
  \item \textit{Continuing Growth:} The system must continually grow to maintain user satisfaction
  \item \textit{Declining Quality:} The quality of the system will decline unless rigorously maintained
  \item \textit{Feedback System:} As the system effects the environment it is installed in, this changes the functions it performs
\end{enumerate}

%%%It is impossible to create a satisfactory system, but we can continually change it to become more satisfactory
These laws make the software engineers objective of a creating a satisfactory system impossible, 
because the system effects the environment it is in, which then changes the measurement of satisfactory.
A software engineers goal is then to continually change a system to make it more satisfactory, with minimal cost and delay \cite{Lehman2006}.
This change must be accomplished while the engineer maintains intellectual control over the complexity of the system \cite{Brooks1975}, 
as the more complex a system, the greater the difficulty to change it.

This iterative process can be seen in the spiral model shown in figure \ref{spiral}, first presented by \cite{Boehm1988}.

%\usepackage{graphics} is needed for \includegraphics
\begin{figure}[htp]
\begin{center}
  \includegraphics[width=\textwidth]{backgroundpics/spiral}
  \caption{The spiral software model}
  \label{spiral}
\end{center}
\end{figure}

This figure shows the evolutionary cycle of software development.
As the process progresses the evolution of the software system continues till the end of it's life.
This is a common model used to develop a software system, and shows the necessity to consider evolution during the software development.  

A software engineer must create a system that can be quickly altered to adapt to a changing environment, 
without increasing the systems complexity to a point where change may be too difficult.

\section{Component Based Software Evolution}
%%%Component systems can help
Component based software engineering (CBSE) creates software systems by composing encapsulated units of execution
that explicitly declare the relationships between themselves and the system.
Using a component based system may reduce the costs and time of making evolving a system through more easily calculating side effects and maximising reuse within the system.
Also, CBSE reduces the complexity of the change to a system by enforcing only granular changes. 

%%%More easily calculate side effects of change
Software components require the explicit definition of their relationships between one another and the system. 
This with the enforcement of the encapsulation on components makes the effects of a change to a component based system can more easily be calculated than a typical system.
Within a monolithic system, typically any part of the system can depend on any other part, this can occur without documentation or constraint.
This means that any change to the system can effect any other part, and in unknown and unpredictable ways.
Their are tools that analyse these dependencies to measure and mitigate their effect on the system, e.g. JDepend, Jens's tool.
However, as a component system explicitly declares its relationships, and encapsulates its functionality these dependencies are restricted.
Therefore, a components relationship to any other component in a system is calculable, making the effect of a change more easily predictable.
For instance, given a text editor component explicitly declares it's dependence on a spell checker, a change to the spell checker will have a known effect on the text editor.
Where in a monolithic system this relationship would only be implicit and the effect would then be more difficult to predict.

%%%Maximising reuse
Reuse is often cited as the main driving force of component technology, and has been empirically shown to increase the quality and productivity within software development \cite{hallsteinsen_experiences_1997}.
The amount of reuse in a system will also decrease the amount of necessary change during system evolution as there is less replicated functionality to maintain.
The greatest obstacle to reuse is the difficultly to locate and access required functionality quickly and easily \cite{ye_supporting_2001}.
As a component explicitly declares the functionality it provides and the environment it requires to function, the ability to find and use it is increased.
This can lead to greater reuse in a system and therefore less required change during evolution.
For example, if a text editor component explicitly requires a spell checker, and a spell checker explicitly declares its functionality,
the ability to find and compose them is greatly increased as their relationship is so specifically defined.


%%%Intellectual control over the complexity of the system is increased
The complexity of a component based system is greatly reduced due to the granularity of its construction.
This complexity is not a mathematical concept, but a psychological one.
It is the perceived complexity of a system, by an engineer, that intends to change the system.
As the systems complexity increases the ability of the engineer to make effective changes to the system decreases.
The number of units that must be looked at and the relationships between them must be considered by the engineer before a change is made.
The atomic evolutionary change made to a component system is the addition or removal of a component, to or from the system.
The smallest evolution that can be made to a monolithic software system can be as small as changing a single instruction. 
Therefore, a component systems granularity means that there are less items each with explict relationships the system is more easily understood.
For example, if a system required upgrading a spell-checker component, 
the parts of the system that an engineer should be concerned about will be the components that depend on the spell checker.

The use of component based systems can lower the cost, time and complexity of software evolution.
These potential benefits motivate this research into the evolution of component based systems. 

\subsection{Component Evolution}
%%%Component evolution, i.e. the modification of components to create newer versions or branch existing versions.


%%%What is a version?
A version is the mechanism through which individual components evolve.
It is a unique marker which is compariable to other versions such that they are ordered.
As with the evolution of entire software systems, evolution of components requires constant maintenance.
Bugs can be found, features can be added, and code can be refactored all which make the component better.

%%%How are components versioned?
The syntax and semantics of a version is usually defined within the component model.
This forces all components that are developed for this model to follow the same general guidelines.

%%%Versions between components?
Although component must be versioned to conform to a versioning model defined by the component model, 
the way in which a developer uses this model to version their component is not usually strictly defined.
Each component is designed to be an independent unit, as such developers of components are separate from one another,
and the way in which they version their components can be different.
Therefore, version comparison is only useful between different versions of the same component;
e.g. a spell-checker component can be version 10 but a separate and superior spell-checker component may be only version 1.
This makes using component versions to decide between components impossible.

%%%A version of a component that is greater than another version of that component is assumed to be better in some way.
A newer version exists because the component has changed to be better in some way.
This may be through a bug being fixed, a security hole being patched, or the functionality being extended.
Having a newer version of a component in the system, may also make all of the other components that depend on it better as well,
causing a propagation of system improvement with the upgrading of one component.

In Belief Revision, one must maintain the newest set of information while only changing the minimal amount of previous knowledge. 

The change to the system that is caused when a newer version is installed may cause harm to your system.
In the same way that a version upgrade can propagate benefits through the system, 
friction or errors can propagate and cause a faulty or not functional system.

%%%Drawbacks of versions, they don't tell what changes
A common approach to selecting an optimal solution is to
maximise the versions of components while minimising the number of components.
The problem with the first criterion is that the version information does not tell us what quality improves, 
how much it improves or if that quality is relevant to the user or system.
Optimising for fewer components in a solution can be against many component system goals, like reuse or extensibility.
For example, this heuristics optimal solution would be a monolithic component with redundant functionality, over 
a set of more specific components. 


Versioning is the main mechanism in which components evolve.
There is also branching, and environment specific altering.

Versioning components has significant research behind it.

Branching is when a difference in opinion or idealogy on how a component should proceed into the future
causes the project to take two different routes given the same base code or idea.

Spring DM takes libraries and makes them OSGi compatable, 
Debian package can be compiled for different CPU architectures.


\subsection{Component System Evolution}
%%%Manually evolving a system can be tedious, so we use component dependency resolution
Evolving a system through individually adding and removing components can be tedious task 
as components can have dependencies on other components which also need to be satisfied.
Therefore, after the user has identified the wanted components, 
those components' dependencies must be satisfied with other components, which themselves can have dependencies.
Satisfying all these dependencies manually is a recursive, time-consuming and error-prone task to accomplish.
However, as most modern component models require components to explicitly state their dependencies; 
this enables component dependency resolution to build systems where all dependencies are satisfied.

%%%Changing the component in the component systems by adding removeing components to support evolution\\
Version and Dynamic dependence, with focus on interface give extensive tools to the composer 
Add, remove, upgrade, downgrade components in the system while it is running.

%%%How is this achieved?

%%%Problems with versioning a component system is different combinations of components, with different versions.

There are some problems that must be solved within the component model like making sure that during the change,
the system is never invalid or unstable. 
This is a scheduling problem as described by %TODO

The composer must also make sure that all dependencies are meet

\subsection{Component Dependency Resolution}
\label{background.cdr}
%%%The tedious nature of satisfying component dependencies during component system evolution can be automated into a function called Component Dependency Resolution.
Manually satisfying all component dependencies while evolving a component system can be a tedious, time consuming task.
This process can be automated into the function Component Dependency Resolution (CDR) \cite{Jenson2010}.
This takes advantage of the explicitly declared requirements of components to find a system where all component constraints are satisfied.

%%%CDR can be used at design-time and run-time on component models.
CDR can be used at design time to determine the required dependencies to build and test a project (as in Apache Maven \cite{casey_better_2008}),
at run time to evolve or extend a component-based system (as in Eclipse P2 \cite{leBerre2010}),
or it can be used to build and restructure software product lines \cite{savolainen_analyzing_2007}.
CDR is also used in package management systems, like apt-get \cite{Barth2005},
for adding, removing and updating components in package based operating systems like Ubuntu\footnote{http://www.ubuntu.com}. 

%%%Talk about dependency hell and how that it is largely mitigated via dependency resolvers

\subsection{Evolution Strategies}

\section{What is a Component?}
\label{background.components}
%%%Some history to software components mentioning McIlroy's 1969 paper \cite{McIlroy1969}
Software components ideals can be traced to \cite{McIlroy1969}, where the author describes his ideas industrializing software engineering through a software component sub-industry. 
These components are made through the decomposition of software into discreet units with explicitly stated interfaces and behaviours.
However, there is still much debate over how to define what a software component is, and what features it should have.

%%%Discussion of articles where Szyperski and Meyers discuss give their versions of what a component is.
A discussion between two leading researchers in component software, Bertrand Meyer and Clemens Szyperski, highlight this difficultly of defining exactly what a software component is. 
They describe across multiple articles \cite{Meyer1999,Szyperski2000a, Szyperski2000, Meyer2000,} the definitions of what a software component is and the importance of their use.

%%%Szyperski's definition
Szyperski defines components in \cite{Szyperski2002} as having three characteristic properties:
\begin{enumerate}
  \item a unit of independent deployment
  \item a unit of third party composition
  \item has no externally observable state
\end{enumerate}

%%%Meyers Definition
Meyer's definition of software components is enumerated as:
\begin{enumerate}
  \item May be used by other software elements (clients)
  \item May be used by clients without the intervention of the components
  developers
  \item Includes a specification of all dependencies (hardware and software
  platform, versions, other components)
  \item Includes a precision specification of the functionality it offers
  \item Is usable on the sole basis of that specification
  \item Is composable with other components
  \item Can be integrated into a system quickly and smoothly
\end{enumerate}

%%%Using a component model
Others, like Heineman and Councill \cite{heineman2001component} have stated that components must conform to a component model, 
\begin{quotation}
A software component is a software element that conforms to a component model and can be independently deployed and composed without modification according to a composition standard.
\end{quotation}

Defining a component model as:
\begin{quotation}
A component model defines a set of standards for component implementation, naming, interoperability, customization, composition, evolution, and deployment.
\end{quotation}

%%%Other differences, architectural/implementation
Exactly what is, and what is not a software component is then in dispute amongst the community.
As such, many different components models have been developed, each targeting various domains with different functionality and technical aspects.
This diversity has inspired a classification approach from \cite{Crnkovic2011}, where components and component models are classified into a scheme.
This effort highlights the difficulty in creating an exact definition of a software component. 

%%%It is difficult to define a natural concept such as component with a set of fixed enumerable features.
These problems with exactly defining a software component may stem from the fact that ``component'' is a natural concept.
The problem, observed from the area of formal concept analysis \cite{Ganter1999} by \cite{Szyperski2002}, is that it is impossible to

\begin{quotation} 
``enumerate a fixed agreeable set of features that is necessary and sufficient for a natural concept such as component.'' 
\end{quotation}

%%%Our egotistical view of components is defined with relation to Component Dependency Resolution.
However, a definition can be found, not by feature enumeration but through stating the intention for the concept and exploring the technically inevitable consequences \cite{Szyperski2002}. 
As the intention of this study is to investigate component dependency resolution and evolution strategies,
the definition of software component used will be in respect to these aspects.

%%%This will not fit all views of what a component is (no definition will), but it eliminates unnecessary arguments so we can focus on CDR
This view of a software components definition will not agree with every persons view of what a software component is, but (as described above) no view can.
By only looking at aspects that are necessary for our topic, the arguments over unnecessary semantics are eliminated, leaving only the core aspects of this research. 

\subsection{Software Component}
The definition of a software component is given with respect to the evolution of the system using component dependency resolution.
Both these areas will be explored further in this chapter, however it is most important to first define the concept of ``software component''.
This definition specifies requirements on the component model that ensure it is applicable in this research.

For CDR to be used with a component system, there are two core requirements, the component model must:
\begin{enumerate}
  \item require the explicit definition of dependencies between components
  \item include mechanisms in which to programmatically compose or evolve a component system
\end{enumerate}
This definition leaves undefined many aspects of component model, however these are ignored as they are not related to CDR of component system evolution.

%%%A component must have explict (computer readable) requirements on the context in which it can be used. Different from COTS requirements which are meant to be human readable.
To automate the resolution of dependencies between components, these dependencies must be explicitly defined and computer readable.
These dependencies constraint the environment in which the component can be executed.
As CDR requires the ability to calculate systems that will function, this requirement is necessary.

%%%The component model should specifiy mechanisms to support evolution of the system; e.g. the addition and removal of components from a composition.
The creation or evolution of a component system must be able to be automated for CDR to be usable.
This means that CDR should have the ability to add, remove and replace components in a system, and create a functioning system.
These actions can occur at either at compile-time or run-time of the system.
As CDR would evolve a system automatically, these actions must be able to be enacted either through a function call, or well defined command interface.

%%%Aspects such as semantics of composition, distribution, development, are outside the scope of CDR, therefore ignored in this definition (that is not to say they are unimportant).
The classification, from \cite{Crnkovic2011}, of a component model is partially described as:
\begin{itemize}
  \item Lifecycle 
  		\begin{itemize}
	  		\item Modelling
	  		\item Implementation
	  		\item Packaging
	  		\item Deployment
		\end{itemize}
	\item Construction
		\begin{itemize}
	  		\item Interface Specification
	  		\item Binding
	  		\item Interactions 
		\end{itemize}
	\item Extra Functional Specifications
		\begin{itemize}
	  		\item Management
	  		\item Specification
	  		\item Composability
		\end{itemize}	
\end{itemize}  
This list displays the complexity in defining a component model.
In this classification scheme, the two aspects that are included in this definition are lifecycle deployment for the evolution of a component system, 
and construction interface specification for the explicitly defined dependencies.
All the other aspects that practically must be defined, are here ignored as their definition is superfluous to the core topic of this research.

These core aspects will be explored in the following sections, with examples of different component models and CDR implementations being presented.




\section{Component Models}
\label{background.models}
%%%Some core component models are described, and their dependencies and evolution are discussed
Given the definition of a software component for this research, some current component models are described and discussed.
These models come from industry (OSGi, Eclipse Plugins, Fractal, Maven), open source community (Debian, RPM) and academia (SOFA2).

The typical mechanism in which components, from these frameworks, describe their relationships is through meta-data files.
These files contain what the component requires and provides, as well as other information like versions and provider details.
The way in which these component models express their relationships will be described.

Typically, the component model also provides a mechanism to alter the system of components.
This is usually a low level interface, such that the addition of a component is an atomic step and does not lead to the addition of other components.
When applicable, these mechanisms will also be described.

Together, the declaration of the component relationships, and the mechanisms to alter the system mean these models fall within our component definition.

To compare these component models, the relationship of a text editor component, that requires a spell checker component is used.
This is a simple example, however it highlights the possible differences in these models.


\subsection{OSGi}
%%%What OSGi is? Bundle Service
OSGi is a mature component model from the OSGi Alliance.
It has a significant presence in industry \cite{Kriens2008} from organizations like the Eclipse Foundation with their Equinox framework and Apache with Felix framework.

OSGi components are refereed to as bundles, these contain JVM classes with meta-data describing their relationships.
A notable difference between OSGi and other component frameworks is that it separates the unit of deployment, the bundle, and the unit of deployment the service.
These services exist on a separate layer to the bundles, each service is created at run-time and is represented by a Java object.
This service layer allows third-party frameworks to describe service relationships, e.g. Spring Dynamic Modules.
These relationships and the interaction with services make themselves a component, under our definition.
A standard way of interacting with this layer is defined in the OSGi compendium is Declarative Services (DS).

OSGi is implemented to allow dynamic interaction, the addition and removal of bundles at run-time.
This can be done through a console implemented in the Equinox OSGi framework, this enables user interaction.

An example of a bundle which defines a text editor that depends on a spell checker is described in figure \ref{osgibundle}.

\begin{figure}[htp]
\begin{center}
\begin{alltt}
Bundle-Name: TextEditor
Bundle-Vendor: Graham Jenson
Bundle-SymbolicName: nz.geek.maori.textEditor
Bundle-Version: 0.0.1.alpha
Bundle-RequiredExecutionEnvironment: J2SE-1.4
Export-Package: nz.geek.maori.textEditor;version="0.0.1.alpha"
Require-Bundle: nz.geek.maori.fonts
Import-Package: nz.geek.maori.spellchecker;version>"0.0.1"
\end{alltt}
  \caption[OSGi Meta-data]{Example of OSGi Meta-data}
  \label{osgibundle}
\end{center}
\end{figure}

%%%OSGI Meta data description
This meta-data shows the name, version and vendor of the component, as well as the exported packages (referring to Java packages) which are able to be used by other components.
The \verb+Require-Bundle+ key expressed the direct dependence on another bundle.
The \verb+Import-Package:+ key expresses the dependence on a package provided by a bundle and not on the bundle itself.

This meta-data only contains the necessary relationships to install a bundle, not what it requires to be functional.
This information is in the service layer, described by the meta-data available in DS.
An example of this meta-data is in figure \ref{dsmetadata}.

\begin{figure}[htp]
\begin{center}
\begin{alltt}
<?xml version="1.0"?>
<component name="textEditor">
    <implementation class="nz.geek.maori.textEditor.TextEditorImpl"/>
    <service>
        <provide interface="nz.geek.maori.textEditor.TextEditor"/>
    </service>
    <reference name="spellChecker"
        interface="nz.geek.maori.spellchecker.SpellChecker"
        bind="setSpellChecker"
        unbind="unsetSpellChecker"
        cardinality="0..1"
        policy="dynamic"/>
</component>
\end{alltt}
  \caption[OSGi Declarative Services]{Example of OSGi Declarative Services meta-data}
  \label{dsmetadata}
\end{center}
\end{figure}

This meta-data includes references to implementation elements like interfaces that are provided and required, and methods to interact with the services.
These relationships can have cardinalities, e.g. a text editor can use multiple spell checkers, and other programmatic features.
The goal of this service meta-data, like the bundle meta-data, is to express the environment in which this component can be used by others.
The \verb+service+ tag describes the services provided, and the \verb+reference+ tag expresses a dependence on another services.

%%%DS provides no versioning
One aspect of DS that is lacking, is the ability to explicitly version services.
The version of the bundle that is providing the service and the version of the package that is provided by the bundle, implicitly version the service being provided.
However, for the evolution of a component model, some type of versioning is required to give a relative timestamp of it's development.
This may make the evolution of these services difficult to predict, and therefore difficult to use CDR to evolve them. 


\subsubsection{Evolution of OSGi}
The programmatic evolution of an OSGi system is defined in the interfaces created by the OSGi alliance \footnote{http://www.osgi.org/javadoc/r4v43/}, therefore are OSGi framework agnostic.
The installation and removal of both the bundles and services from the OSGi system are defined as such:
 
\begin{itemize}
  \item To install a bundle: \verb+org.osgi.framework.BundleContext.install+
  \item To uninstall a bundle: \verb+org.osgi.framework.Bundle.uninstall+
  \item To register a service: \verb+org.osgi.framework.BundleContext.registerService+
  \item To unregister a service: \verb+org.osgi.framework.ServiceRegistration.unregister+
\end{itemize}

OSGi therefore has the necessary elements in order to be considered a component model for this research. 
It has the ability to explicitly describe relationships between either bundles or services, and to install and remove bundles from the system.

\subsubsection{OSGi Bundle Repostiory}
%%%The OBR proposed by Peter Kriens and Richard Hall, is a meta data format for OSGi bundle resolution
Peter Kriens \cite{kriens_osgi_2008}, 
a primary author of the OBR \cite{the_osgi_alliance_rfc-0112_2006}, described a use of a component repository within a resource constrained environment.
When a device registers, 
through the repository, the driver for that device is loaded and then used, until the device is no longer available
then to conserve resources the driver is uninstalled dynamically. 
This demonstrates two requirements for a component repository, dynamic installation and uninstallation and being scalable to small devices.

For the OBR, we reviewed the standard \cite{the_osgi_alliance_rfc-0112_2006}, 
contacted both authors \cite{kriens_osgi_2008, richard_s._hall_obr_2008} 
and downloaded the open source Apache Felix OBR implementation and reviewed the source code.
OBR was our most completely reviewed repository.

OSGi is a 
mature standard component model from the OSGi Alliance that has seen a recent uptake in industry \cite{kriens_osgi_2008} 
from organizations like the Eclipse Foundation with their Equinox framework and Apache with Felix. This has multiplied the 
number of available bundles \cite{the_osgi_alliance_rfc-0112_2006}. OSGi Bundle Repository (OBR) was initially defined by 
Richard S. Hall, and later Peter Kriens, to help with the distribution of components, and is proposed in 
RFC-0112 \cite{the_osgi_alliance_rfc-0112_2006}. The design follows a federation of repositories each describing 
the capabilities and requirements of it's components and providing a URL to access it. Search is done using syntax with OSGi filter 
based expressions. This repository can also resolve dependencies and install these composites into a system. \\
OBR has been seen as a solution to to simplify deployment of OSGi applications
\cite{jung_integrating_2007}, distribution and deployment to embedded
ubiquitous systems \cite{jung_embedded_2006}, smart home applications \cite{gouin-vallerand_managing_2007} and 
dynamic distribution of drivers \cite{kriens_osgi_2008}. It is the only easily available deployment 
architecture available for OSGi, others have been developed to either extend or compete \cite{frnot_component_2005} with OBR, 
but are either in development, have been abandoned or are proprietary.\\ 
The most mature implementation of OBR client is offered by Apache, it is bundled with their core OSGi framework, Felix. 
The largest public OBR implementation is the federated repository provided by the OSGi alliance,
currently (as of 6 January 2009) aggregating components from Apache (32 bundles) and Eclipse (1534 bundles).
There are also many private repositories, some discussed with as much as 5000 bundles involved \cite{kriens_osgi_2008}.\\  

\subsection{Eclipse Plugins}
%%%What is Eclipse
Eclipse is a widely used IDE and an extencible plugin platform for createing Java applications.
It is built on top of the OSGi framework, but ignore OSGi's service layer and re-implements it with its own Eclipse plugin runtime.
Therefore, like the declaritive services, the distruted elements are OSGi bundles but the run time elements are plugins.

These plugins are defined using extensions and extension points, these are the relationships between the plugins.
An example of the meta-data describing a plugin is given in figure \ref{eclipseplugin}. 

\begin{figure}[htp]
\begin{center}
\begin{alltt}
<?xml version="1.0"?>
<plugin
    name="Text Editor"
    id="nz.geek.maori.textEditor"
    version="0.0.1.alpha"
    provider-name="Graham Jenson">
    
    <requires>
        <import plugin="nz.geek.maori.fonts"/>
    </requires>

    <runtime>
        <library name="texteditor.jar"/>
    </runtime>
    
    <extension-point id="nz.geek.maori.spellchecker" 
        name="Spell Checker" 
        schema="spellchecker.exsd"/>
</plugin>
\end{alltt}
  \caption[Eclipse Plugin meta-data]{Example of an Eclipse Plugin plugin.xml meta-data file}
  \label{eclipseplugin}
\end{center}
\end{figure}

This plugin defines the name, version and provider of the plugin, and using the tags \verb+requires+ defines the requirements of this plugin to function.
The \verb+extension-point+ tag defines not only what the plugin provides, but also the required information it requires in order to provide it, described in a schema.
This is a special feature of the Eclipse plugin framework, as other component models generally do not specify these parameters on this type of relationship. 

The schema of an extension point, as shown in figure \ref{eclipseextensionschema}, describes the elements to use an extension.

\begin{figure}[htp]
\begin{center}
\begin{alltt}
<schema targetNamespace="null" xmlns="http://www.w3.org/2001/XMLSchema">
 <element name="spellchecker">
  <complexType>
   <attribute name="spellchecker" type="string" use="required">
    <annotation>
     <appinfo>
      <meta.attribute kind="java" basedOn=":nz.geek.maori.ISpellChecker"/>
     </appinfo>
    </annotation>
   </attribute>
  </complexType>
 </element>
</schema>
\end{alltt}
  \caption[Eclipse Plugin extension point schema]{Example of an Eclipse Plugin extension point schema file}
  \label{eclipseextensionschema}
\end{center}
\end{figure}

In this description, this extension point requires a string that describes a java class that implements \verb+nz.geek.maori.ISpellChecker+.
This is the only requirement for this extension point, but other parameters of types, e.g. Boolean, integer, can be defined.

\subsubsection{Eclipse Evolution}
The programmatic evolution of an Eclipse system is through the use of the previously OSGi methods and with interaction with the plugin registry.

As an eclipse plugin is an OSGi bundle, and the eclipse framework uses OSGi, the methods for installing and removing a plugin are the same as for OSGi.

The extensions and extension points, for an Eclipse system, can be altered in the plugin registry.
This is the storage of all the extensions and extension points for interaction, and the core interaction with this layer of the plugins.
The methods used to add and remove these are then:

\begin{itemize}
  \item add extensions and extension points described in an XML file : \verb+org.eclipse.core.runtime.IExtensionRegistry.addContribution+
  \item remove extension: \verb+org.eclipse.core.runtime.IExtensionRegistry.removeExtension+
  \item remove extension point: \verb+org.eclipse.core.runtime.IExtensionRegistry.removeExtensionPoint+
\end{itemize}

The Eclipse plugin system can therefore be defined as a component system in this study.
It contains the necessary explicit relationships, and the programmatic evolution requirements necessary for CDR to be used.

\subsubsection{Eclipse P2}
%%%The Eclipse P2 Solver, by Le Berre and Rapicault

For the Eclipse P2 repository system there was extensive literature provided by the Eclipse foundation in the form of a developer forum.
We also reviewed an early implementation through use of the software within the Eclipse environment.
Due to its recent release there is no literature reviewing or discussing this software.

Eclipse P2
is the new provisioning system for the Eclipse IDE platform.
It provides an update manager, the functionality to component pool, and a new dependency resolver.\\
The update manager is what most users will be familiar with, being the primary interface to the P2 functionality. 
A public repository, called a site, is added, and can be searched for components and their dependencies to install, and run.
This simplifies the evolution of Eclipse based applications to a simple user interface.\\
Component or bundle pooling uses a centralised set of components to run different applications.
This comes from the common problem of running multiple Eclipse based applications on the same system with different combinations of components.
A file is used to describe what components should be used in each particular application and P2 builds the composition into an application.\\
The dependency resolver of P2 is based on SAT4J\footnote{http://www.sat4j.org/} technology, a SAT resolver, which finds an optimal solution based on
a provided fitness function, if a solution exists it is guaranteed to find it.\\  
Eclipse already is
the core of many applications with its Rich Client Platform. This is a large base of applications that already support and can integrate with P2.

\subsection{Fractal}
Fractal is a component model developed by France Telecom R\&D and INRA.
It is a specification that is designed to be programming language independent, unlike OSGi or Eclipse.
The most notable aspect, and the reason for its name, is that a components can be composed together to make a new component.
This recursive nature of composition, actually means the the system of components is itself a component.

An example of meta-data to define a Fractal component is given in figure \ref{fractalmetadata}.

\begin{figure}[htp]
\begin{center}
\begin{alltt}
<?xml version="1.0" encoding="ISO-8859-1" ?>
<!DOCTYPE definition PUBLIC 
    "-//objectweb.org//DTD Fractal ADL 2.0//EN" 
    "classpath://org/objectweb/fractal/adl/xml/basic.dtd">

<definition name="textEditorComponent">
  <interface name="textEditor" role="server" signature="nz.geek.maori.textEditor"/>
  <interface name="spellChecker" role="client" signature="nz.geek.maori.spellChecker"/>
  <content class="nz.geek.maori.textEditorImpl"/>
</definition>
\end{alltt}
  \caption[Fractal ADL Example]{Example of a simple Fractal ADL file}
  \label{fractalmetadata}
\end{center}
\end{figure}

This meta-data describes the relationship between components as the metaphor of client and server.
The interface tag with the role attribute assigned to ``server'', defines the provided functionality of the component.
The interface tag with the role attribute assigned to ``client'' then defines the required functionality of the component.  

An example of the definition of a recursive component can be seen in figure \ref{fractalrecursve}.

\begin{figure}[htp]
\begin{center}
\begin{alltt}
<?xml version="1.0" encoding="ISO-8859-1" ?>
<!DOCTYPE definition PUBLIC 
    "-//objectweb.org//DTD Fractal ADL 2.0//EN" 
    "classpath://org/objectweb/fractal/adl/xml/basic.dtd">

<definition name="textEditorWithSpellCheckerComponent">
  <interface name="textEditorWithSpellChecker" role="server" signature="nz.geek.maori.textEditorWSC"/>
  <component name="textEditorComponent">
    <interface name="textEditor" role="server" signature="nz.geek.maori.textEditor"/>
    <interface name="spellChecker" role="client" signature="nz.geek.maori.spellChecker"/>
    <content class="nz.geek.maori.textEditorImpl"/>
  </component>
  <component name="spellCheckerComponent">
    <interface name="spellChecker" role="server" signature="nz.geek.maori.spellChecker"/>
    <content class="nz.geek.maori.spellChecker.SpellChecker"/>
  </component>
  <binding client="this.textEditorWithSpellChecker" server="textEditorComponent.textEditor"/>
  <binding client="textEditorComponent.spellChecker" server="spellCheckerComponent.spellChecker"/>
</definition>
\end{alltt}
  \caption[Fractal ADL Example]{Example of a simple Fractal ADL file}
  \label{fractalmetadata}
\end{center}
\end{figure}

In this description of a recursive component structure, as well as defining both the text editor and spell checker components it also defines and instructs their relationships.
The tag \verb+definition+ is then used as a container of components, rather than the deifnition of a single component.
This composite component defines that it provides a service of \verb+textEditorWithSpellChecker+.
To provide this the spell checker must be bound (described in the tag \verb+binding+) to the text editor,
and the text editors provided interface bound to the output interface. 

The programmatic evolution of a Fractal component system can differ between implementations.
To simplify this, only the Java implementation is described. 

\subsubsection{Fractal Evolution}
In this implementation the methods to edit the configuration are\footnote{http://fractal.ow2.org/current/doc/javadoc/fractal/}:
\begin{itemize}
  \item to create a component: \verb+org.objectweb.fractal.api.factory.GenericFactory.newFcInstance+
  \item to add a component to a composite: \verb+org.objectweb.fractal.api.control.ContentController.addFcSubComponent+
  \item to remove a component from a composite: \verb+org.objectweb.fractal.api.control.ContentController.removeFcSubComponent+
\end{itemize}

There are two points that may make the evolution of Fractal component model particularly difficult,
the recursive nature of Fractal, and the lack of required version information about components and composites.

%%%Fractal requires not only the selection of components but the configuration
Given the recursive nature of the components described, any system may provide the same functionality with the same components in a combinatorial number of configurations.
Therefore, not only would a CDR algorithm require to select a set of components but also provide or select the composites to configure them.
The simplest solution to this problem is to ignore the recursive nature of this component model,
and use a CDR algorithm to create exactly one composite with all components in it.
More difficult solutions could be created by reusing user composites, or analyzing the graph structure and grouping into clusters using algorithms like the one presented in \cite{dietrich2008cluster}.

Another aspect of Fractal that will make the automatic evolution of systems difficult will be the lack of versioning information.
Like DS, this component model doesn't not explicitly require the version of the component and the interfacs they provide.
As versions are typically the atomic unit of evolution, the process of selecting a newer version will be made more difficult if not impossible. 

\subsection{Maven}
Maven is a build automation tool, designed to be programming language agnostic but primarily used with Java.
The core component aspect of Maven is that it can dynamically select and download files from a repository to be used to build a system.
Although Maven is built using a plugin architecture, the focus in this section is on the use of Maven as a component model and not Maven itself.

A system is defined using a Project Object Model (POM) file, an example given in \ref{mavenmetadata}. 

\begin{figure}[htp]
\begin{center}
\begin{alltt}
<project xmlns="http://maven.apache.org/POM/4.0.0"
  xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
  xsi:schemaLocation="http://maven.apache.org/POM/4.0.0
                      http://maven.apache.org/xsd/maven-4.0.0.xsd">

  <groupId>nz.geek.maori</groupId>
  <artifactId>textEditor</artifactId>
  <version>0.0.0.alpha</version>

  <dependencies>
    <dependency>
      <groupId>nz.geek.maori</groupId>
      <artifactId>spellChecker</artifactId>
      <version>[0.0.1,1.0.0)</version>
      <type>jar</type>
     </dependency>
  </dependencies>
</project>
\end{alltt}
  \caption[Maven POM file]{Example of a Maven POM file}
  \label{mavenmetadata}
\end{center}
\end{figure}

This model defines the components namespace using the \verb+groupId+ tag, the name using the tag \verb+artifactId+, and the version.
It also defines the dependencies on other projects through the \verb+dependency+ tag,
where it states that it depends on the artifact \verb+spellChecker+ from versions 0.0.1 to (but excluding) version 1.0.0.

\subsubsection{Maven Evolution}
The use of Maven as a development time component model, does not exclude it from the definition of being a component model in this study.
Though it puts it in a unique situation, where it does not evolve a component system by altering it, but by recompiling and replacing it.
Therefore, the evolution of a Maven based system is done simply by selecting the projects to build, and using Maven to compile them into a system. 

Another core difference from the other presented component models is that Maven POM objects do not declare what they provide.
For example, an OSGi bundle can declare provided packages and a Fractal component declares provided interfaces, where a Maven project can only provide itself.
This will simplify a CDR algorithm by not having to resolve another layer of dependencies.

\subsection{Debian Packages}
Debian is a GNU/Linux based operating system provided by the Debain Project.
This operating system most prominent feature is that it is composed of packages, unit of deployment with explicit dependencies.

Each package is defined using a control file, an example presented in figures \ref{debianmetadatate} and \ref{debianmetadatasc}.

\begin{figure}[htp]
\begin{center}
\begin{alltt}
Package: textEditorPackage
Version: 0.0.1.alpha
Depends: spellChecker
Conflicts: otherTextEditorPackage
\end{alltt}
  \caption[Debian Control file for Text Editor]{Example of a Debian Control File for Text Editor}
  \label{debianmetadatate}
\end{center}
\end{figure}

\begin{figure}[htp]
\begin{center}
\begin{alltt}
Package: spellCheckerPackage
Version: 1.0.0
Provides: spellChecker
\end{alltt}
  \caption[Debian Control files for Spell Checker]{Example of a Debian Control File for Spell Checker}
  \label{debianmetadatasc}
\end{center}
\end{figure}

These control files describe two packages, a text editor and spellChecker, they are organised into key/value pairs seperated by the ``:'' character.
The text editor states using the \verb+Depends+ key that is requires a spellChecker to be installed, 
and through the \verb+Conflicts+ key states that it cannot be installed with another text editor.
The spell checker package defines that it provides a spell checker  using the \verb+Provides+ key.

The semantics of these control files is further described in the section \ref{DebToCUDF}.

One aspect that differentiates the Debian package model from the many other models, is that it does not specify the rules of composition between components.
That is, there is no formal specification of the semantics of the communication and relationships between packages.
For instance, OSGi bundles exist in a very constrained environment that manages their interactions, dependning on another bundle gives has run-time implications.
For Debian, the dependence has no run-time effects, only whether the package is functional or not.
The way in which a package, uses or communcates with a depended upon package is then defined between the packages and not in the component model.

Since the composition of packages is not an aspect of this study, this is a valid component model, though some may disagree.


\subsubsection{Debian Evolution}
The application dpkg is the command line tool use to modify a Debian package system.

The commands to modify a Debain package system are:
\begin{itemize}
  \item to add a package: dpkg --install <package file>
  \item to remove a package: dpkg --remove <package>
\end{itemize}

These commands define the atomic actions to change a Debain system.
They can be executed from other applications through the command line, this makes them programming language independent and easily accessible. 

\subsubsection{Apt-get}
%%%Apt-get is the core application for package management in Debian based GNU/linux distributions

Debian is a free and open source GNU/Linux based operating system. 
Debian's package system (dpkg) is used to install, remove and provide information about the operating system packages. 
APT is a repository client built on top of dpkg and simplifies it's functionality.\\
Aptitude is an application that adds a basic user interface to APT and also increases functionality in aspects like 
locating and removing redundant packages. 
Search of a package repository is done using regular expressions mixed with a
custom set of search terms that increase expressiveness. Using a simple
constraint-directed best-first search algorithm with some basic conflict
tracking Aptitude resolves dependencies between packages, and generates
composites to install.\\ 
There are many public and private implementations of this repository system. 
The largest public implementation is the Debian public repository, with 28078 packages in the ``Lenny'' stable repository.
With the most popular Debian distribution Ubuntu\footnote{http://www.ubuntu.com} having ten million users \cite{vance_software_2009} the user base for this repository is massive.
This repository has many regulations to publish and distribute, enumerated in the Debian Developers Reference \cite{andreas_barth_debian_2008}. 
User and automated testing is recommended, and if any critical bugs are found they are removed from the repository. 
This very manual way of publication and
distribution has its drawbacks, mostly the long community process that must be followed.\\

\subsubsection{Aptitude}
%%%Aptitude is a competitor to apt-get which has some more advanced features
Aptitude with APT, has immense amounts of information free on-line, the hardest part was reviewing as much as possible.
We also used and read the help documentation, contacted the author of the software \cite{burrows_modelling_2005} and
the Debian developers reference for the specific implementation of the Debian repository.


\subsection{SOFA 2.0}
Software Appliance (SOFA) is a component model developed at Charles University in Prague.
A component in the SOFA framework is defined by it's frame, which contains the meta-data of what the component requires and provides.
Like Fractal, SOFA is a recursive component model, allowing for a composite of components to be treated as a single component.

An example definition of a frame is given in figure \ref{SOFAmetadata}.

\begin{figure}[htp] 
\begin{center}
\begin{alltt}
<?xml version="1.0"?>
<frame name="nz.geek.maori.textEditor">
  <requires name="spellChecker" itf-type="sofatype://nz.geek.maori.spellChecker"/>
</frame>

<?xml version="1.0"?>
<frame name="nz.geek.maori.spellChecker">
  <provides name="spellChecker" itf-type="sofatype://nz.geek.maori.spellChecker"/>
</frame>
\end{alltt}
  \caption[SOFA ADL files]{Example of a SOFA ADL Files}
  \label{SOFAmetadata}
\end{center}
\end{figure}

This meta-data descirbes two components, a text editor and a spell checker, using the tag \verb+frame+.
The sub elements \verb+requires+ and \verb+provides+ describes their relationship through an externally defined interface with the namespace \verb+sofatype://nz.geek.maori.spellChecker+.
This interface is defined using an Architecture Definition Language (ADL) and added to a repository to be re-used. 


\subsubsection{SOFA Evolution}
SOFA 2.0 is an extension of the SOFA framework, with new services including dynamic reconfiguration for dynamic evolution of an architecture at runtime. 
Unlike other component systems,
it only allows for controlled evolution; 
Many component models allow the change of the component system on a fine grained level of adding or removing a component.
However this model only allows more grainular changes to be made to the system, these changes must conform to specified evolution patterns.
This restriction is meant to increase the manageability and predictability of a component systems evolution. 

Three evolution patterns are predefined: factory pattern, removal pattern, and service access pattern.
As its name suggests, in factory pattern a designated component serves as a component factory. 
The removal pattern serves for destroying of a component previously dynamically created.
The service access pattern allows for the access to external services.
These patterns are further discussed in \cite{Hnetynka2006}.


\subsection{Common Upgradeability Description Format}
%%%CUDF model created for compeition
The Common Upgradeability Description Format (CUDF) model is defined as an abstract representation of the problem found when evolving a package based system, e.g. Debian.
It was created by the Mancoosi project to foster interest and competition in creating solvers for upgrading problems faced by Free and Open Source Software (FOSS).

%%%No concrete components, but fits our definition
There is no concrete component representation, as it was not designed to be an executable component model.
However, as it takes a similar definition of component to this research, it fits within our  

In figure \ref{CUDFmetadata}, an example of a CUDF problem is presented.

\begin{figure}[htp] 
\begin{center}
\begin{alltt}
package: textEditor
version: 1
depends: spellCheckerService

package: spellChecker
version: 2
provides: spellCheckerService

request:
install:textEditor

\end{alltt}
  \caption[CUDF meta-data file]{Example of a CUDF problem file}
  \label{CUDFmetadata}
\end{center}
\end{figure}

The CUDF file is defined using key/value pairs, where each component is defined using the two tags \verb+package+ and \verb+version+.
This file does not only represent the components but also the evolutionary change with the tag \verb+request+.
Further definition of the syntax and semantics of CUDF is in chapter \ref{cdr}, as it is used extensivly throughout this study.

\subsubsection{Mancoosi MPM}
%%%The mancoosi Modular Package Manager uses CUDF, currently going through the process in the Debian component repository

\subsubsection{P2CUDF implementation}
%%%Our implementation is based off of Daniel Le Berre and Rapicult P2CUDF, which uses SAT4J a SAT and PB solver, tested and validated in competitions.
The Mancoosi organisation who have created the CUDF standard have also organised competitions for the solvers.
One implementation of note is the P2CUDF implementation, that uses SAT



\section{Summary}

In this chapter the process of software evolution and the use of component based systems within this process has been described. 













