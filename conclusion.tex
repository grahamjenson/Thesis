\chapter{Conclusion}
\label{conclusion}
%%%The conclusions from this work are made the use of Component dependency resolution

%%%The increased use of component Dependency Resolution in component models, as they mature the requirements that they must satisfy

%%%The way in which components depend on each other must be an important issue when defining component models as it will effect the use of resolution

%%%Initial Investigation conclusions

%%%Simulation Conclusions

%%%Final thoughts

\section{Related Work}
Researchers often look at the mechanisms of component evolution \cite{Wang2006}, how to add or remove a changed component in a system.  
However, we are looking at the architectural level into the properties of the component system as it evolves.
This paper has many similarities to the empirical work into software evolution by Lehman \cite{lehman1980},
which looks for laws and relationships between software and its evolutionary process.
In this paper we aimed to look into the evolution of component systems through CDR,
and identify the consequences of different definitions of minimal change. 

Research into how the finer-grained evolution of individual components integrates with the larger architectural view of component systems, which
usually focuses on component versioning \cite{Bauml2009,Stuckenholz2005}.
This work aims to add well-defined semantics to component versions, 
allowing them to describe if a component has changed its external requirements or if it has only changed internally.
Adding this to component models would allow CDR to make more informed decisions during evolution, 
and through experiments similar to the one described in this paper,
their semantics could be tested to find if their effect is positive to system evolution.

%%%Mancoosi is by far the most related work, though its focus is slightly different
As mentioned many times throughout this paper, 
the Mancoosi organisation is producing significant research in the area of Component Dependency Resolution.
They have defined the format CUDF \cite{treinen2009common}, to express and solve the CDR problems.
They also run constant comparisons against different CDR implementations through the Mancoosi International Solver Competition (MISC),
which we based our experiment on.
They also contribute significantly in the areas of modelling the problem \cite{Cosmo2010} 
and defining and researching solutions for it \cite{Trezentos2010}.
%TODO write more here

Belief revision is an area of logic that focuses on changing beliefs to take into account new knowledge.
The Alchourr\'on, G\"ardenfors, and Makinson (AGM) \cite{alchourron1985logic} postulates give a set of eight properties 
that a revision operator needs to satisfy in order to be considered rational.
An intention of these postulates to ensure minimal change of the set of knowledge when it is revised.
For example, if you saw what you thought was a flying pig, but you later found out it was a bird;
when using belief revision you should revise the minimal amount of knowledge, therefore only discard the belief it was a pig, 
while maintaining the belief it was flying.
By stating whether a component is installed or not as a fact,
and revising these facts with user requests, we are able to define CDR w.r.t. belief revision.
This area of logic is very focused on what is minimal and how to define a minimal operator that is considered rational; 
we have taken much inspiration from this domain.



%%%Daniel Le Beere and Pascal Rapicault making EclipseP2 P2CUDF and Sat4J are all very related

%%%Lehmans Laws of Evolution inspired our research into Component System Evolution
Software evolution is continual management of change to software. 
Software maintenance is often used to describe this,
however is considered an invalid description of evolution, as it conveys a
restoration of a system to a previous state, where evolution is a progression
of changes to a system \cite{lehman_software_2006}. Versioning software is the atomic mechanism of evolution, 
incrementing systems along the time axis.\\ 
Evolution is an intrinsic value of real world software
design and implementation \cite{lehman_programs_1980}. Laws of software
evolution identified by Lehman include continuing change, increasing complexity and
continuing growth \cite{lehman_rules_2001} to name a few. These empirically proven laws
display the importance of software evolution as a process within software
engineering.

Le Berre and Parrain \cite{Berre2008} describe methods for solving dependency resolution with minimal optimisation.
Dependency resolution is used in such areas as software product lines,
for instance Savolainen et al. \cite{savolainen_analyzing_2007} uses dependency analysis to identify and remove unnecessary features.
The optimisation of such algorithms is usually hard coded maximising version while minimising components, 
as discussed in Section \ref{sec:motivation}.
The algorithms that do optimise for other properties, 
such as one proposed by Aleti et al. \cite{Aleti2009} that uses ant colony optimisation for quality optimisation,
usually are not based on a formal framework for multi-criteria optimisation but defines a specific model for each problem.

Instances of different complete lattices used for constraint solving can be found in a similar framework based on c-semirings, 
by Bistarelli et al. \cite{Bistarelli1997}.
They prove that all instances of their framework are complete lattices, and their $+$ operator coincides with join
and if their $\times$ operator is idempotent, it coincides with meet.
Their examples include fuzzy, weighted, probabilistic and valued constraint problems which can be used in our framework.
In their framework $\times$ must distribute over $+$, this gives a distributive lattice,
since lexicographic orders may create non-distributive lattices, our overall frameworks are incompatible.
The c-semiring framework is still greatly useful as c-semirings are complete lattices all instances of this framework will work in ours.

Instances of complete lattices representing criteria can also be found from Fern\'{a}ndez and Hill's \cite{Fernandez} framework,
this represents constraint problems as intervals over lattices.
They give ample examples of lattices including binary strings, intervals and non negative integers ordered by division.
In their framework are presented lexicographic and product orders, and used intervals to describe constraints.
This framework has more of a focus on constraint representation and solution, 
where our framework is focuses on criteria composition.

Lexicographically ordered constraint satisfaction problems \cite{Freuder2009} has many similar ideas to this research.
It is an exploration of an idea (originally defined in as a part of valued constraints \cite{schiex1995valued})
where by ordering variables in the problem lexicographically you can represent user preferences.
This research offers definitions, proofs and background to lexicographical orderings.

Formally modelling preferences is explored in the article by Ozt\"urk et al. \cite{Ozturk}.
They define many types of preference orders, most assume either a total order, or a semi-order (where the order may not be transitive).
As our framework uses only complete lattices orders, the problem of composition and definition is simplified. 
They also discuss the concept of ``near'' which defines similarity or indifference between solutions.

\section{Future Work}
%%%Future work may be looking at different component models, and the application of CDR to them (e.g. Web Services)

%%%Changing Debian packages to have more standard composition, to make change less risky

%%%
