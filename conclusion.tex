\chapter{Conclusion}
\label{conclusion}
%%%Answers to our initial questions
The main research goal of this thesis is to study CSE.
This research has been directed towards this objective.
To attain this goal the semantics of component system evolution where defined, a CDR algorithm implemented and validated, user strategies for evolution explored,
and finally a simulation of the evolution of Ubuntu component systems conducted.
The assessment of the strategies took the form of answering various questions.

TODO describe the methodology


TODO DESCRIBE THE FOUND CONSEQUENCES I.E. How fast a system goes out of date when

How well has this research goal been attained?
Firstly; the strategies that have been accessed are component model (Ubuntu) specific. 
Secondly; not all strategies were enumerated and accessed.

Finding the consequences of component evolution on further component models (like the ones listed in chapter \ref{background}) to make generalisations is impractical and may be impossible.
This is because component models may not have enough information to create a simulation and the effort required to simulate them may exceed available resources of this project.

To simulate the evolution of a component model enough information to populate the variables of the conceptual model is required.
This information, like the likely hood a user will install a component, is often not accessible or does not exist.
The most difficult conceptual model attribute to assign is the repository function that returns a set of components that were available given a time. 
Many component models do not have a set of publicly available components, as their main users create proprietary components or do not see an advantage in sharing.
Component models that do make sets of component public often neglect to keep historical information, e.g. the OSGi repository OSGi Bundle Repository.
In some instances information is gathered but it may be incomplete or be stopped as it is seen to lack value,  
e.g. the Usage Data Collector\footnote{http://www.eclipse.org/epp/usagedata/faq.php} for the Eclipse project was shut down as it was deemed not to have a significant return on investment.  

If enough information was available for a simulation to be conducted, the effort of multiple simulations exceeds the resources of this project.
The computational power required to analyse just a single component model required many hours of high performance computers.
Each evolution problem is itself a hard problem to solve, to simulate generations of a single system was a massive undertaking.
The resources in both man hours and computational hours would need to be increased in order to analyse further component models.

Finding a complete set of all consequences for all user strategies is an impractical goal.
The amount of possible user strategies is massive, and only the common strategies where used in the simulation.
When these strategies where simulated only specific consequences where measured to answer the questions asked in chapter \ref{ubunutsimulation}.
Creating then simulating all possible user strategies would create a massive amount of data.
Then the extensive analysis of this data to find all consequences would likely be uninteresting and unusable.
Finding the consequences to a strategy that is not currently used provides little practical information.

What was presented in this thesis to answer the research question was 
\text{some} of the consequences when evolving an \textbf{Ubuntu} component system with CDR with \textbf{common} user strategies where described in this thesis.
This is believed to be significant enough to state that this research has been successful.  

To conclude this thesis, a list of contributions is briefly given as these are the ultimate outcomes of the research.
Then similar and used research from third parties are described to give a more general view of this domain.
Finally, the future of this research is outlined and the final thoughts are discussed.

\section{Contributions}
To answer the research questions various artifacts where created.
The artifacts that could be deemed useful to further study, that are also relatively unique are seen as contributions knowledge. 
These contributions include; the formal definition of component evolution, the implementation of CDR that evolves a component system,
the simulation that  

%%%Formalisation of evolution, the semantics

%%%GJSolver implementation 

%%%Simulation -- conceptual model

%%%List of consequences

%%%New stable components shown to reduce certain problems for certain user strategies

\section{Related Work}
Throughout this research the domains of software evolution, component based software engineering (CBSE) and component dependency resolution.
Research from these domains has shaped and informed this research, and in this section such research is discussed and contrasted with this thesis.

\subsection{Software Evolution}
%%%Lehman, other stuff on evolution
Software evolution is continual management of change to software. 
Software maintenance is often used to describe this,
however is considered an invalid description of evolution, as it conveys a
restoration of a system to a previous state, where evolution is a progression
of changes to a system \citep{lehman_software_2006}. Versioning software is the atomic mechanism of evolution, 
incrementing systems along the time axis.\\ 
Evolution is an intrinsic value of real world software
design and implementation \citep{lehman_programs_1980}. Laws of software
evolution identified by Lehman include continuing change, increasing complexity and
continuing growth \citep{lehman_rules_2001} to name a few. These empirically proven laws
display the importance of software evolution as a process within software
engineering.

This paper has many similarities to the empirical work into software evolution by Lehman \citep{lehman1980},
which looks for laws and relationships between software and its evolutionary process.
In this paper we aimed to look into the evolution of component systems through CDR,
and identify the consequences of different definitions of minimal change. 


\subsection{CBSE}
%%%All the CBSE stuff, Szyperski \ldots

Research often looks at the mechanisms of component evolution \citep{Wang2006}, how to add or remove a changed component in a system.  
However, this research looks at the architectural level into the properties of the component system as it evolves.
The mechanisms of exactly 

Research into how the finer-grained evolution of individual components integrates with the larger architectural view of component systems, which
usually focuses on component versioning \citep{Bauml2009,Stuckenholz2005}.
This work aims to add well-defined semantics to component versions, 
allowing them to describe if a component has changed its external requirements or if it has only changed internally.
Adding this to component models would allow CDR to make more informed decisions during evolution, 
and through experiments similar to the one described in this paper,
their semantics could be tested to find if their effect is positive to system evolution.

\subsection{Component Dependency Resolution}
%%%Le Berre and Parrain + Mancoosi 

%%%Mancoosi is by far the most related work, though its focus is slightly different than ours
As mentioned many times throughout this paper, 
the Mancoosi organisation is producing significant research in the area of Component Dependency Resolution.
They have defined the format CUDF \citep{treinen2009common}, to express and solve the CDR problems.
They also run constant comparisons against different CDR implementations through the Mancoosi International Solver Competition (MISC),
which we based our experiment on.
They also contribute significantly in the areas of modelling the problem \citep{Cosmo2010} 
and defining and researching solutions for it \citep{Trezentos2010}.
%TODO write more here

Le Berre and Parrain \citep{Berre2008} describe methods for solving dependency resolution with minimal optimisation.
Dependency resolution is used in such areas as software product lines,
for instance Savolainen et al. \citep{savolainen_analyzing_2007} uses dependency analysis to identify and remove unnecessary features.
The optimisation of such algorithms is usually hard coded maximising version while minimising components, 
as discussed in Section \ref{sec:motivation}.
The algorithms that do optimise for other properties, 
such as one proposed by Aleti et al. \citep{Aleti2009} that uses ant colony optimisation for quality optimisation,
usually are not based on a formal framework for multi-criteria optimisation but defines a specific model for each problem.

\subsection{Software product lines}


\section{Future Work}
%%%The formal model: the all-or-nothing returing of evolution if a evolution problem is unsatisfiable, the not considering previous user requests  

%%%The report returned because an evolution problem is unsatisfiable, how best to give this

%%%Future work may be looking at different component models, and the application of CDR to them (e.g. Web Services). Incuding recursive component models like Fractal

%%%Additional hard constraints, like apt-gets Never remove anything for an update

%%%Exploring more component models, and mapping them to CUDF to experiment with, and solve more problems.

%%%Making more criteria, based on testcases contracts user communities, as discuesed in chapter 

%%%Information from differnet loactions and meta data can be used to define the criteria.
Many different criteria can be created to be used in such a problem.
Criteria can be defined from current solvers like Eclipse P2's criteria to minimise the age of the installed components.
Information from component meta-data, component contracts \citep{Watkins1999}, repositories \citep{Guo2000}, 
composition testing \citep{XuejieZhang2008} and user preferences could be used to define criteria.
Additional criteria, such as size, reliability or licence, may change a systems' desirability, 
therefore during evolution the optimisation of such criteria may return better solution.

%%%Explore the difference between iterative strengthing one function vs lex iterative stregnenthing (e.g. Eclipse P2 vs GJSolver)

%%%Integration with MPM then test on real systems the implications of this research

%%%Further stufy of the interaction between users and their component systems. We found it hard to find information, maybe some research would be interesting,
%%%which we could include to make the simulations more valid.

\section{Final Thoughts}
The domain of software evolution is fundamental to software engineering, and this domain includes the evolution of component systems.
It is hoped that some aspects of component system evolution have been illuminated and that this research has contributed to the field. 

 
