\chapter{Formal Component System Evolution}
\label{formal}
\epigraph{In theory there is no difference between theory and practice. In practice there is.}
{\textit{Jan L. A. van de Snepscheut}}
Suppose a user wants to install a new text editor component into their system.
The selected text editor has a dependency on a spell checker;
meaning a spell checker component must be installed for the text editor to be functional.
There are three spell checker components available that satisfy this dependency,
this means that at least one of these spell checkers must be selected for installation as well.
How can the user select between which spell-checker to install? 

In another example the user already has the text editor installed, and wants to update it to a newer version to increase its stability and functionality.
There are two newer versions available, however the newest version of the text editor requires the system to install a new spell checker,
where the lesser up to date text editor can use the currently installed spell checker.
The different versions of the spell-checker component conflict with each other, they cannot coexist in the same component system.
Where one solution installs the newest text-editor it also requires reinstalling the spell-checker, 
while the alternate solution only requires changing the text-editor.
Both solutions will resolve the user's request, therefore the selection of an optimal solution is required.  

The first step in solving such component evolution problems is to represent them formally, i.e. the semantics.
These problems have constraints from component relationships, e.g. ``depends'' and ``conflicts''.
What exactly these relationships mean must be defined, before the concept of a ``solution'' can be explored.
These problems also require a framework in which to choose between various possible solutions.
The user's strategy will define which solution to select, but how to define which solution to pick is a difficult task.

The second step in solving component evolution problems is to be able to describe and convey them efficiently, i.e. the syntax.
A well formed language which maps to the semantics will enable a concise description of an evolution problem.
This description which will fully contain an evolution problem can then be used to find a solution.

In this chapter the semantics and syntax of the evolution of a component system is formally defined.
The core atomic problem in component system evolution is an evolution problem, the change made to the system at the user's requests.
The formal definition and the properties of the evolution problem and system evolution are presented in section \ref{formal.step}.
Through iteratively solving evolution problems, generations of the system is created over a period of time,
A discussion on this generational evolution of a component system is given in section \ref{formal.evo}

The way in which the user's strategy selects and optimal solution is represented in this research through the use of a criteria composed lexicographically.
Each criterion is represented as a ranking system over a complete lattices, described in section \ref{formal.opt}.
It is shown that when such criteria are composed they remain a ranking system over a complete lattice allowing the stacking of criteria.

The syntactic representation of the evolution problem and the user strategy's criteria 
are through the Common Upgradeability Description Format (CUDF) \citep{treinen2009common} 
and the Mancoosi Optimisation Format\footnote{http://www.mancoosi.org/misc-2011/criteria/} (MOF).
These allow an evolution problem to be described and how an optimal system is defined in order to find solution.
Both CUDF and MOF are defined and mapped to their semantic counterparts in section \ref{formal.cudf}. 

\section{Evolution Problem}
\label{formal.step}
In this section, a formal definition for an evolutionary problem is given.
This definition includes a simple optimisation framework to represent a user's strategy in selecting a solution.
This problem of finding a solution to an evolution problem is then shown to be NP-Complete,
and the problem of selecting and optimal solution is shown to be NP-Hard.

\subsection{Formal Definition}
%%%What a component is
First the space of components is denoted as $\mathbb{C}$.
Each component is described by a name and version ($\langle n, v\rangle$), such that no two components can have the same name and version.
A component can be denoted as $n^v$, where the version is superscript of the name e.g. $c^2$ is a component $\langle c, 2\rangle$.
If version and name are inconsequential, then components can be denoted as $a$,$b$,$c$\ldots

%%%What a component system is and the relationships
A component system is represented by a set of components, e.g. $\{a_1,c_2\}$ is a system with components $a_1$ and $c_2$ in it.
A component system is typically denoted as $\alpha$ or $\beta$, and a set of component systems is typically denotes as $A$ or $B$.
The relationships between all components are described by a set of constraints denoted as $R$.

%%%What the change is
The user's requested change to be made to their component system is defined as a set of constraints denoted as $\Delta$.

%%%What is a solution
An evolutionary problem is then the set of component relationship constraints with the user's request constraints, i.e. $R \cup \Delta$.
A solution to an evolutionary problem is then a set of components (a component system) that satisfies all constraints in $R \cup \Delta$.
The function $solutions$ is defined such that it takes a set of constraints and returns all solutions to the constraints,
i.e. $solutions(R \cup \Delta)$ equals all solutions of $R \cup \Delta$.

%%%Selecting a solution
Many component systems may satisfy the set of constraints $R \cup \Delta$ but only one system can be selected.
The function $rank$ is defined to take the previous component system and proposed system and return a measure of optimality to be maximised with respect to some order $>$. 
For example, given the current component system $\alpha$ and a proposed systems $\beta_1$ and $\beta_2$, 
$rank(\alpha,\beta_1) > rank(\alpha,\beta_2)$\footnote{the range of $rank$ (e.g. $\mathbb{R}$ or $\mathbb{N}$) and the relationship $>$ are left undefined here},
then system $\beta_1$ is said to be better, or more optimal than system $\beta_2$.
The $rank$ function is then the mechanism the user's strategy selects the optimal system.

It is important to note that the $rank$ function takes both the current and proposed system when measuring the system.
This allows it to measure the change to the system as well as the proposed systems overall optimality.
A ranking function that measures change between systems is described as \textbf{dynamic} and one that measures only the proposed system is described as \textbf{static}.
For example, a ranking function that measured the amount of removed components from the system is dynamic, but one that measures the resulting systems size is static.

%%%The evolutionary function
The function that takes a component system and evolves it to another system is described as an evolutionary step function and denoted as $E$.
This function then takes the evolution problem (the set of relationship and user request constraints), 
the user's strategy (the rank function), and the previous component system and returns the evolved, optimal system.

\begin{defs}
Given the previous system $\alpha$, the constraints $R \cup \Delta$ and the function $rank$ to be maximised with order $<$, the function $E$ is defined as
$E(\alpha, R \cup \Delta,rank) = \max \limits_{\beta \in solutions(R \cup \Delta)} rank(\alpha,\beta)$
\end{defs}

That is, $E$ evolves system $\alpha$ to another system that is a solution of $R \cup \Delta$ and that maximises the function $rank$.
Note: for rank to be minimise the order $<$ can be flipped to $>$.

\subsection{Relationships and Requests}
The relationship constraints and request constraints that form the sets $R$ and $\Delta$ can be further described. 

%%%Component realtionships constraints
The constraints in $R$ can be either: 
\begin{itemize}
  \item keep constraint in the form $a_1 \vee \ldots \vee a_n$, e.g. $a \vee b$ means the $a$ or $b$ must be in the system
  \item dependency constraint in the form $a \rightarrow c_1 \vee \ldots \vee c_n$, e.g. $a \rightarrow b \vee c$ means $a$ depends on $b$ or $c$
  \item conflict constraints in the form $a \rightarrow \neg c$, meaning $a$ conflicts with $c$
\end{itemize}

These constraints are defined semantically such that:
\begin{itemize}
	\item a keep constraint  $a_1 \vee \ldots \vee a_n$ in $R$ means for any solution $\alpha$ in $solutions(R \cup \Delta)$, $a_1 \in \alpha$ or \ldots or $a_n \in \alpha$ 
	(note: this can be a singleton e.g. $a$ is a valid keep constraint)
	\item a dependency constraint $a \rightarrow c_1 \vee \ldots \vee c_n$ in $R$ means for any solution $\alpha$ in $solutions(R \cup \Delta)$, then $c_1 \in \alpha$ or \ldots or $c_n \in \alpha$
	\item conflict constraint $a \rightarrow \neg c$ in $R$ means for any solution $\alpha$ in $solutions(R \cup \Delta)$, if $a \in \alpha$ then $c \not \in\alpha$
\end{itemize}
These constraints are expressive enough to describe many of the relationships from the component models described in section \ref{background.models}.
The main relationships that is not described here is that of composite relationships that exist in such component models like Fractal.

%%%Change constraints
The constraints in $\Delta$ are created from the user requests to either install, remove or upgrade a component:
\begin{itemize}
  \item an installation constraint is in the form $a_1 \vee \ldots \vee a_n$, e.g. $a \vee b$ means $a$ or $b$ should be installed
  \item a remove constraint is of the form $\neg a$, e.g. $\neg a$ means $a$ should be removed from the system
  \item an upgrade constraint is of the form $a_1 + \ldots + a_n = 1$, e.g. $a + b = 1$ means exactly one of either $a$ or $b$ is installed.   
\end{itemize} 
The most complex constraint in this set is the upgrade constraint, this is used to state that exactly one component must be installed.

The semantics of these constraints is such that;
\begin{itemize}
  \item an installation constraint $a_1 \vee \ldots \vee a_n$ in $\Delta$ means for any solution $\alpha$ in $solutions(R \cup \Delta)$, $a \in \alpha$ or \ldots or $a_n \in \alpha$ 
  \item a remove constraint  $\neg a$ in $\Delta$ means for any solution $\alpha$ in $solutions(R \cup \Delta)$, $a \not \in \alpha$
  \item an upgrade constraint $a_1 + \ldots + a_n = 1$ in $\Delta$ means for any solution $\alpha$ in $solutions(R \cup \Delta)$, $|\{a_1,\ldots,a_n\} \cap \alpha| = 1$
\end{itemize} 
Here the semantics of the upgrade constraint is expressed as a constraint on the cardinality of the intersection between the solution and the included components.
This cardinality constraint is used to define the request that a component must be replaced by exactly one of a higher version.
How this constraint is used is further described in section \ref{formal.cudf.request}. 

%%%What is the change conflicts with R
A possibility that can occur is that the requested change creates constraints that conflict with the set of component relationships,
i.e. $R \cup \Delta$ is unsatisfiable.
For instance, if there exists a keep constraint $a$ and the request $\neg a$, $R$ and $\Delta$ will be a conflicting set of constraints.   
A practical solution to resolve this issue is to check to see if the constraints a conflicting, and if they are make no change.
That is, if the set $R \cup \Delta$ is unsatisfiable, $E(\alpha, R \cup \Delta,rank) = \alpha$.

\subsection{Component System Evolution is NP-Complete}
Finding a solution that satisfies all relationship and request constraints is shown to be NP-Complete through reduction to a Boolean Satisfiability (SAT) problem,
and not belonging to a class of simple SAT problems given in Schaefer's dichotomy theorem \citep{Schaefer1978}.
This is not the first proof that this problem is NP-Complete, as presented in \citep{edos2005report} it is shown to be reducible to 3-SAT. 
Though it may be the first through using Schaefer's dichotomy theorem, which may be found to be more intuitive than reduction to 3-SAT.

SAT problems where the initial problem given the class NP-Complete in \citep{cook1971}.
This class of problem is described as being able to verify a solution quickly, but have no efficient way to find a solution initially.
To show that this problem is NP-Complete, the first step is to reduce the problem into SAT problem represented by a Boolean equation in Conjunctive Normal Form (CNF).
CNF is a conjunction of clauses, where each clause is a disjunction of literals.

Given all components are represent variables in the problem, the constraints from an evolution problem are reduced to CNF clauses:
\begin{itemize}
  \item keep constraint: $a_1 \vee \ldots \vee a_n$ is directly reduced to a single clause in CNF
  \item dependency constraint: $a \rightarrow c_1 \vee \ldots \vee c_n$ can be reduced to a CNF as a clause $\neg a \vee c_1 \vee \ldots \vee c_n$
  \item conflict constraint: $a \rightarrow \neg c$ can be represented in CNF as a clause $\neg a \vee \neg c$
  \item installation constraint: $a_1 \vee \ldots \vee a_n$ is directly reduced to a single clause in CNF
  \item remove constraint: $\neg a$ is directly representable as a CNF clause
\end{itemize}

The upgrade constraint requires multiple CNF clauses to create a logically equivalent statement.
An upgrade constraint $a_1 + \ldots + a_n = 1$ states one component of $a_1$,\ldots,$a_n$ must be installed, but no two of them can be installed.
This can be created using a CNF clause $a_1 \vee \ldots \vee a_n$ with a set of clauses $\neg a_i \vee \neg a_j$ where where $i$ and $j$ are from $1$ to $n$, $i \neq j$ and $i < j$.
For example, the upgrade constraint $a_1 + a_2 + a_3 = 1$ is translated into the four CNF constraints $a_1 \vee a_2 \vee a_3$, $\neg a_1 \vee \neg a_2$, $\neg a_1 \vee \neg a_3$, and $\neg a_2 \vee \neg a_3$.
The amount of CNF clauses grows quadratically with the size of the upgrade constraint. 

All clauses are combined through $\wedge$ to form a complete CNF formula which represents the SAT problem.

There are trivial SAT problems that can be solved easily.
To show that the evolution problem is not a trivial Schaefer's dichotomy theorem \citep{Schaefer1978} is used.
According to this theorem, a SAT problem represented in CNF is not NP-Complete iff it is in one of six classes.
These classes are:
\begin{enumerate}
  \item the problem is solvable by assigning each variable false
  \item the problem is solvable by assigning each variable true
  \item every clause has at most one negated variable (Horn clause)
  \item every clause has at most one unnegated variable (dual-Horn clause)
  \item every clause has two literals (2-SAT problem)
  \item all relations are equivalent to a conjunction of affine formulae (i.e. $x_1 \oplus \ldots \oplus x_n = true$ or $x_1 \oplus \ldots \oplus x_n = false$)
\end{enumerate} 

An evolution problem is not in the first or second classes as a problem could contain the clauses $\neg a$ and $b$, 
where both clauses would not be satisfied if both variables assigned true, or false. 

The third and fourth classes state that the problem can either be represented by a set of Horn or a set of dual-Horn clauses.
Such problems are known to be solvable in linear time \citep{dowling1984linear}.
An evolution problem can be defined with the conflict and dependency clauses $\neg a \vee \neg c$ and $\neg a \vee c_1 \vee \ldots \vee c_n$. 
As one is a dual-Horn clause and the other a Horn clause, an evolution problem does not fit into either the third or fourth class.

The fifth class states that the CNF problem cannot be represented as a series of clauses with only two literals,
such a problem has been shown to be solvable in linear time \citep{aspvall1979linear}.

The sixth class states that for this problem to be NP-Complete it must not be representable as a linear equation over a two element field $\{0,1\}$
That is, the CNF formula can be represented as a conjunction of clauses using the XOR ($\oplus$) operator.
 
The evolutionary step problem can be shown to be in neither the fifth or sixth classes 
through mapping to an equivalent problem called ``exactly one in three'' presented in \citep{Schaefer1978} as problem ``NP1''.
This problem describes a series of clauses that result in solutions where only one of three components can be selected. 
This problem can is defined as an upgrade constraint $a_1 + a_2 + a_3 = 1$,  
with the translated CNF clauses $a_1 \vee a_2 \vee a_3$, $\neg a_1 \vee \neg a_2$, $\neg a_1 \vee \neg a_3$, and $\neg a_2 \vee \neg a_3$.
This problem is shown to not belong to any of the above classes in lemmas 3.1A, 3.1B and 3.1W in \citep{Schaefer1978}.

%%%This problem may be in fact P if it can exist to one of these classes
Finding a solution to an evolutionary problem is then is NP-Complete. 

\subsection{Component System Evolution is NP-Hard}
As noted by \citep{Berre2008}, this problem is often under constrained, creating many possible component systems that satisfy all constraints.
Also noted, is the fact that some of these solutions are not as ``good'' as others.
Finding an optimal solution by maximising the $rank$ function over the set of possible solutions of an evolution problem is NP-Hard.
This can be seen as the problem to find a solution is NP-Complete, and when the system is found it is difficult to determine whether it is the optimal solution.
This means, once a solution is found that satisfies all constraints, it is impossible to say that this solution is optimal without further steps. 

This NP-Hard class of problem is notably intractable to solve, and will impact any algorithm designed to find an optimal system.
The attempts to mitigate this complexity are discussed in chapter \ref{implementation}.

\subsection{Generational Component System Evolution}
\label{formal.evo}
The atomic action is component system evolution is changing one system to the next through the evolutionary step function.
Each change creates a new generation of the system, this is an analogy to a generation of a biological organism.
Over time the changes to the system may make each generation resemble less and less what the system once was.
This process is the evolution of a component system from the perspective seen in this research. 

%%%This process depends on time
This process can occur over large periods of time, over which the environment of components changes.
Over time, newer component versions and new components are developed.
This means that any given time the set of components and therefore the set of component relationships change.
Therefore, the set of components at time $t$ is denoted $\mathbb{C}_t$, and the set of component relationships at time $t$ is denoted $R_t$.

%%%The requests should be aggregated into one request, if there is a conflict then newer requests should be prioritised
Each change alters the system, but some parts of the system should remain static.
The requested changes to the system should not be able to be undone in subsequent evolutions.
That is, if a user selects to install a text-editor one change, the next change should not allow it to be removed.  
The simple solution to this is to aggregate all previous requests into one set of constraints;
Given a series of evolutionary changes denoted as the tuple $\langle \Delta_1, \ldots, \Delta_i \rangle$ in order from least to most recent,
the constraints for the request would be the $\Delta_1 \cup \ldots \cup \Delta_i$.
However, requests can conflict, e.g. a component is requested to be installed, and later requested to be removed.
As a more recent request is of higher importance than an older request, a process of finding a non-conflicting set of request constraints can be defined.
Therefore: given a series of requests $\langle \Delta_1, \ldots, \Delta_i \rangle$ in order from least to most recent,
the set of request constraints is defined as $\Delta_G = [\Delta_n \mid n \in \{1, \ldots , i\} \mbox{ and } \Delta_n \cup \ldots \cup \Delta_i \mbox{ is satisfiable}]$.
That is, $\Delta_G$ is the subset of request constraints that includes all constraints that do not conflict with a more recent constraint.

%%%This process is then defined as
Given the tuple of evolutionary changes denoted as $\langle \Delta_1, \ldots, \Delta_n \rangle$
which occur at times  $\langle t_1, \ldots, t_n \rangle$.
A generation is defined as $G_i = E(G_{i-1},R_{t_i} \cup \Delta_i,rank)$ where $i$ is an integer between $1$ and $n$.
The initial generation of this process, $G_0$, is the starting point that could either be an system with no components, or a system that is a pre-defined configuration of components.

%%%This makes a sometimes counter intuitive complexity
This process of component system evolution can be counter-intuitive and complex, as the optimal solution for an evolutionary step may not be optimal over generations.
For instance, given the $rank$ function that tries to minimise the number of components altered (the symmetric difference between the solutions), i.e. $rank(\alpha,\beta) = |\alpha \Delta \beta|$,
an initial system $G_0 = \{\}$, a series of user requests $\langle \{a\}, \{d\}\rangle$, 
and a set of constraints (time invariant) $R = \{a \rightarrow b^1 \vee b^2, b^1 \rightarrow \neg b^2, b^2 \rightarrow c, d \rightarrow b^2\}$;
$G_1 = \{a,b^1\}$ where $rank(G_0,G_1) = 2$, and $G_2 = \{a,b^2,c,d\}$ where $rank(G_1,G_2) = 4$.
The total change between generations by minimising change using rank is then $6$, where in the first evolution $a$ and $b^1$ are added, 
and in the second evolution $b^1$ is removed and $b^2$, $c$ and $d$ are added.

This is not an optimal solution when looking at the problem in generational perspective.
A better evolution of this system would have been $G_1 = \{a,b^2,c\}$ then $G_2 = \{a,b^2,c,d\}$.
This would change only a total or $4$ components as opposed to $6$.
Therefore, although the individual evolution $rank$ function is intuitive, the overall result is not optimal.

This counter-intuitive and complex behaviour of component system evolution requires further study.
This is one of the reasons for this being the focus of this research. 

\subsubsection{Belief Revision}
This formalism of generational evolution is similar to the formal logic of belief revision \citep{alchourron1985logic}.
This logic deals with the process in which a set of beliefs can be revised when confronted with new information.
The complexity of belief revision comes from the many ways in which a set of beliefs can be revised when necessary.
For instance, you see a flying black object, you know that birds fly so you infer that it is a bird.
An expert in flying things then tells you that it is a bat; given this new information your previous beliefs require some revision.
How this revision occurs can be a complex task, as previously held beliefs must be questioned; for instance, is the object still black?

The Alchourrón, G\"ardenfors, and Makinson (AGM) \citep{alchourron1985logic} postulates for belief revision give a set of eight properties 
that a such a revision operator needs to satisfy in order to be considered \textit{rational}.
These postulates (not enumerated here) were rephrased for propositional languages by \citep{katsuno1991propositional}. 
Given a set of propositional formula $Y$ representing the belief set, and a single formula $A$ representing new information, the revision of $Y$ by $A$, denoted by $Y \circ A$.
This should have these properties:

\begin{itemize}
  \item (KM1) \textit{ $Y \circ A$  implies $A$}
  \item (KM2) \textit{ If $Y \wedge A$  is satisfiable, then $Y \circ A \equiv Y \wedge A$}
  \item (KM3) \textit{ If $A$ is satisfiable, then $Y \circ A$  is also satisfiable}
  \item (KM4) \textit{ If $Y_1 \equiv Y_2$ and $A_1 \equiv A_2$, then $Y_1 \circ A_1 \equiv Y_2 \circ A_2$}
  \item (KM5) \textit{ $(Y \circ A) \wedge B$  implies $Y \circ (A \wedge B)$}
  \item (KM6) \textit{ If $(Y \circ A) \wedge B$ is satisfiable, then $Y \circ (A \wedge B)$ implies $(Y \circ A) \wedge B$}
\end{itemize} 

The first four KM postulates are equivalent to the first six AGM postulates, describing the basic nature of revision;
new information is always included in the new beliefs (KM1); if the new information does not conflict with old information the revision is equivalent to conjunction (KM2);
if the new information is satisfiable then the revised beliefs should be satisfiable (KM3); given equal scenarios the results are equal (KM4).

The last two KM postulates are equivalent to the last two AGM postulates, which describe the intended minimal change of revision.
That is, revision should only change a minimal set of beliefs given new information is conflicting.
Through weakening (KM6) to two more postulates (KM7) and (KM8), \citep{katsuno1991propositional} further define the revisions minimal change.

\begin{itemize}
  \item (KM7) \textit{ $Y \circ A_1$  implies $A_2$ and $Y \circ A_2$ implies $A_1$ then $Y \circ A_1$ is equivalent to $Y \circ A_2$}
  \item (KM8) \textit{ $(Y \circ A_1) \wedge (Y \circ A_2)$ implies $A$}
\end{itemize}

\citep{katsuno1991propositional} go on to describe a model theoretic characterisation of minimal change; 
given the set of all models $M$, a function is defined that assigns to a set of formula $Y$ a pre-order $\leq_{Y}$ over $M$,
where the strict order is defined as $m <_Y m'$ if and only if $m \leq_Y m'$ and $m' \not \leq_Y m$. 
This assignment is described as \textit{faithful} if three conditions hold:
\begin{enumerate}
  \item If $m,m' \in Mod(Y)$, then $m <_Y m'$ does not hold
  \item If $m \in Mod(Y)$ and $m' \not\in Mod(Y)$, then $m <_Y m'$ holds
  \item If $Y \equiv Z$, then $\leq_Y = \leq_Z$  
\end{enumerate}

That is, a model of $Y$ cannot be strictly less than any other model of $Y$ and must be strictly less than all non-models of $Y$.

Katsuno and Mendelzon then use this assignment to define minimality and a revision operator; 
let $J$ be a subset of $M$, 
a model $m$ is minimal in $J$ with respect to $\leq_{Y}$ if $m \in J$ and there is no $m' \in J$ such that $m' <_Y m$. 
The function $Min(J,\leq_{Y}) = \{ m \mid m$ is minimal in $J$ with respect to $\leq_{Y} \}$.
A revision operator $\circ$ will satisfy the postulates (KM1)-(KM5) if and only if
their exists a faithful assignment that maps each set of propositional formula $Y$ to a pre-order $\leq_{Y}$
such that $Mod(Y \circ A) = Min(Mod(A),\leq_{Y})$.
Katsuno and Mendelzon show that (KM6) will also be satisfied iff $\leq_{Y}$ is a total order,
and (KM7) and (KM8) will also be satisfied iff $\leq_{Y}$ is a partial order.

\paragraph{Component System Evolution Mapping}
This propositional belief revision can be used to describe component system evolution, it proposes a formal basis to give component system evolution ``rational'' properties.
However, there are incompatibilities with this mapping, significantly this logic's dependence on minimal change.

%%%Define the mapping
The set of beliefs, $Y$, defines the propositional formulae whose model is the component system,
and the new information, $A$, is the propositional formulae that are requested change to the system.
The variables in these formula represent the components, and a model is represented by a set, where if a variable is in a set iff it is assigned $true$, 
and a variable is not in the set iff it is assigned $false$. 
Then set $Y$ is the set of formulae that is ``believed" to create a component system best suited for the user.
The formula $A$ defines a change to the beliefs of what is best for the user, which may require the component system to be revised.

%%%Discuss the mapping of the function to the revision operator
The component relationships are facts in this logic, and not beliefs; they are axioms that are defined as integrity constraints by \citep{katsuno1991propositional}.
The revision operator is then denoted with respect to the component relationships $R$ as $\circ_R$.
This revision operator $\circ_R$ is mapped to the evolutionary step function $E$;
given the evolutionary function $E(\alpha,R \cup \Delta,rank) = X_1$, $Mod(Y) = \{\alpha\}$ and $Mod(Y \circ_{R} \Delta) = \{X_1\}$.
This restricts the possible models of $Y$ and the revised models to a singleton sets of $\{X\}$ and $\{X_1\}$,
as there can only exist a single component system at a time.

%%%What does this mapping give us, a foundation
An order $\leq_{Y}$ that holds to the properties stated previously must be defined in order to consider this revision operator ``rational''.
This property, that is the basis of belief revision operators gives component system evolution a foundation.
It states that the changes that are made to a component system are reasonable with respect to the beliefs that it is satisfiable for the user.
The benefit of this mapping would provide evolution with a set of revision operators already defined, and another area of research to contribute to.

%%%However, this mapping is incompatible with our definition.
Although this mapping may provide some benefits to component system evolution, their are fundamental differences which make it incompatible.
The optimisation function $rank$ with is analogous to the order $\leq_{Y}$.
They both describe the measures of optimality, however $rank$ can be static, measure the optimality of a system separate from a previous system,
where $\leq_Y$ is only dynamic, measuring the change from previous to new system.
This difference creates a incompatibility, given the constraint on $\leq_Y$ which requires no change if necessary,
and $rank$ which can make changes which may not be minimal.
For example, if a system is requested to install a component that is already installed, a belief revision operator will never change the system,
however the evolution step function may identify there exists a newer version and attempt to update the component.

%%%Therefore it is not used
This fundamental difference excludes the use of belief revision as the basis of component system evolution formalisation.
Although an extension of belief revision may be possible to accurately describe component system evolution, 
the necessary changes will remove core attributes of belief revision, making it an unreasonable mapping.
This area of belief revision has informed and inspired the research into component system evolution.

\section{Multi-Criteria Component System Evolution}
\label{formal.opt}
%%%The formal definition of how to evolve a component system is complicated because it is a multicriteria problem
Any requested evolution of a component system can have many different possible resulting systems \citep{leBerre2010}.
This is because the problem is generally under-constrained \citep{Berre2008}, allowing multiple systems to satisfy user request and component relationship constraints.
The function $rank$, its range, order and properties have so far been left largely undefined. 
In this section this function $rank$ is defined as a multi-criteria optimisation problem where each criteria is lexicographically composed.

%%%Why is it multicriteira
The evolution of a component system is a mutli-criteria optimisation problem \citep{Berre2008}.
The necessity of using multiple criteria can be seen in the examples of current CDR application criteria presented in \ref{background.models},
where no current examples of CDR implementation used only one criterion to select an optimal system.
Eclipse P2 provides an example where more than four different criteria create the function that selects their optimal system.

%%%Why is it lexicographically composed
Using a lexicographical order to compose criteria, is an intuitive way of ordering solutions.
A lexicographical order states that one criterion is infinitely more important than the next criterion.
Such an ordering has been used in the Mancoosi International Solver competition to compare solvers, and in the prototype solver MPM presented in \citep{abate2011}.

%%%Information from differnet loactions and meta data can be used to define the criteria.
Many different criteria can be created to be used in such a problem.
Criteria can be defined from current solvers like Eclipse P2's criteria to minimise the age of the installed components.
Information from component meta-data, component contracts \citep{Watkins1999}, repositories \citep{Guo2000}, 
composition testing \citep{XuejieZhang2008} and user preferences could be used to define criteria.
Additional criteria, such as size, reliability or licence, may change a systems' desirability, 
therefore during evolution the optimisation of such criteria may return better solution.

In this section the formal definition of the $rank$ function is given such that it allows multiple criteria composed with a lexicographic order.

\subsection{Multi-criteria Optimisation}
%%%Combining criteira is a challenge because criteria have different domains and orders, some have partial orders, arbitrary rankings, criterion orderings.
Optimising multiple criteria proposes some challenges; firstly criteria may have different domains and orders, 
e.g., minimising the size in bytes while maximising percentages of reliability. 
Some criteria may have partial orders where two solutions can be incomparable,
e.g., one licence may not be better or worse than another.
Criteria may have arbitrary rankings, 
e.g., preferences for licences can differ significantly between users.
A criterion could also be more important than another, 
e.g., correct functionality of a system will always be more important than its size.
All this must be considered when formally defining the $rank$ function.

%%%A naive solution is to map all criteria to real numbers, then aggregate them through addition multiplication with weights.
A naive way to create a $rank$ function is map all criteria to a function that returns a real number.
Then by aggregating these numbers through addition or multiplication (possibly with weights) a single $rank$ function to be minimised or maximised is defined. 

%%%This has draw backs, some criteria are infinitly more important, it is not intuitive for users to weight.
This method has some drawbacks; information is lost in the conversion to real numbers, like the reason why a specific system was selected over another.
The relationships between criteria are also difficult to define, as getting an intuitive system order requires altering weights which makes the function complicated to maintain.
This leads to the problem that assigning preferences to criteria with arbitrary weights is not intuitive,
e.g., stating ``size is $.25$ more important than vendor'' does not convey meaningful information about the weighting decision, or its impact.

%%%We approach this problem formally using orders over partially ordered sets, where any sub set is bounded, this is a complete lattice.
The formal approach to solve this problem is to use orders over sets, 
where each criterion is a set ($A$) with an order ($\leq$).
Each criterion is then a partially ordered set (the order must be reflexive, antisymmetric and transitive).
Furthermore, it is requires that any set of elements in a criterion must be bounded, 
i.e. have a least upper bound and a greatest lower bound.
A complete lattices satisfies these requirements, therefore is used as the representation. 

%%%these complete lattice criteria using the product and lexicographic orders.
These complete lattices are able to be composed using a lexicographic order with the result being a complete lattice.
This order can then be used to compose multiple criteria together without the need for arbitrary weights.

%%%This framework can then be used to describe and discuss the multicritera problem of CDR.
This framework defines criteria as a ranking system which includes the $rank$ function over a complete lattice.
The $rank$ function measures a solutions as an element in a complete lattice. 
The complete lattice gives an order to the solutions based on their ranking.
By combining these criteria (ranking systems and complete lattices) multi-criteria problems can be composed.

\subsection{Complete Lattice}
%%%Complete Lattices have been used in other optimisation frameworks.
Complete lattices are an effective abstraction to represent rankings,
and have been used before when describing such criteria \citep{Bistarelli1997,Fernandez}.
They can represent problems that involve partial orders, and be combined into new lattices using various orders.

%%%The formal definition for comlpete lattices is a partially ordered set where all subsets have a unique least upper bound and unique greatest lower bound
A complete lattice is a partially ordered set where all subsets have a unique least upper bound and unique greatest lower bound.
Formally this is defined:
\begin{defs}
A complete lattice is a pair $L = \langle A, \leq \rangle$ where $A$ is a non empty set 
and $\leq \subseteq A \times A$ is a relation such that:
\begin{itemize}
  \item $\leq$ is a partial order
  \item for all subsets of $A$ there exists a unique least upper bound (join or $\vee$) and a unique greatest lower bound (meet or $\wedge$)
\end{itemize}
\end{defs}

%%%The domiain of the complete lattice represents the value domain of the criteria.
The domain of the complete lattice ($A$) defines the value space (e.g., probability, cost, \ldots) 
that is used to rank solutions. 
The core attribute of a complete lattice is that all subsets of the lattice have both a unique least upper bound (join or $\vee$) 
and a unique greatest lower bound (meet or $\wedge$).
Using these operators the greatest ($1$) and least ($0$) elements can be defined as
the join of the entire domain ($\bigvee A = 1$) and the meet of the domain ($\bigwedge A = 0$).

%%%We define a ranking system and function, which returns a value for the complete lattice domain.
An optimal solution can now be defined through a ranking system with respect to complete lattices.
%%%A ranking system is a lattice a finite domain of variables, and their assignment domain
\begin{defs}
Consider a complete lattice $L = \langle A, \leq \rangle$; 
a ranking system is defined over this lattice as a triple $RS = \langle L, D, V \rangle$, 
where $V$ is a finite set of variables and $D$ is their finite domain.
\end{defs}

These domains can be latter defined given the specific problem of component evolution that is being focused on.

%%%A solution (system) is a mapping of variables to the domain
\begin{defs}
A solution is a variable binding $\gamma: V \rightarrow D$, a mapping of each variable to an element in the domain,
and $\Gamma$ is the set of all solutions.
\end{defs}

This definition of solution does not take into account a solutions rank or order, therefore a solution could be the worst possible solution.
%%%The ranking function, takes two solutions, and returns the distance between them 
\begin{defs}
Consider a complete lattice $L = \langle A, \leq \rangle$ and a ranking system $RS = \langle L, D, V \rangle$.
A ranking function ($rank$) returns a metric of the current solution compared to a new solution to elements from $A$,
$rank: \Gamma \times \Gamma \rightarrow A$.
\end{defs}

%%%The set of optimal solutions is then the set of solutions where there are no better solutions
\begin{defs}
Consider a complete lattice $L = \langle A, \leq \rangle$, a ranking system $RS = \langle L, D, V \rangle$, a previous solution $\gamma$ and a ranking function $rank$.
The set of optimal solutions ($OSol \subseteq \Gamma$) is the set of solutions where there is no other solution whose rank is better,
such that $OSol = \{ s \in \Gamma : \nexists s' \mbox{ such that } rank(\gamma,s) < rank(\gamma,s')\}$
\end{defs}

%%%The set of optimial solutions may still be undesirable, as it is only solutions that are available
The set of optimal solutions only includes the highest ranked solutions,
as with the definition of solutions, these optimal solutions could be undesirable.
For instance, given a problem which is ranked with either $Correct$ or $Incorrect$, 
the optimal solution could be $Incorrect$ if there exists no solutions that are $Correct$. 

\subsection{Composition of Complete Lattices}
\label{sec:composition}
As a complete lattice with a ranking system is the representation of a criterion,
the composition of criteria is the way of expressing their relationships to one another. 
The composition operator in this framework is defined as using the lexicographic order.

It is shown here that the lexicographical composition of complete lattices will result in a complete lattice,
this enables any composition of criteria to remain within our framework.
This is proven by deriving the join (unique least upper bound) and meet (unique greatest lower bound) operations,
and showing there exists a least element ($0$) within the lattice \citep{davey1990introduction}. 

The ranking systems are defined to be composed with the lexicographic ordering:
\begin{defs}
\label{def:lex_order}
Consider two complete lattices $L_1 = \langle A_1, \leq_1 \rangle$ and $L_2 = \langle A_2, \leq_2 \rangle$;
$L_1 \odot L_2$ creates a lexicographical composition  $L_L = \langle A_1 \times A_2, \leq_L \rangle$
where $\leq_L$ is a lexicographic order;
$(a,b) \leq_{L} (a',b')$ iff $a <_{1} a'$ or $(a = a'$ and $b \leq_{2} b')$.
\end{defs}

The lexicographical order is trivially reflexive, anti-symmetric and transitive, therefore it is a partial order.
\begin{prop}
The lexicographical composition of two complete lattices is a complete lattice.
\end{prop}
\begin{prof}
Consider two points $(a,b)$ and $(a',b')$; 
the join of $(a,b)$ and $(a',b')$ is $(a',b')$ if $a <_1 a'$,
$(a,b)$ if $a' <_1 a$,
$(a, b \vee b')$ if $a = a'$,
or if $a$ and $a'$ are incomparable ($a||a'$) it is $(a \vee a', 0_2)$
as this is an upper bound, and any other upper bound must be bigger than this.
The meet is defined dually where the meet of $(a,b)$ and $(a',b')$ is $(a',b')$ if $a' <_1 a$,
$(a,b)$ if $a <_1 a'$,
$(a, b \wedge b')$ if $a = a'$,
or if $a$ and $a'$ are incomparable ($a||a'$) it is $(a \wedge a',1_2)$
as this is a lower bound, and any other lower bound must be smaller than this.

This lattice is also complete as its least bound is the least bound of each set $(0_1,0_2)$.
$\Box$\end{prof}

There are two things to note about the lexicographical composition; 
first it does not create a distributive lattice i.e. $\wedge_L$ does not distribute over $\vee_L$.
\begin{prop}
The lexicographic composition does not result in a distributive lattice.
\end{prop}
\begin{prof}
Consider two pairs $(a,b)$ and $(a', b') \in L_1 \odot L_2$ where $a || a'$ and $a = a''$ and $a' || a''$,
then $(a,b) \wedge_{L} ((a', b') \vee_{L} (a'', b'')) = (a,b)$,
where under the same conditions $((a,b) \wedge_{L} (a', b')) \vee_{L} ((a,b) \wedge_{L} (a'', b'')) = (a,b \wedge_2 b'')$.
$\Box$\end{prof}

Secondly, two lattices (not complete lattices) lexicographically combined together may not be a lattice. 
If a lattice was the base representation, this would make it impossible to use a lexicographic composition and be certain that the resulting structure be usable.
This is an important reason for the choice of complete lattices as the structure of representation.
\begin{prop}
The lexicographic composition of two lattices may not result in a lattice.
\end{prop}
\begin{prof}
Suppose a lattice $K$ has a non linear order, and a lattice $L$ has no least bound ($0_L$). 
For two pairs $(a,b)$ and $(a',b)$ in $K \odot L$ have no join if $a$ and $a'$ are incomparable.
This would be defined as $(a,b) \vee (a',b) = (a \vee a',0_L)$, as $0_L$ does not exist this join does not exist.
$\Box$\end{prof}

The final part of this formalism is to show how the remainder of the structures are composed with the lexicographic orders.
The lexicographic composition of the ranking systems is defined as:
\begin{defs}
Consider two complete lattices $L_1 = \langle A_1, \leq_1 \rangle$ and $L_2 = \langle A_2,\leq_2 \rangle$ and
the ranking systems over them $RS_1 = \langle L_1,D,V \rangle $ and $RS_2 = \langle L_2,D,V \rangle$,
with defined ranking functions as $rank_1: \Gamma \times \Gamma \rightarrow A_1 $ and $rank_2: \Gamma \times \Gamma \rightarrow A_2$.
The combination $RS_1 \odot RS_2$  results in the ranking system 
$RS = \langle L_1 \odot L_2, D, V \rangle$, 
and the combination of the ranking functions is 
$rank: \Gamma \times \Gamma \rightarrow A_1 \times A_2$ where $rank(\gamma_1,\gamma_2) = \langle rank_1(\gamma_1,\gamma_2), rank_2(\gamma_1,\gamma_2) \rangle$.
\end{defs}
Note: in this definition, to combine ranking systems they must have the same set of variables and the same domain.

\subsection{Discussion on Formalism}
The point of this exercise is to explore the multi-criteria problem of component system evolution and the $rank$ function that defines optimal solutions.

What is required to create a criterion is: 
\begin{itemize}
  \item a domain $A$ with an order $\leq$ that define a complete lattice $L = \langle A, \leq \rangle$
  \item a set of variables $V$ and domain of those $D$
  \item a $rank$ function that takes two solutions and returns a value from $A$
\end{itemize}, 
In component system evolution the variables are typically the components, i.e. $ V = \mathbb{C}$, and the domain of these is whether they are in the system or not, i.e. $D = \{T,F\}$.
Therefore, the necessary elements to define a criteria in component system evolution are the lattice and the rank function.

It has been shown that if the criteria defined use complete lattices, the lexicographic order can be used and the resulting criteria will remain within this framework. 
This provides a proof that if a criteria is defined within this framework, then using a lexicographic order is ``safe'', and the problem will remain consistent.

In section \ref{formal.mancoosioptimisationformat} the syntax to order criteria is defined, 
in chapter \ref{implementation} the way in which these criteria are optimised is given,
and in chapter \ref{strategies} various criteria are defined that fit in this framework.

\subsection{Semi-ring constraint incompatibility}
%%%Discussion of the related yet incompatible work C-semirings; how they inspired this work but due to lexicographic order we are unable to use it.
A large part of this formalisation was influenced by research into the representation of constraints as a c-semiring \citep{Bistarelli1997}.
This research shows that all instances of their framework are complete lattices, and their $+$ operator coincides with join
and if their $\times$ operator is idempotent, it coincides with meet.
Their examples include fuzzy, weighted, probabilistic and valued constraint problems which can be used in our framework.
In their framework $\times$ must distribute over $+$, this gives a distributive lattice.
Since lexicographic orders may create non-distributive lattices, as shown above, our overall frameworks are incompatible.
This means that the direct use of this research is impossible, though this area remains a source of inspiration.

\section{Common Upgradeability Description Format}
\label{formal.cudf}
%%%The description of the represnation of CUDF is described.
What has been described so far in this chapter is the formal model of component system evolution, with its constraints and it's optimisation.
These semantics require a representation, a language in which to describe and convey such an evolution problem.
In this section, the representation of such a problem is described through using the Common Upgradeability Description Format (CUDF) specification presented by \citep{treinen2009common}.
This specification was previously discussed in section \ref{background.models}, where an example of its meta-data was shown in figure \ref{CUDFmetadata}.

CUDF was defined as an abstract representation the evolution problem of open source software, also described as an upgradeability problem.
It was designed in order to allow the comparison of various implementations designed to solve CUDF problems, 
and to create a generalised solver tof such problems.
In both aspects CUDF has succeeded.
The Mancoosi International Solver Competition (MISC)\footnote{http://www.mancoosi.org/misc/} has been held, both in 2010 and 2011 as well as intermittently, 
to compare various state of the art, and legacy, solvers.
The solver MPM, presented in \citep{abate2011}, was designed and created to solve real world problems represented in CUDF.

%%%In this section\ldots
In this section first the design principles of CUDF are described, this will show the motivations of this definition are aligned to this research.
The syntax of CUDF is then described, this will not cover all aspects of the CUDF specification, for instance the extensive type system of CUDF is left out.
This will however, be enough detail to give a broad understanding of the format.
The defined CUDF syntax is then mapped to our model of the a component system evolution through the constraints that have been defined.
This includes some minor extensions to the presented definition in section \ref{formal.step}.
Finally, the Mancoosi format for specifying optimisation criteria, denoted as MOF, is discussed.

\subsection{CUDF Design}
The Mancoosi organisation is a research project whose area is the improvement to the upgrading of Free and Open Source Software (FOSS) distributions.
This upgrade problem is the same problem defined in this chapter, the evolution of a component system.
Mancoosi looks at a broad area within this domain, and has made many contributions in the area.

One of these contributions was to organise a competition between competing solutions of the evolution problems of FOSS systems.
This was beneficial as it would encourage researchers and practitioners into researching the evolution problem.

An initial problem faced in organising such a competition is a format in which the competition could represent the upgrade problem.
The design of this format would have to follow some design principles to ensure the results would be useful.
These principles are presented in \citep{treinen2009common}, summarised as:

\begin{itemize}
  \item \textbf{Agnostic towards component model details}: 
  The specific component model and the implementation chosen to solve the problem, should be abstracted as to allow many problems and solutions to be used  
  \item \textbf{Stay close to the original problem}: 
  The original problem is still the focus of this research, therefore the format should not abstract so far as to be unrecognisable. 
  By using similar terms and syntax that already exists within the domain, the format will still directly represent the upgrade problem. 
  \item \textbf{Preserve the ability for humans to inspect encoded problems}:
  The analysis and design of a specific problem should be able to be directly accomplished through manual investigation.
  This will allow greater testing and debugging, also enable the direct inspection of the problem by researchers for study.
  \item \textbf{Avoid bias towards specific implementations or techniques}:
  Specific encoding of the problem, e.g. using propositional logic, or constraint programming, may create an advantage or disadvantage for a particular technique or solution.
  Since a goal of this research is to encourage the advancement of this area, the format should strive to be independent from any technique or implementation. 
  \item \textbf{Support legacy tools}:
  The comparison to tools that are already in use to solve such upgrade problems is a necessity when determining if this research is advancing the field.
  Ideally, a legacy or current solution should easily be able to be adapted and used with the format.
  Conversely though, the format should not stop state-of-the-art solutions from being used.
  \item \textbf{Extensible}:
  Although the format will attempt to abstract the common elements of the problem, there may still be necessary component model specific details that require inclusion.
  Also, some details are required for the optimisation of the problem, but which are not relevant to the specification of the format.
  The ability to extend the format is then required.
  \item \textbf{Transactional semantics}:
  The format should have the ability to completely represent a problem as a single unit, that can be passed to an implementation for solution.
  Also, the solution passed back should itself be a single unit, of the same format.
  This ignores aspects of the problem such as install order of the components, though this is outside the scope of this research.
  \item \textbf{Plain Text Format}:
  The use of plain text, as opposed to a binary format, will allow it to be human readable, as well as make it easier to parse and write.
  Although plain text may not be the most efficient way to encode a problem, the overhead required to parse other formats may decrease the interest to enter a competition.
  This also aligns with the morals of the community of FOSS developers, where plain text is the universal information interchange format \citep{raymond2003art}.
\end{itemize}

The result of these design goals is the CUDF specification, presented in \citep{treinen2009common}, and presented in the following sections.

\subsection{CUDF Document}
%%%Here the CUDF document is defined using text and trying to stay away from too many formalisms, just describing concepts to be used later
In this section a brief description of the CUDF format is presented.
Some aspects of CUDF are ignored (e.g. the formal type system) as a complete redefinition of the original specification is not the goal of this section.
Where details are removed, or glossed over a reference will be made as to ensure that misinformation is not conveyed. 

A CUDF document is a single plain text file, that represents all information necessary to define an evolutionary step as defined in section \ref{formal.step}.

This document is separated into three sections, the preamble, the package descriptions, and the request.

\begin{itemize}
  \item \textbf{preamble} stanza: Defines the additional types used in the CUDF document
  \item \textbf{package descriptions} stanzas: typically the bulk of a CUDF document, this defines the set of components (using the FOSS term package)
  \item \textbf{request} stanza: this defines the requested evolutionary change that should be made to the components 
\end{itemize}

This structure is presented in figure \ref{formal:cudfstruct}.

\begin{figure}[htp]
\centering
\begin{tabular}{|c|}
\hline preamble \\ \hline
\hline package description$_{1}$ \\ \hline
\hline package description$_{2}$ \\ \hline
 \multicolumn{1}{c}{\ldots}  \\ 
\hline package description$_{i}$\\ \hline
\hline request\\ \hline
\end{tabular}
\caption{Structure of the CUDF stanzas}
\label{formal:cudfstruct}
\end{figure}

Every stanza begins with a key of their type (\verb+preamble+, \verb+package+, \verb+request+), followed by several lines ending in a empty line.
Each stanza line defines a set of properties using key/value pairs separated by the delimiter ``:``, these are in no defined order.
This structure is presented in figure \ref{formal.cudfproperties}

\begin{figure}[htp] 
\begin{center}
\begin{alltt}
\textit{stanza}: \textit{value}
\textit{key_1}: \textit{value_1}
\ldots
\textit{key_n}: \textit{value_n}

\ldots

\textit{stanza}: \textit{value}
\textit{key_1}: \textit{value_1}
\ldots
\end{alltt}
  \caption[CUDF property structure]{Structure of CUDF properties}
  \label{formal.cudfproperties}
\end{center}
\end{figure}

\subsubsection{Package Description}
The package description stanza starts with the \verb+package+ key followed by the value of package name, a non-empty string.
The only mandatory property of this stanza is defined with the key \verb+version:+ who's value is the version of the package, a positive integer.
The pair $\langle name, version \rangle$ of a package is unique, there can exist at most one package description for a given name and version.
This name and version pair is the atomic unit for the CUDF document. 

Some relevant properties for a package are defined by the keys:
\begin{itemize}
  \item \verb+installed+: this Boolean property states whether the package is installed or not in the system. 
  As the CUDF document describes all packages, installed and not, the set of packages with the property \verb+installed: true+ defines the current component system.
  \item \verb+keep+: this property defines the keep constraints as defined in section \ref{formal.step}
  Some possible values\footnote{The keep property can also be assigned feature or none} are:
	  	\begin{itemize}
	  		\item \verb+version+: keep this particular version of the package installed
	  		\item \verb+package+: keep at least one version of this package installed
		\end{itemize}
  \item \verb+provides+: this is a list of names of features or services that this package provides separated by the delimiter ``,''.
  e.g. \verb+provides: a, b, c+ means this package provides the features \verb+a+, \verb+b+ and \verb+c+.
  Each feature name can be accompanied by a version, to state what particular version is provided, e.g. \verb+a=10+ means feature \verb+a+ version \verb+10+ is provided.
  When no version is specified for a feature, it is defined as all versions are provided.
  \item \verb+depends+: this is a list of lists of \textbf{package formulae}, first separated by the delimiter ``,'' then delimiter ``|''.
  The list represents a conjunction of disjunctions (conjunctive normal form), with each formulae defining a set of packages.
  A package is defined using a name of either a package or feature $n$ and optionally an operator and version of the form  $n = v$, $n$ != $v$, $n > v$, $n < v$, $n >= v$, or $n <= v$.
  For example, \verb+depends: a , b | c < 10+ means the package depends on a packages (or features) ``\verb+a+ AND (\verb+b+ OR \verb+c+ less than version \verb+10+)''.  
  \item \verb+conflicts+: is a list of \textbf{package formulae} as defined above separated by the delimiter ``,''.
  For example, \verb+conflicts: a , c > 2+ means this package conflicts with all packages (or features) with the name \verb+a+ AND \verb+c+ greater than the version \verb+2+
\end{itemize}

\subsubsection{Preamble}
The preamble stanza starts with the key \verb+preamble:+, no value is necessary for this key.
The main function of this stanza is to provide the description of addition properties and their types, that can be added to the package descriptions.
This is described under the key \verb+property+ where the value is a list of properties defining their name, type and optionally a default value separated by the delimiter ``,''.
Each additional property of name $n$ and type $t$ and optionally a default value is a pair or triple separated first by ``:'' then ``='' where the default is wrapped in ``['' and ``]''.

For example, \verb+property: size: int, bugs: int = [0]+ defines the integer property of \verb+size+ and the integer property of \verb+bugs+ with the default value \verb+0+.
Given this preamble, package descriptions can now use these properties as shown in figure \ref{formal.cudfextensionexample}.

\begin{figure}[htp] 
\begin{center}
\begin{alltt}
preamble:
property: size: int, bugs: int = [0]

package: textEditor
version: 1
bugs: 10
size: 2
depends: spellCheckerService

\ldots

\end{alltt}
  \caption[Example of Extendable CUDF syntax]{Example of Extendable CUDF syntax}
  \label{formal.cudfextensionexample}
\end{center}
\end{figure}

\subsubsection{Request}
\label{formal.cudfdes.request}
The request stanza starts with the \verb+request:+ key, no value is required for this key.
This stanza contains three properties that define the request to change the system,
each is a list of \textbf{package formulae} separated by the delimiter ``,'' such that:
\begin{itemize}
  \item \verb+install+: is a request to install a set of packages into the system,
  e.g. \verb+install: a, b >= 2+ means install component \verb+a+ and component \verb+b+ of version two or greater.
  \item \verb+remove+: is a request to remove a set of packages from the system 
  e.g. \verb+remove: a , b = 2+ means remove all components with name \verb+a+ and component \verb+b+ of version two.
  \item \verb+upgrade+: is a request to remove all versions of a package and install greater than or equal versions of the package,
  e.g. \verb+upgrade: a+ means to remove all packages of name \verb+a+ and install one package of equal or greater versions to that of the maximum version of \verb+a+ currently installed. 
\end{itemize}

%%%Installation of multiple components
CUDF as a specification mostly resembles the Debian package format, described in section \ref{background.models}.
A significant difference between these two specifications is that the CUDF model does not explicitly state that only one version of a package can be installed.
This is a practical decision as other component models, like Red Hat Package manager and OSGi, allow the installation of multiple versions of the same component.
Although models exist that allow multiple versions of a package to be installed, having multiple versions installed is seen as less optimal as it replicates functionality. 
This is then left up to the optimisation when finding a solution to try to identify solutions with only one version installed per component.

%%%Upgrading with multiple packages
A request to upgrade a component is significantly more complicated than the other requests.
This is partially due to CUDF allowing having multiple versions of the same component installed.
If a package is requested to be upgraded and there are multiple versions of that package installed,
then all but the highest version must be removed, and only one version can remain in the system.
For example, if a system has $a_1$ and $a_2$ installed and it is requested to upgrade $a$,
then $a_1$ must be removed, and either $a_2$ can remain, or $a_2$ can be removed and a higher version of $a$ can be installed.

Given these semantics, requesting to upgrade a component can actually do nothing to the system
For example, is $a$ is requested to be upgraded and the only version of $a$ installed is $a_1$, then the system does not have to change to satisfy the request.
This means that the intuitive request to upgrade a system is left to the optimisation function.
That is, to get newer versions of component installed it is necessary to define an appropriate $rank$ function.

\subsection{CUDF Specification}
In this section, the model presented in section \ref{formal.step} is mapped to this CUDF specification.
The package stanzas are used to define to the current component system $\alpha$ and the component relationship constraints $R$, 
while the request stanza is used to define the user request constraints $\Delta$. 

The first definition is that of the CUDF document, which is made up of three sections; the preamble stanza, a set of package description stanzas, and a request stanza:
\begin{defs}
A CUDF document then is described as $CUDF = \langle preamble, PD, request \rangle$ where $PD$ is the set of package description stanzas.
\end{defs} 
Each stanza is made of a set of properties, where each property is a tuple of key/value, i.e. $stanza = \{\langle $\verb+key+, \verb+value+$\rangle\}$.
This syntax is described in figures \ref{formal:cudfstruct} and \ref{formal.cudfproperties}.

The function $property$ is defined such that it takes a stanza and key and returns a value,
i.e. $property: STANZA \times key \rightarrow value$ such that given a stanza $s$ and key \verb+key+,
$property(s,$\verb+key+$) = $ \verb+value+ where $\langle$\verb+key+, \verb+value+$ \rangle \in s$.

If the key does not exist in the stanza, the default value of the property is returned.
For instance, the default value in a package description stanza for the \verb+installed+ property is defined as \verb+false+;
therefore, if the key \verb+installed+ is not defined in a package description stanza $pd$, then $property(pd,$\verb+installed+$)$ equals \verb+false+.
Further, if a property does not have a defined default value, then $\emptyset$ is returned.

\subsubsection{Preamble}
%%%Description of a basic preamble, as much of the specification is not used
The first stanza of any CUDF document is the $preamble$.
The core goal of this is to define additional properties (and their default values) that can be used to describe a component.
This property definition is accomplished through using an extensively defined type system in CUDF, and has a complete and complicated specification found in \citep{treinen2009common}.
However, as much of this specification is not used in this research only a basic syntax and semantics will be described.
The syntax of the preamble \verb+property+ value is defined in the BNF grammar as \verb+<properties>+ in figure \ref{formal.cudfpropertysyntax}.

\begin{figure}[htp] 
\begin{center}
\begin{alltt}
<properties> ::= <property> ["," <property>]*
<property> :: = <pname> ":" <type> ("=" "["<defaultvalue>"]")?
<type> ::= "int"
\end{alltt}
  \caption{Preamble property syntax}
  \label{formal.cudfpropertysyntax}
\end{center}
\end{figure}

This syntax defines each property as a name, a type and a default value, i.e. $\langle name, type, default \rangle$, where $name = $ \verb+<pname>+, $type = $ \verb+<type>+,
and the $default =$ \verb+<defaultvalue>+. 
In the full CUDF specification there are more types other than \verb+int+, such as \verb+enum+ and \verb+string+,
some having a different syntax than described here.

\subsubsection{Components}
Each component is defined by a name and version, as described in section \ref{formal.step}.
This information is extracted from the package descriptions in a CUDF document.
The function $pd2c$ takes a package description stanza and returns a component, such that $pd2c(pd) = \langle property(pd, $ \verb+name+ $), property(pd, $ \verb+version+ $) \rangle$.
The set of components, $\mathbb{C}$, equals the set of converted package descriptions, i.e. $\mathbb{C} = [ pd2c(pd) \mid pd \in PD]$.

To refer to a property assigned to a component $a$, of the key \verb+key+, it is written $a$.\verb+key+.
That is, $a$.\verb+key+ $= property(pd, $\verb+key+$)$ where $a = pd2c(pd)$.
For example, the name of a component $a$ can be written as $a$.\verb+name+, its version as $a$.\verb+version+.
A component can still be denoted as $n^v$, where $n$ = $a$.\verb+name+ and $v$ = $a$.\verb+version+.

As described above, 
if a request property does not exist for the component, then the default value of that property is returned, and if no default is defined then $\emptyset$ is returned.

A CUDF document not only describes the set of all components, but the set of components that defines the current system.
The set of components in the current system (denoted as $\alpha$) is defined using the key \verb+installed+,
such that, $c \in \alpha$ iff  $c.$\verb+installed+ equals \verb+true+.
That is, only the components whose property \verb+installed+ is set to \verb+true+, are in the current component system.

\subsubsection{Features}
%%%Features or services
CUDF specifies an additional aspect to component relationships, that of a feature or service.
Each component can provide a set of features, where each feature is represented by a name, and a set of versions.
Unlike a component, which has exactly one version, a component can provide multiple versions of a feature.

A feature is then a pair $(n,V)$ where all features are in the set $F$, $n$ is the name of the feature, and $V$ is a subset of positive integers representing versions, i.e $V \subseteq \mathbb{N}$.
The features provided by a component are defined as the property with the key \verb+provides+, 
whose value follows \verb+<provides>+ from the BNF grammar presented in figure \ref{formal.cudfprovidessyntax}.

\begin{figure}[htp] 
\begin{center}
\begin{alltt}
<provides> ::= <feature> ["," <feature>]*
<feature> :: = <fname> ("=" <ver>)?
\end{alltt}
  \caption[Provides syntax]{CUDF Provides syntax}
  \label{formal.cudfprovidessyntax}
\end{center}
\end{figure}

Each feature represented by \verb+<feature>+ is in the form ``\verb+<fname>+'' or  ``\verb+<fname>+ = \verb+<ver>+'', 
which is mapped to a feature $($\verb+<fname>+$,\mathbb{N})$ or $($\verb+<fname>+$,\{$\verb+<ver>+$\})$ respectivly.
That is, a component provides all versions of a feature if a specific version is not defined, and if a version is defined it provides a singleton set of that version.
 
The list of features defined by \verb+<provides>+, in the form ``\verb+<feature>+$_1$,\ldots,\verb+<feature>+$_n$'', can then be mapped to a set of features.
This property is wrapped with the function $providedFeatures$,
such that given a component $c$, $providedFeatures(c)$ equals the set of features mapped from $c$.\verb+provides+.

\subsubsection{Package formula}
A package formula is a query to retrieve a set of components from a CUDF document.
This formula is the mechanism to define all relationships and requests in the CUDF specification.

Each package formula is syntactically defined as \verb+<pkgf>+ in the BNF grammar in figure \ref{formal.cudfpackageformulasyntax}.
This also defines \verb+<pkgname>+ as the package name, \verb+<ver>+ as the package version, and \verb+<relop>+ as a relational operator expressing the constraint of the query.

\begin{figure}[htp] 
\begin{center}
\begin{alltt}
<pkgf> ::= <pkgname> (<relop> <ver>)?
<relop> ::=  "=" | "!=" | ">=" | ">" | "<=" | "<"
\end{alltt}
  \caption[Package Formulae syntax]{Structure of CUDF package Formulae syntax}
  \label{formal.cudfpackageformulasyntax}
\end{center}
\end{figure}

The syntax of \verb+<relop>+ is parsed to a mathematical relation with the function:  
$\{$ \verb+"="+ $\rightarrow$ $=$, \verb+"!="+ $\rightarrow \not =$, 
\verb+">="+ $\rightarrow$ $\geq$, \verb+">"+ $\rightarrow$ $>$, \verb+"<="+ $\rightarrow$ $\leq$, \verb+"<"+ $\rightarrow$ $<$$\}$.
The package formula is in the form ``\verb+<pkgname>+'' or  ``\verb+<pkgname>+ \verb+<relop>+ \verb+<ver>+'',
given \verb+<relop>+ is mapped to $op$, each form is mapped to a triple $\langle $\verb+<pkgname>+$,0,>\rangle$ or $\langle$\verb+<pkgname>+$,op,$ \verb+<ver>+ $\rangle$ respectively.
That is, each package formula is a triple of name, operation and version.
If \verb+<relop>+ and \verb+<ver>+ are not defined, the operation defaults to greater than version 0.

%%%Find all packages which satisfy the package formula
Package formulae (whose set is denoted as $PF$) can be mapped to a set of components through the function $packages: PF \rightarrow 2^{\mathbb{C}}$,
which takes a package formula and returns all packages that conform to its definition.
This is defined as:
\begin{defs}
Given a set of components $\mathbb{C}$ defined in a CUDF document, and a package formulae $\langle n,v,op\rangle$
$packages(\langle n,v,op\rangle) = [\langle n_c,v_c \rangle \mid \langle n_c,v_c \rangle \in \mathbb{C} \mbox{ and } n_c = n \mbox{ and } v_c \mbox{ op } v]$.
\end{defs}
That is, any component whose name is the same as that in the package formulae and whose version is related through the defined $op$ will be included in the set.

%%%Find all packages who provides a feature which satisfies the package formula
A package formula does not distinguish between components and features, so a package formula is also used to search for components providing a feature.
The function $features: PF \rightarrow 2^{\mathbb{C}}$ takes a package formula and returns a set of components that provide the described feature.
\begin{defs}
Given a set of components $\mathbb{C}$ defined in a CUDF document, and a package formulae $\langle n,v,op\rangle$
$features(\langle n,v,op\rangle)$ equals 
$[c \mid c\in \mathbb{C} \mbox{ and } (n,V) \in providedFeatures(c) \wedge \exists v_f \in V \mbox { such that } v_f \mbox{ op } v ]$.
\end{defs}
That is, given a package formula, 
$features$ returns a set of components that provide a feature where the name of the feature is the name in the package formula 
and there exists a version of that feature that satisfies the relation. 

Give the functions $packages$ and $features$ the resolution of a package formula $pf$ can be described as the function 
\begin{defs}
$packagesThatSatisfy(pf) = packages(pf) \cup features(pf)$.
\end{defs}
That is, $packagesThatSatisfy$ takes a package formula and returns a set of packages that either directly satisfy it, or that provide a feature that satisfy the it.

\subsubsection{Relationships}
Given the function $packagesThatSatisfy$, the CUDF document can be mapped to the relationship constraints described in section \ref{formal.step}.

There are three constraints:
\begin{itemize}
  \item keep constraint: derived from the property \verb+keep+ of a package descriptions, only included if the property \verb+installed+ is true.
  \item dependency constraint: derived from the property \verb+depends+ from all package descriptions in a CUDF document.
  \item conflict constraints: derived from the property \verb+conflicts+ from all package descriptions in a CUDF document.
\end{itemize}

\paragraph{Keep Constraint}
The keep constraint states that a system should maintain either a specific package, or a version of a package in the system.
In the CUDF specification only the keep constraints of installed components are considered.

The function $keeppf$ is defined to take a component and to return a package formula such that can be used to create a keep constraint.
Given a component $\langle n,v \rangle = c$, $keeppf$ is defined such that:
\begin{itemize}
	\item if $c$.\verb+keep+ equals \verb+version+: $keeppf(c) = \langle n, =, v \rangle$
	\item if $c$.\verb+keep+ equals \verb+package+: $keeppf(c) = \langle n, >, 0 \rangle$
\end{itemize}

A keep constraint, of the form $c_1 \vee \ldots \vee c_n$, for a package is then created using the function $keep$,
where $keep(c) = \bigvee packages(keeppf(c))$.
That is, the package formula from $keeppf$ is used to query for a set of packages whose disjunction forms the keep constraint.
This creates a constraint to ensure one of the resulting components to be included in the system.

To create the set of all keep constraints, all installed packages must be mapped to the function $keep$.
Given a set of components $\mathbb{C}$ defined in a CUDF document, 
the set of components $\alpha$ which denotes all installed components, is used to create the set of keep constraints $\bigcup \limits_{c \in \alpha} keep(c)$.

\paragraph{Dependency Constraint}
The dependency constraints of a set of components $\mathbb{C}$ defined in a CUDF document are mapped using the property key \verb+depends+,
whose syntax is defined as \verb+<depends>+ from the BNF grammar presented in figure \ref{formal.cudfdependssyntax}.

\begin{figure}[htp] 
\begin{center}
\begin{alltt}
<depends> ::= <pkgflist> ("," <pkgflist>)*
<pkgflist> ::= <pkgf> ("|" <pkgf>)*
\end{alltt}
  \caption[CUDF Package depends syntax]{Structure of CUDF depends syntax}
  \label{formal.cudfdependssyntax}
\end{center}
\end{figure}

This syntax shows that the depends property is a list of package formula (as defined in figure \ref{formal.cudfpackageformulasyntax}) lists, 
first separated by the delimiter ``,'' then by the delimiter ``|''.
Each package formula list maps to a single dependency constraint, as described in section \ref{formal.step}.

The syntax of a \verb+<pkgflist>+ is in the form ``\verb+<pkgf>+$_1$ | \ldots | \verb+<pkgf>+$_n$'', where \verb+<pkgf>+$_i$ maps to $pf_i$.
Each \verb+<pkgflist>+ then maps to a set of package formulae $pkgflist$ such that $pkgflist = \{pf_1,\ldots, pf_n\}$.

The property \verb+<depends>+ is then of the form ``\verb+<pkgflist>+$_1$ ,\ldots, \verb+<pkgflist>+$_n$'', where \verb+<pkgflist>+$_i$ maps to a set of package formulae $pkgflist_i$. 
The property \verb+<depends>+ is mapped to a set of sets of package formulae $listpkgflist = \{pkgflist_1,\ldots,pkgflist_n\}$.

The function $dependsOn$ is then defined such that it takes a component and a package list to create a single dependency constraint of the form $a \rightarrow c_1 \vee \ldots \vee c_n$,
as defined in section \ref{formal.step}.
Given a component $a$ and a package list $pkgflist$, 
$dependsOn(a,pkgflist)$ equals the constraint $a \rightarrow \bigvee  \bigcup \limits_{pkgf \in pkgflist} packagesThatSatisfy(pkgf)$.
That is, $dependsOn(a,pkgflist)$ is $a$ implying the disjunction of the union of all components that satisfy a contained package formula to create the dependency constraint. 

The function $depends$ is then defined to return a set of all dependency constraints for a component.
Given a component $a$, the set of sets of package formulae mapped from $a$.\verb+depends+ denoted as $listpkgflist$,
$depends(a)$ is defined to equal $\bigcup \limits_{pkgflst \in listpkgflist} dependsOn(a,pkgflst)$.
That is, the set of dependency constraints for a given component is the union of all constraints created from individual \verb+depends+ properties.

Finally, the set of all dependency constraints is defined given the set of all components $\mathbb{C}$ defined in a CUDF document,
such that the set of dependency constraints equals $\bigcup \limits_{c\in \mathbb{C}} depends(a)$.

\paragraph{Conflict Constraint}
The conflict constraints of a given component defines the relationship where it will not be functional with another component in the system.
The syntax of the \verb+conflicts+ property value is defined as \verb+<conflicts>+ and is presented in figure \ref{formal.cudfconflictsyntax}.

\begin{figure}[htp] 
\begin{center}
\begin{alltt}
<conflicts> ::= <pkgf> ("," <pkgf>)*
\end{alltt}
  \caption[CUDF Package conflicts syntax]{Structure of CUDF conflicts syntax}
  \label{formal.cudfconflictsyntax}
\end{center}
\end{figure}

This syntax is the same as defined above in the depends property syntax for \verb+<pkgflist>+ except it uses a different delimiter. 
The mapping is also the same, where the property value is in the form \verb+<pkgf>+$_1$ , \ldots , \verb+<pkgf>+$_n$ and maps to a set of package formulae $conflictPkgF$.

Given a component $a$ and the set $conflictPkgF$ that is mapped from the $a$.\verb+conflicts+;
the function $conflictsWith$ is defined to return a set of conflict constraints where each constraints is in the form $a \rightarrow \neg c$, as defined in section \ref{formal.step}.
This function is defined as, 
$conflictsWith(a) = [a \rightarrow \neg c \mid c \in packagesThatSatisfy(pf) \mbox{ and } pf \in conflictPkgF \mbox { and } c \not = a]$.
That is, a component conflicts with any component that satisfies a package formula defined in its \verb+conflicts+ property,
with the exception that it cannot conflict with itself.
This final caveat of a CUDF conflict is directly taken from the Debian package specification \citep{Barth2005}, 
as it allows a package to declare a conflict with itself and this forces similar packages to be removed if it is installed.  

Finally, given the $\mathbb{C}$ is the set of all components in a CUDF document,
the set of all conflict constraints for a CUDF document is defined as $\bigcup \limits_{c\in \mathbb{C}} conflicts(a)$.

\paragraph{Union}
Given a set of components $\mathbb{C}$, the set of currently installed components $\alpha$, 
the set of all relationship constraints, $R$, is the union of the keep, depends and conflicts constraints defined above.
That is, 
\begin{defs}
$R = \bigcup \limits_{c \in \alpha} keep(c) \cup \bigcup \limits_{c\in \mathbb{C}} depends(a) \cup \bigcup \limits_{c\in \mathbb{C}} conflicts(a)$.
\end{defs}

\subsubsection{Request}
\label{formal.cudf.request}
In a CUDF document there exist exactly one request stanza, which has three optional properties \verb+install+, \verb+remove+ and \verb+update+ respectively.
Each value for these properties has the same syntax, shown in figure \ref{formal.requestssyntax}.

\begin{figure}[htp] 
\begin{center}
\begin{alltt}
<install> ::= <pkgflist>
<remove> ::= <pkgflist>
<update> ::= <pkgflist>
<pkgflist> ::= <pkgf> ("," <pkgf>)*
\end{alltt}
  \caption[CUDF Package conflicts syntax]{Structure of CUDF conflicts syntax}
  \label{formal.requestssyntax}
\end{center}
\end{figure}

The syntax of \verb+<pkgflist>+ is exactly the same defined above for the conflicts property, and can be mapped to the set of package formulae $pkgflist$.
The \verb+install+ property maps to the package formulae set $installpkgflist$; the \verb+remove+ property maps to the package formulae set $removepkgflist$;
the \verb+update+ property maps to the package formulae set  $updatepkgflist$.

\paragraph{Install}
An install constraint is of the form $a_1 \vee \ldots \vee a_n$,
this is defined semantically as $a_1 \in E_{R \cup \Delta}(\alpha)$ or \ldots or $a_n \in E_{R \cup \Delta}(\alpha)$.

The function  $install(pf)$ is defined to take a package formula $pf$ and return one install constraint such that $\bigvee packagesThatSatisfy(pf)$.
Each package formulae in the set $installpkgflist$ creates one install constraint,
therefore the set of all install constraints is defined as $\bigcup \limits_{pf \in installpkgflist} install(pf)$.

\paragraph{Remove}
A remove constraint is of the form $\neg a$,
this is defined semantically as $a \not \in E_{R \cup \Delta}(\alpha)$.

The function $remove(pf)$ is defined to take a package formula $pf$ and returns a set of remove constraints such that $[\neg a \mid  a \in packagesThatSatisfy(pf)]$.
Then the set of remove constraints is the union of all constraints created from the $removepkgflist$ set, i.e. $\bigcup \limits_{pf \in removepkgflist} remove(pf)$.

\paragraph{Upgrade}
%%%This is a difficult to express
The upgrade semantics of CUDF are the most difficult to express, this is because of the complicated relationships it causes as discussed in section \ref{formal.cudfdes.request}.
The upgrade semantics of CUDF state that two constraints must be satisfied for each package formula $pf$ in $updatepkgflist$:
\begin{enumerate}
  \item exactly one package that satisfies $pf$ is in the system
  \item no packages with a lesser version than the highest currently installed component with the name from $pf$ can be included.
\end{enumerate} 

The first upgrade constraint is the cardinality constraint of the form $a_1 + \ldots + a_i = 1$, as described in section \ref{formal.step}.
Given the package formula $pf$, the function $upgrade_1$ is defined to return an upgrade constraint,
such that $upgrade_1(pf) = \bigoplus packagesThatSatisfy(pf) = 1$.
That is, each package that satisfies the package formula is included in the cardinality constraint.

The second type of constraint is of the form $\neg a$, defined as the removal constraint described in section \ref{formal.step}.
To create the required constraints some utility functions $named$ and $maxversion$ are defined.

\begin{defs}
Given the a set of components $\beta$ and the package name $n$ the set of packages in $\beta$ of the name $n$ is returned by the function $named$, such that
$named(\beta,n) = \beta \cap packagesThatSatisfy(\langle n,0,> \rangle)$.
\end{defs} 

\begin{defs}
Given a set of components and a name $n$ the function $maxversion(\beta,n)$ returns the integer $c$.\verb+version+ 
such that $c \in named(\beta,n)$ and $\nexists c' \in named(\beta,n)$ where $c'$.\verb+version+ $> c$.\verb+version+.
\end{defs}
That is, $maxversion(\beta,n)$ returns the highest version of any component with a name $n$.

Given the name $n$ and a set of component $\beta$, the set of components that are below this maximum version of $n$ in $\beta$ is defined as:
$packagesThatSatisfy(\langle n, maxversion(\beta,n), < \rangle)$
So to satisfy the second constraint of the upgrade request to have no package installed with the same name but lesser version that the highest currently installed version,
the function  $upgrade_2$ is defined as:
\begin{defs}
Given the currently installed system $\alpha$ and a package formula $\langle n,v,op \rangle$,
$upgrade_2(\alpha,\langle n,v,op \rangle) = [\neg a \mid a \in packagesThatSatisfy(\langle n, maxversion(\beta,n), < \rangle)]$
\end{defs}
That is, all components of name $n$ that have a lesser version than the highest version currently installed in $\alpha$ cannot be installed in the new system. 

The set of all upgrade constraints is then the union of all constraints created for all package formulae in $updatepkgflist$,
i.e. $\bigcup \limits_{pf \in updatepkgflist} (upgrade_1(pf) \cup upgrade_2(\alpha,pf))$.

\paragraph{Union}
Given a set of components $\mathbb{C}$, the set of currently installed components $\alpha$,
and the sets of package formulae mapped from the request stanza properties \verb+install+, \verb+remove+ and \verb+update+ 
(respectively $installpkgflist$, $removepkgflist$ and $updatepkgflist$);
the set of all change constraints represented as $\Delta$ is the union of the install, remove and update constraints above.
That is, 
\begin{defs}
Given 
\begin{itemize}
  \item $i = \bigcup \limits_{pf \in installpkgflist} install(pf)$
  \item $r = \bigcup \limits_{pf \in removepkgflist} remove(pf)$
  \item $u = \bigcup \limits_{pf \in updatepkgflist} (upgrade_1(pf) \cup upgrade_2(\alpha,pf))$
\end{itemize}
$\Delta =  i \cup r \cup u$
\end{defs}

\subsection{Full Example}
\label{formal.example}
An example of a CUDF document is presented in figure \ref{formal.CUDFEXAMPLE} to illuminate the basic process of mapping a CUDF document to a set of constraints as expressed in section \ref{formal.step}.

\begin{figure}[htp] 
\begin{center}
\begin{alltt}
preamble:
property: size: int = [0]

package: syslib
version: 1
installed: true
conflicts: syslib

package: syslib
version: 2
conflicts: syslib

package: textEditor
version: 1
depends: spellChecker | spellCheckerService, syslib > 1

package spellChecker
version: 1
size: 1

package: tpspeller
version: 1
provides: spellCheckerService
size: 2

request:
install:textEditor

\end{alltt}
  \caption[CUDF Example]{Example of a CUDF request}
  \label{formal.CUDFEXAMPLE}
\end{center}
\end{figure} 

This example can be mapped to a set of components $\mathbb{C}$, a system $\alpha$, a set of constraints $R$ and a change request $\Delta$ in order to define the evolution problem.
These values must be first extracted from the document, as described below.

\subsubsection{Preamble}
%%%Describe the preamble
The preamble from the CUDF document presented in figure \ref{formal.CUDFEXAMPLE}, 
defines the addition of one property \verb+size+ of type \verb+int+ whose default value is \verb+0+.
This extension allows the component \verb+tpspeller+ version 1, to define its \verb+size+ as $2$.

\subsubsection{Constraints}

%%%Describe the set of components and the initial system
The set of components are defined in the package stanzas in the document,
such that $C = \{syslib^1, syslib^2,  textEditor^1,  spellChecker^1,  tpspeller^1\}$.
This represents two system library versions (\verb+syslib+), a text editor component (\verb+textEditor+), a spell checker (\verb+spellChecker+) and a third party spell checker (\verb+tpspeller+).

The initial system that $\alpha$ includes all components whose package stanzas include the property \verb+installed+ set as \verb+true+.
As described above, if \verb+installed+ is not defined the property defaults to the value \verb+false+,
therefore $\alpha = \{ syslib^1 \}$.

%%%Describe the depends constraints (including features and inequalities)
The set of constraints $R$ for this CUDF document is extracted from the package description stanzas, where the relevant properties of \verb+depends+, \verb+conflicts+ and \verb+provides+ are
mapped as described in the previous sections. 
The only depends constraints in this document are from the $textEditor^1$ component;
where the depends property is broken into two \verb+<pkgflist>+, \verb+spellChecker | spellCheckerService+ and \verb+syslib > 1+.
The first \verb+<pkgflist>+ is broken into two package formulae, \verb+spellChecker+  and \verb+spellCheckerService+,
which are mapped to $\langle $\verb+spellChecker+$,0,>\rangle$ and $\langle $\verb+spellCheckerService+$,0,>\rangle$ denoted as $pf_1$ and $pf_2$ respectively.
The second has exactly one package formulae, mapped to $\langle $\verb+syslib+$,1,>\rangle$ denoted as $pf_3$.

The $packagesThatSatisfy(pf_1)$ equals $\{spellChecker^1\}$, and $packagesThatSatisfy(pf_2)$ equals $\{tpspeller^1\}$.
The function $dependsOn(textEditor^1 , \{pf_1,pf_2\} )$ 
then equals the constraint $textEditor^1 \rightarrow spellChecker^1 \vee tpspeller^1$,
expressing the text editor depends on either the spell checker component or a component that provides a third party spell checker service.

The $packagesThatSatisfy(pf_3)$ equals $\{syslib^2\}$,
and the function  $dependsOn(textEditor^1 , \{pf_3\} )$ returns the constraint  $textEditor^1 \rightarrow syslib^2$.
This expresses that for the text editor to be installed the component $syslib^2$ must be installed.

%%%Describe the conflicts constraints
In this example there are two components that declare conflicts, $syslib^1$ and $syslib^2$.
Both of these are the \verb+<pkgflist>+ with one package formulae mapped to  $\langle $\verb+syslib+$,0,>\rangle$, which is denoted as $pf_4$.
The function $packagesThatSatisfy(pf_4)$ equals $\{ syslib^1,syslib^2 \}$,
however the $conflictsWith$ function returns different conflicts because of the caveat that a component cannot conflict with itself.
Therefore, $conflictsWith(syslib^1)$ returns the set of constraints $\{syslib^1 \rightarrow \neg syslib^2\}$,
and $conflictsWith(syslib^2)$ returns the set of constraints $\{syslib^2 \rightarrow \neg syslib^1\}$.
Note: these constraints are semantically the same.

%%%All request constraints are then\ldots
Given this example the set of constraints $R$ is then 
$\{ textEditor^1 \rightarrow spellChecker^1 \vee tpspeller^1,$ 
$textEditor^1 \rightarrow syslib^2,$ 
$syslib^2 \rightarrow \neg syslib^1,$   
$syslib^2 \rightarrow \neg syslib^1\}$.

\subsubsection{Request}
%%%Describe the request constraint
The user's request constraints $\Delta$ are defined in the request stanza, which includes the request to \verb+install+ the component \verb+textEditor+. 
This package formula maps to $\langle $\verb+textEditor+$,0,>\rangle$, where $packagesThatSatisfy(\langle textEditor,0,>\rangle)$ equals $\{textEditor^1\}$.
Through functions $install$ and $installpkgflist$ this returns the constraint $textEditor^1$,
which asserts that the text editor component will be included in the new system, i.e. $\Delta = \{textEditor^1\}$.

\subsubsection{Solutions}
%%%Describe the possible models that can satisfy all constraints 
The set systems returned from the function $solutions$, as defined in section \ref{formal.step}, must satisfy all constraints in $R \cup \Delta$.

By going through the constraint the solutions can be found.
Firstly, the request constraint ensures that the text editor component is included, the component $textEditor^1$ will be installed.
If $textEditor^1$ is installed then the system library component $syslib^2$ must be installed.
As the system library components conflict, $syslib^1$ must not be installed.
Of the two components that are left, $spellChecker^1$ and $tpspeller^1$, at least one must be installed due to the dependencies of the text editor.

This gives three possible solutions to this problem;
\begin{itemize}
  \item $s_1 = \{syslib^2, textEditor^1, spellChecker^1\}$,
  \item $s_2 = \{syslib^2, textEditor^1, tpspeller^1\}$,
  \item $s_3 = \{syslib^2, textEditor^1, spellChecker^1, tpspeller^1\}$
\end{itemize}
That is, $solutions(R \cup \Delta) = \{s_1,s_2,s_3\}$.

Given some criteria defined with the function $rank$ and complete lattice $\langle A , < \rangle$, 
one of the solutions $s_1,s_2,s_3$ must be selected in the function $E(\alpha, R \cup \Delta,rank)$. 

\subsection{Mancoosi Optimisation Format}
\label{formal.mancoosioptimisationformat}
%%%Describe the format by which mancoosi has required optimisation criteria formatted
The CUDF specification does not specify the criteria used to select a solution.
For the purpose of the MISC competition however, the Mancoosi organisation gave a specification to represent optimisation criteria.
This representation was designed to be passed to the CUDF solver on the command line, this meant that it must be expressible in a single line of human readable text.
This results in the relatively simple BNF grammar, as opposed to other possible specifications such as the framework presented in \citep{treinen2009}. 
This grammar is described in figure \ref{formal.optbnf}.

\begin{figure}[h!]
\begin{center}
\begin{alltt}
<criteria> ::= <criterion> (, <criterion>)*
\end{alltt}
  \caption{Syntax of the optimisation criteria}
  \label{formal.optbnf}
\end{center}
\end{figure}

This defines a list of \verb+criterion+ with the delimiter \verb+,+ in the form $\langle criterion_1, \ldots, criterion_n \rangle$.
Each criterion is a unique string which expresses a criteria.

It is possible to map this specification to that defined above in section \ref{formal.opt}.
Given that the domain $D = \{T,F\}$ and the variables $V = \mathbb{C}$;
each criterion $criterion_i$ is mapped to a ranking system over a complete lattice $RS_i = \langle L_i,D,V \rangle$
and ranking function $rank_i$.
The composition of the criteria is then the lexicographic composition of all the $criterion_1 \oplus \ldots \oplus criterion_n$, as described in section \ref{formal.opt}.

\subsubsection{Example}
An example of how to use this mapping for a practical problem can be extracted from the above CUDF document example presented in figure \ref{formal.CUDFEXAMPLE}.
In this example, the initial system $\alpha$ was  $\{syslib^1\}$, and there were three possible solutions
\begin{itemize}
  \item $s_1 = \{syslib^2, textEditor^1, spellChecker^1\}$,
  \item $s_2 = \{syslib^2, textEditor^1, tpspeller^1\}$,
  \item $s_3 = \{syslib^2, textEditor^1, spellChecker^1, tpspeller^1\}$
\end{itemize}
That is, $solutions(R \cup \Delta) = \{s_1,s_2,s_3\}$.

The criteria to select a solution could be defined by minimising the change to the solution, then minimising the total size of the components.
For this, first two criteria must be defined, and mapped to a ranking system and function, then they must be composed to select a solution.

The criterion \verb+-change+ is firstly defined to minimise the change in components when evolving the system.
This criterion is then mapped to the ranking system $RS_{change} = \langle L_{change},D,V \rangle$ where  $L_{change}$ is the lattice $\langle \mathbb{N}, \leq \rangle$,
and the ranking function that measures the symmetric difference between the initial and the evolved systems, i.e. $rank_{change}(\alpha,\alpha') = \alpha \Delta \alpha'$.

The criterion \verb+-size+ is then defined to minimise the total size of the system.
This is mapped to the tanking system $RS_{size} = \langle L_{size},D,V \rangle$ where  $L_{size}$ is the lattice  $\langle \mathbb{N}, \leq \rangle$,
and the ranking function which returns the size of the evolved system, i.e.  $rank_{size}(\alpha,\alpha') = \sum_{c \in \alpha'} c$.\verb+size+.

If the optimisation criteria are defined as \verb+-change,-size+, then the two ranking systems are composed using the operator $\odot$,
such that $RS = \langle \langle \mathbb{N} \times \mathbb{N}, \leq_L \rangle, D, V \rangle$ where $\leq_L$ is a lexicographic order;
$(a,b) \leq_{L} (a',b')$ iff $a <_{1} a'$ or $(a = a'$ and $b \leq_{2} b')$.
Also, the ranking functions are combined such that $rank(\alpha,\alpha') = \langle rank_{change}(\alpha,\alpha'), rank_{size}(\alpha,\alpha') \rangle$.

This composed ranking function is used to calculate the rank of the solutions, where $rank(\alpha,s_1) = \langle 4, 1\rangle$, $rank(\alpha,s_2) = \langle 4, 2\rangle$, $rank(\alpha,s_3) = \langle 5, 3\rangle$.
The order of these ranks over $\leq_L$ is such that $rank(\alpha,s_1) \leq_L rank(\alpha,s_2) \leq_L rank(\alpha,s_3)$.
Therefore, given the criteria \verb+-change,-size+, the solution $s_1$ is the optimal solution for the evolution problem derived from the CUDF document presented in figure \ref{formal.CUDFEXAMPLE}.


\section{Summary}
In this chapter the semantics and syntax of component system evolution were discussed.
This evolution process was formally defined as the iterative application of an evolution step function.
Each step taken is defined as the optimal solution to an evolution problem.

The semantics of the evolution problem is defined as a set of constraints which represent the component relationships and the user's request to change the system.
This problem is syntactically represented in a CUDF document, which was described and mapped to the evolution problem. 

To define an optimal solution the $rank$ function was described as taking two solutions and measuring them.
This function was defined to be created from the lexicographical composition of multiple criteria,
where each criterion is defined as a ranking system over a complete lattice.
The representation of such criteria is in the Mancoosi optimisation format, a format created for the MISC competition.

In the following chapters, the implementation and strategies used to evolve a component system will be further discussed.
This will bring the ideas and concepts presented in this chapter to a concrete level, and show the practical challenges and benefits of automated component dependency resolution. 