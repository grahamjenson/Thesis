\chapter{Formal Model of Component System Evolution}
\label{formal}
\epigraph{In theory there is no difference between theory and practice. In practice there is.}
{\textit{Jan L. A. van de Snepscheut}}
In order to facilitate the study of the component system evolution process, a formal model has been developed.
Having such a model defines concepts and enables the discussion and investigation of component system evolution.

The component evolution process is modeled as a repetitive selection of solutions to evolution problems.
The two distinct parts of this model are the evolution problem, and the solution selection.
These are presented in sections \ref{formal.step} and \ref{formal.opt} respectively.

To represent an evolution problem and the criteria through which a solution is selected,
the Common Upgradeability Description Format (CUDF) \citep{treinen2009common}
and the Mancoosi Optimisation Format\footnote{http://www.mancoosi.org/misc-2011/criteria/ accessed 6/3/2012} (MOF) are used.
Both CUDF and MOF are presented and mapped to the formal model in section \ref{formal.cudf}. 

\section{Formal Model of Component System Evolution}
\label{formal.step}
Consider the problem where a user wants to install a text editor component into their system.
The selected text editor has a dependency on a spell checker;
meaning that a spell checker component must be installed for the text editor to be functional.
There are three spell checker components available that satisfy this dependency.
This means that at least one of these spell checkers must be selected for installation as well.
How can the user select which spell-checker to install? 

A formal model that can describe such evolution problems is presented in this section.

\subsection{Evolution Problem}
In this section a series of definitions are presented that make up the model of component system evolution.

%%%What a component is
First a component is must be defined.
\begin{defs}
\label{formal.componentdef}
Let $\mathcal{N}$ be the set of names, and $\mathcal{V}$ be the set of versions \footnote{Names and versions are finite alphanumeric sequences which can contain special some characters like ``.'' and ``-''}; 
a \textbf{component}\footnote{In recursive component models, such as Fractal \citep{Quma2006}, the definition ``component'' would include the concept of a composite component.
A composite component $c$ is defined as a set of components, i.e. $c \subseteq \mathbb{C}$.
This definition is not included in this model, though it may be possible to be modified to include it if required.} 
is an element of $\mathbb{C}$, where $\mathbb{C} = \mathcal{N} \times \mathcal{V}$. 
\end{defs}
A component $a$ is then a pair $\langle n,v \rangle$, where $n$ is its name and $v$ is its version.
The characters  $a,b,c,\ldots$ are used to denote components, $m,n,o,\ldots$ used to denote names, and $v,w,x,\ldots$ used to denote versions.

\begin{defs}
\label{formal.componentsystemdef}
A \textbf{component system} is a finite subset of components, e.g. $\alpha$ is a component system and $\alpha \subseteq_{finite} \mathbb{C}$. 
\end{defs}
The characters $\alpha,\beta,\gamma$ are used to denote component systems.

Constraints are used to restrict possible systems.
\begin{defs}
\label{formal.constraintdefs}
A \textbf{constraint} is set of component systems, e.g. $con$ is a constraint and $con \subseteq 2^{\mathbb{C}}$.
\end{defs}

Only certain types of constraints are allowed in this model, these types are:
\begin{enumerate}
  \item $\neg a := \{\alpha \in 2^{\mathbb{C}} \mid a \not \in \alpha \}$ \label{formal.removeconstraint}.
  \item $a \rightarrow \neg c := \{\alpha \in 2^{\mathbb{C}} \mid \mbox{if } a \in \alpha \mbox{ then } c \not \in \alpha\}$ \label{formal.conflictconstraint}.
  \item $a_1 \vee \ldots \vee a_n := \{\alpha \in 2^{\mathbb{C}} \mid a_1 \in \alpha \mbox{ or }\ldots \mbox{ or } a_n \in \alpha\}$ \label{formal.keepconstraint}.
  \item $a \rightarrow c_1 \vee \ldots \vee c_n := \{\alpha \in 2^{\mathbb{C}} \mid \mbox{if } a_1 \in \alpha \mbox{ then }  c_1 \in \alpha \mbox{ or } \ldots \mbox{ or } c_n \in \alpha\}$ \label{formal.dependencyconstraint}.
  \item $a_1 + \ldots + a_n = 1 := \{\alpha \in 2^{\mathbb{C}} \mid |\{a_1,\ldots,a_n\} \cap \alpha| = 1\}$ \label{formal.upgradeconstraint}.
\end{enumerate}
The set of constraints is restricted to these types as only these are necessary to represent required evolution problems. 

\begin{defs}
\label{formal.constraintdefs}
A component system, $\alpha$, \textbf{satisfies} a constraint $con$, iff $\alpha \in con$.
\end{defs}

\begin{defs}
An \textbf{evolution problem}, $EP$, is a finite set of constraints.
\end{defs}

\begin{defs}
A \textbf{solution}, $\alpha$, to an evolution problem, $EP$, is a component system that satisfies all constraints in the evolution problem, i.e. $\alpha \in con_i$ for all $con_i \in EP$.  
\end{defs}

\begin{defs}
An evolution problem is \textbf{unsatisfiable} if there exists no solution to it.  
\end{defs}


\subsubsection{Example}
Assume the evolution problem $EP = \{con_1,con_2\}$.
The constraints $con_1$ is $b$ (constraint type \ref{formal.keepconstraint}), which is defined as the set of all component system with $b$ in them.
The constraint $con_2$ is $a \rightarrow c$ (constraint type \ref{formal.dependencyconstraint}), which is defined as the set of all component systems where if $a$ is included, then $c$ is included.
The intersection of these two constraints includes all component systems that are solutions to $EP$, 
such as $\{b\}$, $\{a,b,c\}$ and $\{a,b,c,d\}$.

\subsubsection{Solving Evolution Problem is NP-Complete}
Finding a solution that satisfies all constraints in an evolution problem is NP-Complete \citep{cook1971}.
This can be shown by mapping the evolution problem to a known NP-Complete problem called one-in-three satisfiability.
This problem is defined by \cite{Schaefer1978} as:
\begin{quote}
Given sets $S_1, \ldots, S_n$ each having at most 3 members, is there a subset $T$ of the members such that for each $i$, $|T \cap S_i|  =  1$.
\end{quote}

This can be mapped to an evolution problem where:
\begin{quote}
Given sets $S_1, \ldots, S_n$ each containing 3 components, and constraints $con_1,\ldots,con_n$
such that for each $i$, $S_i = \{a,b,c\}$ iff $con_i$ equals constraint $a + b + c = 1$ (constraint type \ref{formal.upgradeconstraint}).
A set of components $\alpha$ is such that for each $i$, $|\alpha \cap S_i|  =  1$ iff $\alpha$ is a solution to the evolution problem $EP = \{con_1,\ldots,con_m\}$.
\end{quote}
This mapping shows that an evolution problem can be NP-Complete, but not all evolution problems are so difficult.
A trivial evolution problem could be constructed that could be solved efficiently.
For example, an evolution problem with not explicit (or implicit) component conflicts 
(constraint types \ref{formal.removeconstraint},\ref{formal.conflictconstraint} and \ref{formal.upgradeconstraint}), can create simple problems \citep{abate2011}.

\subsection{Constraints, Relationships, and Requests}
\label{formal.constraints}
An evolution problem is made of two sets of constraints; constraints created by the request the user has made to change the system, 
and constraints created from relationships between components.

\begin{defs}
The set of \textbf{all user requests}, $\Delta$, is the set of all constraints where each constraint in $\Delta$ is either:
\begin{itemize}
  \item an \textbf{installation} request of constraint type \ref{formal.keepconstraint}, e.g. $a \vee b$ is a request by the user to install component $a$ or $b$ into the system.
  \item a \textbf{remove} request of constraint type \ref{formal.removeconstraint}, e.g. $\neg a$ is a request by the user to remove component $a$ from the system.
  \item an \textbf{upgrade} request of constraint type \ref{formal.upgradeconstraint}, e.g. $a + b = 1$ is a request by the user to upgrade a component to either $a$ or $b$, but not both.
\end{itemize}
\end{defs}


\begin{defs}
The set of \textbf{all component relationships}, $\Omega$, is a set of all constraints where each constraint in $\Omega$ is either: 
\begin{itemize}
  \item a \textbf{keep} relationship of constraint type \ref{formal.keepconstraint}, e.g.  $a \vee b$ mean keep component $a$ or $b$ in the system.
  \item a \textbf{dependency} relationship of constraint type \ref{formal.dependencyconstraint}, e.g.  $a \rightarrow b \vee c$ means $a$ depends on component $b$ or $c$.
  \item a \textbf{conflict} relationship of constraint type \ref{formal.conflictconstraint},  e.g. $a \rightarrow \neg b$ means $a$ conflicts with component $b$.
\end{itemize}
\end{defs}

At any point in time, there exists only a finite set of components. 
\begin{defs}
$\mathbb{C}_t$ is the finite set of components that exist at time $t$, $\mathbb{C}_t \subset_{finite} \mathbb{C}$
\end{defs}

\begin{defs}
Given time $t$, and the set of components $\mathbb{C}_t$, the set of \textbf{component relationships w.r.t. time} is $\Omega_{t}$, where $\Omega_t = \{con \cap 2^{\mathbb{C}_t} \mid con \in \Omega\}$
\end{defs}

\begin{defs}
Given time $t$, and the set of components $\mathbb{C}_t$, the set of \textbf{user requests w.r.t. time} is $\Delta_{t}$, where $\Delta_t = \{con \cap 2^{\mathbb{C}_t} \mid con \in \Delta\}$
\end{defs}

\begin{defs}
Given a time $t$, a \textbf{user request}, $\delta_t$, is a finite set of user requests at time $t$, where if $con \in \delta_t$ then $con \in \Delta_t$.
\end{defs}

\begin{defs}
Given a time $t$, a set of \textbf{component relationships}, $\omega_t$, is a finite set of component relationships at time $t$, where if $con \in \omega_t$ then $con \in \Omega_t$.  
\end{defs}

An evolution problem, $EP$, can be constructed by combining a user request $\delta_t$ and a set of component relationships $\omega_t$, such that $EP = \delta_t \cup \omega_t$.

\subsubsection{Example}
At time $t$, the components $a$ and $b$ exist, therefore $\mathbb{C}_t = \{a,b\}$.
The set of all component systems at time $t$ is $2^{\mathbb{C}_t} = \{\{\},\{a\},\{b\},\{a,b\}\}$.
A component relationship constraint, $con_1 \in \Omega$, is defined as $a \rightarrow b \vee d$.
The constraint $con_1$ is satisfied by the component systems $\{a,b\}$, $\{a,b,d\}$ and $\{a,d\}$.
The constraint $con_1' \in \Omega_t$, is such that $con_1' = con_1 \cap 2^{\mathbb{C}_t}$, where $con_1' = \{\{\},\{b\},\{a,b\}\}$.

The user request constraint $con_2$ is defined as $a$, which is satisfied by the component systems $\{a\}$ and $\{a,b\}$.
The constraint $con_2' \in \Delta_t$, is such that $con_2' = con_2 \cap 2^{\mathbb{C}_t}$, where $con_2' = \{\{a\},\{a,b\}\}$.

A set of component relationships $\omega_t = \{con_1'\}$, and a user request $\delta_t = \{con_2'\}$, make the evolution problem $\delta_t \cup \omega_t$.
There only solution to $\delta_t \cup \omega_t$ is the component system $\{a,b\}$.  

\subsection{Component System Evolution}
\label{formal.evo}
A component system is evolved from one system to another to satisfy an evolution problem consisting of a user request and set of component relationships.

\begin{defs}
Given a component system $\alpha$, an \textbf{evolution preference order} is defined w.r.t. $\alpha$,  $\prec_{\alpha} \subseteq 2^{\mathbb{C}} \times 2^{\mathbb{C}}$.
\end{defs}

\begin{defs}
Given a component system $\alpha$, an evolution preference order w.r.t. $\alpha$, $\prec_{\alpha}$, and an evolution problem $EP$;
an \textbf{optimal} component system, $\beta$, is a solution to $EP$, where there exists no other solution to $EP$, $\beta'$, such that $\beta \prec_{\alpha} \beta'$.   
\end{defs}

\begin{defs}
Given a component system $\alpha_{t-1}$, an evolution preference order w.r.t. $\alpha_{t-1}$, $\prec_{\alpha_{t-1}}$, 
a user request $\delta_t$,a set of component relationships $\omega_t$, and time $t$;
the \textbf{evolution step} function $\epsilon$ returns an optimal solution, $\alpha_t$, to the evolution problem $\delta_t \cup \omega_t$, 
where $\epsilon(\alpha_{t-1},\delta_t \cup \omega_t) = \alpha_t$.
\end{defs}

\begin{defs}
Given an initial component system $\alpha_{0}$, a series of user requests $\delta_1,\ldots,\delta_{n}$, a series of sets of component relationships $\omega_1,\ldots,\omega_{n}$;
the \textbf{evolution} function $\epsilon^*$ is defined as\\
$\epsilon^*(\alpha_0,\langle \delta_1 \cup \omega_1,\ldots,\delta_{n} \cup \omega_n \rangle)$ $=$ $\epsilon(\epsilon(\ldots \epsilon(\alpha_0,\delta_1 \cup \omega_1),\ldots),\delta_n \cup \omega_n)$
$=$ $\alpha_n$.
\end{defs}

A caveat to the evolutionary step function occurs if it is unsatisfiable.
A possible solution to resolve this situation is:
Given an evolutionary problem $\delta_t \cup \omega_t$, and the component system $\alpha_{t-1}$, if $\delta_t \cup \omega_t$ is unsatisfiable, 
then $\epsilon(\alpha_{t-1},\delta_t \cup \omega_t) = \alpha_{t-1}$.
This solution is implemented in current solvers, like apt-get,
where when an evolution step fails, no change is made and output describing the failure to the user is generated. 

Another caveat to this process is that a users change request should not be undone with subsequent generations.
For example, is a user requests to install component $a$, future generations should not remove $a$.
This can be a difficult task, as in the future the user may request to remove $a$, which creates an unsatisfiable problem to keep and remove $a$.
A possible solution is to give the evolutionary preference order this responsibility to ensure the maximum amount of previous user requests are satisfied.
This is a similar problem that is faced by revision function in the domain of belief revision \citep{alchourron1985logic}.
Revision functions try to preserve consistency across a set of beliefs as new, and possibly inconsistent, information is included. 
This aspect of the evolution process is not further explored in this research, though belief revision may provide inspiration for future research.

\subsubsection{Example}
%%%This makes a sometimes counter intuitive complexity
The selection of an optimal solution to an evolutionary step, may not be optimal over multiple evolutions.

This can be demonstrated with an example:
Let the evolutionary preference order select solutions with the minimum number of components altered (the symmetric difference between the solutions), 
i.e. $\beta \prec_{\alpha} \beta'$ iff $|\alpha \Delta \beta| > |\alpha \Delta \beta'|$.
Let the initial system $\alpha_0 = \{\}$.
Let a series of user requests be $\Delta_1 = \{a\}$ and $ \Delta_2 = \{d\}$. 
Let the set of constraints $\omega_1 = \omega_2 = \{a \rightarrow b_1 \vee b_2, b_1 \rightarrow \neg b_2, b_2 \rightarrow c, d \rightarrow b_2\}$.

Consider component evolution from $\alpha_0$ to $\alpha_2$;
\begin{itemize}
  \item $\alpha_0 = \{\}$
  \item $\alpha_1 = \epsilon(\alpha_0,\delta_1 \cup \omega_1)$, given the preference order $\prec_{\alpha_0}$. $|\alpha_0 \Delta \{a,b_1\}| = 2$ is optimal, therefore $\alpha_1 = \{a,b_1\}$.
  \item $\alpha_2 = \epsilon(\alpha_1,\delta_2 \cup \omega_2)$, given the preference order $\prec_{\alpha_1}$. $|\alpha_1 \Delta \{a,b_2,c,d\}| = 4$ is optimal, therefore $\alpha_2 = \{a,b_2,c,d\}$.
\end{itemize}

From $\alpha_0$ to $\alpha_1$ components $a$ and $b_1$ are added, 
and from $\alpha_1$ to $\alpha_2$ components $b_1$ is removed, and $b_2$, $c$ and $d$ are added.
The total change across the generations is therefore $6$.
This, however, is not the optimal change over the multiple evolutions.
If $\alpha_1 = \{a,b_2,c\}$, and $\alpha_2 = \{a,b_2,c,d\}$, the total change would be $4$.
This shows that although the evolution step function returned locally optimal solutions,
globally (across multiple evolutions) the selection of solutions was not optimal.

%Should define prefernce with repect to future evolution
%should define 
 
\section{Optimal Component System Selection}
\label{formal.opt}
%%%The formal definition of how to evolve a component system is complicated because it is a multicriteria problem
Any requested evolution of a component system can have many different possible resulting systems \citep{leBerre2010}.
This is because the problem is generally under-constrained \citep{Berre2008}, allowing multiple systems to satisfy evolution problems.
The order $\prec_{\alpha}$ is used to define a preference over the possible systems to select from.

%%%This is a multi criteria problem
By looking at the previously presented CDR implementations in chapter \ref{background} (such as Eclipse P2, apt-get, aptitude, and MPM), some requirements for the preference order have be extracted:
\begin{itemize}
  \item Multiple criteria to select an optimal solution.
  \item Different criteria may have different domains to be optimised for (e.g. versions, changed components, age).
\end{itemize} 

%%%A naive solution is to map all criteria to real numbers, then aggregate them through addition multiplication with weights.
A naive way to create a preference order with these requirements is to create a function for each criteria that takes a component system and returns a real number.
Then for each possible solution the function is applied to return a value, which is then aggregated through addition or multiplication (possibly with weights).
The optimal system is then the system that returns the maximum (or minimum) real value. 

%%%This has draw backs, some criteria are infinitly more important, it is not intuitive for users to weight.
This method has some drawbacks:
\begin{itemize}
  \item Information is lost in the conversion to real numbers, e.g. the reason why a specific system was selected over another.
  \item The relationships between criteria are also difficult to intuitively define, e.g. ``size $\times$ version'' combination of criteria is confusing.
  \item Altering weights to express order over criteria does not convey meaningful information about decisions or their impact.
  For example, stating ``size is $.25$ $\times$ version'' is difficult to understand as versions and size are in two separate domains, 
and greater versions are preferred where smaller size is preferred.
\end{itemize}

%%%Using composed orders
A possibly more intuitive approach to this problem is to define each criterion as an order over component systems.
Then, the preference for one criterion over another, can be expressed by combining them together using a lexicographic order.
This composition lets the user assign a preference to criteria, without having to assign arbitrary weights.
This method has been used before in the MPM \citep{abate2011} CDR implementation, and will be presented in this section.

\subsection{Criteria and Lexicographic Composition}
In this section a criterion and the lexicographic composition of criteria are formally defined.

\begin{defs}
A \textbf{ranking function}, $rank$, is a function that takes two component systems and returns a value in the set $A$, i.e. $rank : 2^{\mathbb{C}} \times 2^{\mathbb{C}} \rightarrow A$.
\end{defs}
A ranking function measures the change from a previous system to the range $A$.

\begin{defs}
\label{formal.defcriteria}
A \textbf{criterion} is a tuple $\langle rank, \leq \rangle$, where $rank$ is a ranking function, and $\leq$ (whose strict order is $<$) is a partial order over $A$.
\end{defs}
The order $\leq$ is a partial order, which is defined to be reflexive ($a \leq a$), antisymmetry ($if a \leq b and b \leq a then a = b$), and transitive ($if a \leq b and b \leq c then a \leq c$).

\begin{defs}
\label{formal.defcrittooptimal}
The \textbf{evolution preference order} $\prec_{\alpha}$ is defined given a criterion $\langle rank, \leq \rangle$, 
iff $rank(\alpha,\beta_1) < rank(\alpha,\beta_2)$ then $\beta_1 \prec_{\alpha} \beta_2$.
\end{defs}
The evolution preference order, is described with respect to a criterion.


\begin{defs}
\label{formal.defcritlex}
The \textbf{lexicographic composition} multiple criteria into a single criterion is defined with the operator $\oplus$.
Let the two criteria $crit_1 = \langle rank_1, \leq_{1} \rangle$, and $crit_2 = \langle rank_2, \leq_{2} \rangle$,
where the range of $rank_1$ is $A_1$, and the range of $rank_2$ is $A_2$.
The lexicographical composition of $crit_1$ and $crit_2$, $crit_1 \oplus crit_2$, equal the criterion $\langle rank_L,\leq_L \rangle$.
The range of $rank_L$ is $A_1 \times A_2$, and $rank_L(\alpha,\beta) = (rank_1(\alpha,\beta),rank_2(\alpha,\beta))$.
The order $\leq_L$ (whose strict order is $<_L$) is over $A_1 \times A_2$, such that $(a,b) \leq_L (a',b')$ iff $a <_1 a'$ or $(a = a'$ and $b \leq_2 b')$.
\end{defs}
$rank_L$ takes two component systems and returns a value in the set $A_1 \times A_2$, making it a ranking function.
The order $\leq_L$ is a partial order \citep{Schroder2003} over $A_1 \times A_2$.
Therefore, the tuple $\langle rank_L,\leq_L \rangle$ is a criterion.

The composition of multiple criteria, results in a criterion, which can be used to define the evolution preference order $\prec_{\alpha}$.

In section \ref{formal.mancoosioptimisationformat} a syntax to describe the composition of criteria is defined. 
In chapter \ref{implementation} an algorithm to find optimal solutions to such criteria is described.
In chapter \ref{strategies} various criteria are defined that fit within this framework.

\section{Common Upgradeability Description Format and Mancoosi Optimisation Format}
\label{formal.cudf}
%%%The description of the represnation of CUDF is described.
The Common Upgradeability Description Format (CUDF)\footnote{This specification was previously discussed in section \ref{background.models}, with an example shown in figure \ref{CUDFmetadata}.
}, 
specification presented by \citep{treinen2009common}, is a language to describe an evolution problem ($\delta_t \cup \omega_t$) and a component system ($\alpha_{t-1}$). 
The Mancoosi Optimisation Format (MOF)\footnote{http://www.mancoosi.org/misc-2011/criteria/ accessed 6/3/2012}, is a language to describe an evolution preference order ($\prec_{\alpha_{t-1}}$).
Together, CUDF and MOF provide a language in which to express enough information for the evolutionary step function.

CUDF and MOF were to allow the comparison of various solvers in the Mancoosi International Solver Competition (MISC)\footnote{http://www.mancoosi.org/misc/ accessed 6/3/2012}.
MISC competition was held in both 2010 and 2011,
and was entered by various state of the art, and legacy, solvers that had been created, or modified, to solve CUDF problems with MOF preference order.

%%%In this section\ldots
In this section the design principles and requirements of CUDF are described.
A brief overview of a CUDF document is then presented.
The CUDF specification is then mapped to our model of component system evolution.
Finally, the MOF for specifying optimisation criteria is mapped to the model.

\subsection{CUDF Design}
\label{formal.cudfDesign}
The Mancoosi organisation is a research project committed to the improvement of the process of evolving Free and Open Source Software (FOSS) distributions.
Mancoosi looks at various problems within this domain, and have made many contributions.
One such contribution was to organise a competition between solvers of the evolution problems of FOSS systems, MISC.
This designed to encourage researchers and practitioners into researching the evolution problem.

An initial problem faced by the organisers of MISC, is that a common format was required to describe evolution problems.
The design of this format would have to follow some design principles to ensure the results would be useful.
These principles are presented in \citep{treinen2009common}, and are summarised as:

\begin{itemize}
  \item \textbf{Agnostic towards component model details}: 
  The specific component model chosen to represent the problem, should be abstracted to allow many various component models to be described.  
  \item \textbf{Stay close to the original problem}: 
  The evolution problem should be the focus of the format, therefore it should not be abstracted so far as to be unrecognisable. 
  By using similar terms and syntax that already exists within the domain, the format will still directly represent the evolution problem. 
  The analysis and design of a specific problem should be able to be directly accomplished through manual investigation.
  \item \textbf{Preserve the ability for humans to inspect encoded problems}:
  This will allow greater testing and debugging, also enable the direct inspection and creation of problems by researchers.
  \item \textbf{Avoid bias towards specific implementations or techniques}:
  Specific encoding of the evolution problem, e.g. using propositional logic, or constraint programming, may create an advantage or disadvantage for a particular technique or solution.
  Since a goal of the format is to encourage the advancement of the component system evolution area, it should strive to be independent from any technique or implementation. 
  \item \textbf{Support legacy tools}:
  The comparison to tools that are already in use to solve such evolution problems, is a necessity when determining if this research is advancing the field.
  Ideally, a legacy, or current solution, should easily be able to be adapted and used with the format.
  Conversely though, the format should not stop state-of-the-art solutions from being used.
  \item \textbf{Extensible}:
  Although the format will attempt to abstract the common elements of the problem, there may still be necessary component model specific details that require inclusion.
  Also, some details are required for the optimisation of the problem, but which are not relevant to the specification of the format.
  The ability to extend the format is then required.
  \item \textbf{Transactional semantics}:
  The format should have the ability to completely represent a problem as a single unit, that can be passed to an implementation for solution.
  Also, the solution passed back should itself be a single unit, of the same format.
  This ignores aspects of the problem such as install order of the components, though this is outside the scope of the format.
  \item \textbf{Plain Text Format}:
  The use of plain text, as opposed to a binary format, will allow it to be human readable, as well as make it easier to parse and write.
  Although plain text may not be the most efficient way to encode a problem, 
  the overhead required to parse other formats may decrease the interest of researchers, or practitioners, into researching the evolution problem.
  This also aligns with the morals of the community of FOSS developers, where plain text is the universal information interchange format \citep{raymond2003art}.
\end{itemize}

The result of these design goals is the CUDF specification, presented in \citep{treinen2009common}, and described in the following sections.

\subsection{CUDF Document}
%%%Here the CUDF document is defined using text and trying to stay away from too many formalisms, just describing concepts to be used later
In this section a brief description of the CUDF format is presented.
This description is not a complete specification, but an overview of CUDF.
Some aspects of CUDF are ignored (e.g. the formal type system) as a complete redefinition of the original specification is not the goal of this section.

A CUDF document is a single plain text file, that represents all information necessary to define an evolutionary problem.
A document also contains the description of the set of components that make a component system.

A CUDF document is separated into three sections, the preamble, the package descriptions, and the request.

\begin{itemize}
  \item \textbf{preamble} stanza: Defines the additional types used in the CUDF document
  \item \textbf{package description} stanzas: typically the bulk of a CUDF document, this defines the set of components (using the FOSS term package)
  \item \textbf{request} stanza: this defines the requested evolutionary change that should be made to the components 
\end{itemize}

This structure is presented in figure \ref{formal:cudfstruct}.

\begin{figure}[htp]
\centering
\begin{tabular}{|c|}
\hline preamble \\ \hline
\hline package description$_{1}$ \\ \hline
\hline package description$_{2}$ \\ \hline
 \multicolumn{1}{c}{\ldots}  \\ 
\hline package description$_{i}$\\ \hline
\hline request\\ \hline
\end{tabular}
\caption{Structure of the CUDF stanzas}
\label{formal:cudfstruct}
\end{figure}

Every stanza begins with a key of their type (\verb+preamble+, \verb+package+, \verb+request+), followed by several lines ending in a empty line.
Each stanza line defines a set of properties using key/value pairs separated by the delimiter ``:``, these are in no defined order.
This structure is presented in figure \ref{formal.cudfstanza}

\begin{figure}[htp] 
\begin{center}
\begin{alltt}
\textit{stanza}: \textit{value}
\textit{key_1}: \textit{value_1}
\ldots
\textit{key_n}: \textit{value_n}
\end{alltt}
  \caption{Structure of  CUDF stanza}
  \label{formal.cudfstanza}
\end{center}
\end{figure}

\subsubsection{Package Description}
The package description stanza starts with the \verb+package+ key followed by the value of package name, a non-empty string.
The only mandatory property of this stanza is defined with the key \verb+version:+ who's value is the version of the package, a positive integer.
The pair $\langle name, version \rangle$ of a package is unique, there can exist at most one package description for a given name and version.

Some relevant properties for a package are defined by the keys:
\begin{itemize}
  \item \verb+installed+: this Boolean property states whether the package is included in the described component system. 
  As the CUDF document describes all packages, installed and not, the set of packages with the property \verb+installed: true+ are included in the component system $\alpha_{t-1}$.
  \item \verb+keep+: this property describes a keep relationship, as defined in section \ref{formal.constraints}.
  Some possible values\footnote{The keep property can also be assigned feature or none} are:
	  	\begin{itemize}
	  		\item \verb+version+: keep this particular version of the package installed
	  		\item \verb+package+: keep at least one version of this package installed
		\end{itemize}
  \item \verb+provides+: this is a list of names of features or services that this package provides separated by the delimiter ``,''.
  e.g. \verb+provides: n, m, v+ means this package provides the features with name \verb+n+, \verb+m+ and \verb+v+.
  Each feature name can be accompanied by a version, to state what particular version is provided, e.g. \verb+n=10+ means feature \verb+n+ version \verb+10+ is provided.
  When no version is specified for a feature, it is defined as all versions are provided.
  \item \verb+depends+: The value of this property is mapped to a set of dependency relationships, as defined in section \ref{formal.constraints}.
  The value is a list of lists of \textbf{package formulae}, first separated by the delimiter ``,'' then delimiter ``|''.
  It is a conjunction of disjunctions (conjunctive normal form), with each formulae defining a set of packages.
  A package is defined using a name of either a package or feature $n$ and optionally an operator and version of the form  $n = v$, $n$ != $v$, $n > v$, $n < v$, $n >= v$, or $n <= v$.
  For example, \verb+depends: n , m | o < 10+ means the package depends on a packages (or features) ``name \verb+=n+ AND (name \verb+m+ OR name \verb+o+ with version less than \verb+10+)''.  
  \item \verb+conflicts+: is a list of \textbf{package formulae} as defined above separated by the delimiter ``,''.
  For example, \verb+conflicts: n , m > 2+ means this package conflicts with all packages (or features) with the ``name \verb+n+ AND name \verb+m+ with version greater than \verb+2+''.
\end{itemize}

An example of a package description stanza is given in figure \ref{formal.cudfpdstanza}.
\begin{figure}[htp] 
\begin{center}
\begin{alltt}
package: textEditor
version: 1
installed: true
depends: spellCheckerService
\end{alltt}
  \caption{Example of Package Description Stanza}
  \label{formal.cudfpdstanza}
\end{center}
\end{figure}

\subsubsection{Preamble}
\label{cudf.preambledes}
The preamble stanza starts with the key \verb+preamble:+, no value is necessary for this key.
The main function of the preamble is to provide the description of additional properties and their types, that can be used by package descriptions.
This is the mechanism which allows the extension of a CUDF document, as described in design principles of CUDF presented in section \ref{formal.cudfDesign}.

Extension properties are described in the value to key \verb+property+.
This value is a list of properties that describe a name of the property, the type of the property and optionally the properties default value.
Each property is separated by the delimiter ``,'', the name is separated from the version by ``:``, and the default value is wrapped in ``['' and ``]'' and separated from the version by ``=``.

For example, \verb+property: size: int, bugs: int = [0]+ defines the integer property of \verb+size+ and the integer property of \verb+bugs+ with the default value \verb+0+.
An example where these extended properties are used in a package description stanza is shown in figure \ref{formal.cudfextensionexample}.

\begin{figure}[htp] 
\begin{center}
\begin{alltt}
preamble:
property: size: int, bugs: int = [0]

package: textEditor
version: 1
bugs: 10
size: 2
depends: spellCheckerService

\end{alltt}
  \caption{Example of preamble stanza with extendable CUDF syntax}
  \label{formal.cudfextensionexample}
\end{center}
\end{figure}

\subsubsection{Request}
\label{formal.cudfdes.request}
The request stanza starts with the \verb+request:+ key, no value is required for this key.
This stanza contains three properties that define the user request to change the system.
Each value is a list of \textbf{package formulae} separated by the delimiter ``,''.
The keys and values are:
\begin{itemize}
  \item \verb+install+ key, whose value is mapped to a set of installation requests, as described in section \ref{formal.constraints}.
  For example, \verb+install: n, m >= 2+ means install component \verb+n+ and component \verb+m+ of version two or greater.
  \item \verb+remove+ key, whose value is mapped to a set of remove requests, as described in section \ref{formal.constraints}.
  For example, \verb+remove: n , m = 2+ means remove all components with name \verb+n+ and component \verb+m+ of version two.
  \item \verb+upgrade+ key, whose value is mapped to a set of upgrade and remove requests, as described in section \ref{formal.constraints}.
  For example, \verb+upgrade: n+ means to remove all packages of name \verb+n+ and install one package of equal or greater versions to that of the maximum version of \verb+m+ currently installed. 
\end{itemize}

\begin{figure}[htp] 
\begin{center}
\begin{alltt}
request:
install: n
remove: m
upgrade: o
\end{alltt}
  \caption{Example of CUDF request stanza}
  \label{formal.cudfrequeststanza}
\end{center}
\end{figure}

In figure \ref{formal.cudfrequeststanza}, an example of the request stanza is given.
In this example, a component of name \verb+n+ is requested to be installed, all components of name \verb+m+ are requested to be removed,
components of name \verb+o+ are requested to be upgraded.

%%%Upgrading with multiple packages
The CUDF request to upgrade a component is the most complex request.
This complexity is because CUDF defines two requirements on the upgrade request,
\begin{enumerate}
  \item Only one component of the selected name can be installed.
  \item The installed component's version must be greater than, or equal to, the currently installed greatest version of a component with that name.
\end{enumerate}
For example, if a system has components $a_1 = \langle n,1 \rangle$ and $a_2 = \langle n,2 \rangle$ installed and it is requested to upgrade components with name $n$.
Component $a_1$ must be removed, and either $a_2$ can remain, or $a_2$ can be removed and a higher version of a component with name $n$ can be installed.

\subsection{CUDF Specification}
In this section, the model presented in section \ref{formal.step} is mapped to this CUDF specification.
The package stanzas are used to define to the set of components, $\mathbb{C}_t$, the component system, $\alpha_{t-1}$, and the component relationship constraints $\omega_t$. 
The request stanza is used to define the user request $\delta_t$. 

\subsubsection{CUDF BNF Grammar}
A simplified version of the CUDF EBNF grammar\footnote{http://www.mancoosi.org/cudf/ebnf/ visited 26/3/2012} is given in figure \ref{formal.cudfBNFgrammar}. 

\begin{figure}[htp] 
\begin{center}
\begin{alltt}
(* Top Level Elements *)
<cudf> ::= <preamble> <packagedescription>* <request>
<preamble> ::= "preamble:" "\textbackslash{}n" <stanza>
<packagedescription> ::= "package:" <name> "\textbackslash{}n" "version:" <nat> "\textbackslash{}n" <stanza>
<request> ::= "request:" "\textbackslash{}n" <stanza>
(* Structure *)
<stanza> ::= [<property> "\textbackslash{}n"]* "\textbackslash{}n"
<property> ::= <key> ":" <value>
<key> ::= <ident>
<value> ::= <bool> | <int> | <nat> | <string> \\| <name> | <ident> | <vpkgformula> | <vpkglist> | <veqpkglist> | <typedecls>
<vpkgformula> ::= <orformula> ("," <orformula>)*
<orformula> ::= <vpkg> ("|" <vpkg>)*
<vpkglist> ::= <vpkg> ("," <vpkg>)*
<vpkg> ::= <name> (<relop> <version>)?
<relop> ::= "=" | "!=" | ">=" | ">" | "<=" | "<"

<veqpkglist> ::= <veqpkg> ("," <veqpkg>)*
<veqpkg> ::= <name> ("=" <version>)?

<typedecls> ::= <typedecl> ("," <typedecl>)*
<typedecl> ::= ident ":" type ("=" "["<nat>"]")?
<type> ::= "int"

(* Bottom Level Types *)
<name> ::= ["A"-"Z" | "a"-"z" | "0"-"9" | "-" | "+" | "." | "/" | "@" | "(" ")" | "\%"]+
<ident> ::= ["a"-"z"][""a"-"z" | "0"-"9"]+		
<nat> ::= ["0"-"9"]+
<bool> ::= "true" | "false"
<int> ::= ("+"|"-")? ["0"-"9"]+
<string> ::= [^"\textbackslash{}n"| ^"\textbackslash{}n"]* (*Unicode string with no CR or LF*)
\end{alltt}
  \caption{CUDF BNF Grammar}
  \label{formal.cudfBNFgrammar}
\end{center}
\end{figure}

\subsubsection{Additional Constraints}
In figure \ref{formal.cudfBNFgrammar}, a CUDF document is described as a preamble, a list of package descriptions, and a request.
The preamble is a stanza started with the text \verb+preamble:+.
A package description is a stanza started with a package name, and a package version.
The request is a stanza started with the text \verb+request:+.

This grammar does not list all the constraints for each stanza, and each property.
For example, the property with key \verb+installed+ can only be in a package description, and can only have a \verb+<bool>+ value.
Each stanza type (preamble, package description or request) can consist of different properties, where each properties value can be of a different type.
In tables \ref{formal.cudfpremableprops}, \ref{formal.cudfpdprops} and \ref{formal.cudfrequestprops}, 
the allowed properties for the preamble, a package description, and the request are described respectively.

\begin{table}
\begin{tabular}{|c|c|c|}
Property Name & Value Type & Default Value \\ \hline
property & \verb+<typedecl>+ & \verb+""+
\end{tabular}
\caption{Preamble properties}
\label{formal.cudfpremableprops}
\end{table}

\begin{table}
\begin{tabular}{|c|c|c|}
Property Name & Value Type & Default Value \\ \hline
\texttt{depends} & \verb+<vpkgformula>+ & \verb+""+ \\
\texttt{conflicts} & \verb+<vpkglist>+ & \verb+""+ \\ 
\texttt{provides} & \verb+<veqpkglist>+ & \verb+""+ \\ 
\texttt{installed} & \verb+<bool>+ & \verb+false+ \\ 
\texttt{keep} & \texttt{<ident>} either \texttt{"version"}, \texttt{"package"}, or \texttt{"none"} & \texttt{"none"} \\ 
\end{tabular}
\caption{Package Description properties}
\label{formal.cudfpdprops}
\end{table}

\begin{table}
\begin{tabular}{|c|c|c|}
Property Name & Value Type & Default Value \\ \hline
\texttt{install} & \verb+<vpkglist>+ & \verb+""+ \\ 
\texttt{remove} & \verb+<vpkglist>+ & \verb+""+ \\ 
\texttt{upgrade} & \verb+<vpkglist>+ & \verb+""+ \\ 
\end{tabular}
\caption{Request properties}
\label{formal.cudfrequestprops}
\end{table}

In addition to the properties allowed in the package description, as presented in table \ref{formal.cudfpdprops}, extra properties can be defined in the preamble's \texttt{property} property.
This is described in section \ref{cudf.preambledes}, and restricted to only defining new \texttt{<int>} typed properties.

\subsubsection{Mapping}

\begin{defs}
A \textbf{CUDF document} is a preamble stanza ($preamble$), a set of package description stanzas ($PD$) , and a request stanza ($request$), $\langle premable, PD, request \rangle$.
\end{defs}

Each stanza can be seen as a function:
\begin{defs}
A stanza $s$ is a function that takes a key \texttt{key}, and returns a value \texttt{value}, $s($\texttt{key}$) = $\texttt{value}. 
\end{defs}

This function is abbreviated to use the infix notation \texttt{.}:
\begin{defs}
Given a stanza $s$, a key \texttt{key}, and value \texttt{value}, $s$.\texttt{key}$ = $\texttt{value} iff $s($\texttt{key}$) = $\texttt{value}.
\end{defs}
For a package description stanza $pd$, $pd$.\texttt{name} returns the \texttt{<name>} describing the name of the component.
Also, $pd$.\texttt{version} returns the \texttt{<nat>} which defines the version of the component.

In the following sections, this CUDF document is mapped to the set of components $\mathbb{C}_t$, the component system $\alpha_{t-1}$,
the component relationship constraints $\omega_t$, and the user request constraints $\delta_t$.

\subsubsection{Components}
The set of components, $\mathbb{C}_t$, and component system $\alpha_{t-1}$ are defined given a CUDF document.

\begin{defs}
The function $pd2c$ is defined to take a package description stanza $pd$, and return a component, $pd2c(pd) = \langle pd.$\texttt{name}, $pd.$\texttt{version} $\rangle$.
\end{defs}

The infix notation \texttt{.} can also be used to abbreviate component properties: 
\begin{defs}
Given a package description stanza $pd$,  the component $c = pd2c(pd)$, a key \texttt{key}, and value \texttt{value}, 
$c$.\texttt{key}$ = $\texttt{value} iff $pd$.\texttt{key} $ = $ \texttt{value}.
\end{defs}

\begin{defs}
Given a CUDF document $\langle premable, PD, request \rangle$, the set of components $\mathbb{C}_t$ equals the set of package descriptions mapped using the function $pd2c$,
$\mathbb{C}_t = \{pd2c(pd) \mid pd \in PD\}$
\end{defs}

\begin{defs}
Given a CUDF document $\langle premable, PD, request \rangle$, the component system $\alpha_{t-1}$ equals the set of package descriptions, mapped using the function $pd2c$,
whose property \texttt{installed} equals \texttt{true},
$\alpha_{t-1} = \{pd2c(pd) \mid pd \in PD $ and $ pd.$\texttt{installed} $=$ \texttt{true} $\}$
\end{defs}

\subsubsection{Features}
%%%Features or services
CUDF specifies an additional aspect to component relationships, that of a feature or service.
Each component can provide a set of features, where each feature is represented by a name, and a set of versions.
Unlike a component, which has exactly one version, a component can provide multiple versions of a feature.

\begin{defs}
A \textbf{feature} $f$ is a pair consisting of a name $n \in \mathcal{N}$ and a set of versions $V \subseteq \mathcal{V}$ , 
$f = \langle n,V \rangle$
\end{defs}

The features provided by a component are defined as the property with the key \verb+provides+, which is of the type \texttt{<veqpkglist>}.
This type is a list of \texttt{<veqpkg>}, either of the form ``\verb+<name>+'' or  ``\verb+<name>+ = \verb+<version>+''.
\begin{itemize}
  \item \verb+<name>+ $:=$ $($\verb+<name>+$,\mathbb{V})$
  \item \verb+<name>+ = \verb+<version>+ $:=$ $($\verb+<fname>+$,\{$\verb+<version>+$\})$
\end{itemize}
That is, a \texttt{<veqpkg>} which does not define a version, is defined as a feature that provides all versions.
A  \texttt{<veqpkg>} the defines a version, is defined as a feature that provides a singleton set of that version.

\begin{defs}
The function $providedFeatures$ is defined to take a component $c$, and return the set of features that component provides,
$providedFeatures(c) =$ the set of features mapped from the $c$.\texttt{provides} value.
\end{defs}

\subsubsection{Package formula}
A package formula, of type \texttt{<vpkg>}, is a query to retrieve a set of components from a CUDF document.
This formula is the mechanism that defines all relationships and requests in the CUDF specification.

Each \texttt{<vpkg>} is of the form ``\texttt{<name>}'' or  ``\texttt{<name> <relop> <version>}''.
\begin{defs}
A \textbf{package formula} $pf$ is a triple, name $n$, version $v$, and relation $r$, $pf = \langle n, v , r \rangle$.
\end{defs}

The syntax of \verb+<relop>+ is parsed to a mathematical relation with the function $relop$:  
$relop = \{$ \verb+"="+ $\rightarrow$ $=$, \verb+"!="+ $\rightarrow \not =$, 
\verb+">="+ $\rightarrow$ $\geq$, \verb+">"+ $\rightarrow$ $>$, \verb+"<="+ $\rightarrow$ $\leq$, \verb+"<"+ $\rightarrow$ $<$$\}$.

\begin{itemize}
  \item \texttt{<name>} $:=$ $\langle $\texttt{<name>}$, 0 , > \rangle$
  \item \texttt{<name> <relop> <version>} $:=$ $\langle $\texttt{<name>}$,$ \texttt{<version>}$, relop($\texttt{<relop>}$) \rangle$
\end{itemize}
That is, a \texttt{<vpkg>} that does not define a relation or version, is defined as a package formula that is greater than zero.

%%%Find all packages which satisfy the package formula
A function to find packages that satisfy the package formula is defined:
\begin{defs}
The function $packages$ is defined to take a package formula $\langle n,v,op\rangle$ and return the set of components that satisfy the formula,
$packages(\langle n,v,op\rangle) = \{\langle n,v_c \rangle \mid \langle n,v_c \rangle \in \mathbb{C}_t \mbox{ and } v_c \mbox{ op } v\}$
\end{defs}

%%%Find all packages who provides a feature which satisfies the package formula
A package formula may not distinguish between components and features, so a package formula is also used to search for components providing a feature.
A function is then defined to find packages that provide a feature that satisfies a package formula:
\begin{defs}
The function $features$ is defined to take a package formula $\langle n,v,op\rangle$ and return the set of components that provide a feature that satisfy the formula,
$features(\langle n,v,op\rangle) = \{c \mid c \in \mathbb{C}_t \mbox{ and } (n,V) \in providedFeatures(c) \mbox{ and } \exists v_f \in V \mbox { where } v_f \mbox{ op } v \}$.
\end{defs}

Give the functions $packages$ and $features$ the set of all components that can satisfy a formula:
\begin{defs}
The function $packagesThatSatisfy$ reutrns the set of all components that can satisfy the package formula $pf$, $packagesThatSatisfy(pf) = packages(pf) \cup features(pf)$.
\end{defs}

\subsubsection{Relationships}
Given a CUDF document, three sets of relationship constraints, each of different types, are extracted:
\begin{itemize}
  \item keep relationship constraints $\omega_t^{keep}$ are extracted from the \verb+keep+ key of package descriptions in $\alpha_{t-1}$.
  \item dependency relationship constraints $\omega_t^{dep}$ are extracted from the \verb+depends+ key of package descriptions in $\mathbb{C}_t$.
  \item conflict relationship constraints $\omega_t^{confl}$ are extracted from the \verb+conflicts+ key of package descriptions in $\mathbb{C}_t$.
\end{itemize}
The set of relationship constraints $\omega_t$, as described in section \ref{formal.step}, is then the union of these,
$\omega_t =  \omega_t^{keep} \cup \omega_t^{dep} \cup \omega_t^{confl}$


\paragraph{Keep Relationship}
Given a CUDF document, the set of keep relationship constraints is $\omega_t^{keep}$.
These constraints are extracted from the key \texttt{keep} of the components in $\alpha_{t-1}$.
 
The values of the property with key \texttt{keep} can be either \texttt{none}, \texttt{version}, or \texttt{package}.
If the value is \texttt{none}, then no constraints are generated.
\begin{defs}
The function $keep$ takes a component $c = \langle n ,v \rangle$, and returns a set of keep relationship constraints, such that
\begin{itemize}
	\item if $c$.\verb+keep+ equals \verb+none+: $keep(c) = \emptyset$
	\item if $c$.\verb+keep+ equals \verb+version+: $keep(c) = \{c\}$
	\item if $c$.\verb+keep+ equals \verb+package+: $keep(c) = \{\bigvee packages(\langle n, >, 0 \rangle)\}$
\end{itemize}
\end{defs}
The function $keep$ is defined to take a component $c$ and to return a set of keep relationship constraints where
if the value of $c$.\verb+keep+ equals \verb+none+ then the empty set if returned.
If the value of $c$.\verb+keep+ equals \verb+version+, the returned set contains one keep relationship constraint that states that component should be kept;
If the value of $c$.\verb+keep+ equals \verb+package+, 
the returned set contains one keep relationship constraint that states that a component with the same name should be kept. 

\begin{defs}
Given a CUDF document with component systen $\alpha_{t-1}$, the set of all keep relationship constraints, $\omega_t^{keep}$, 
equals $\bigcup \limits_{c \in \alpha_{t-1}} keep(c)$.
\end{defs}

\paragraph{Dependency Constraint}
%%TODO UPTO HERE
The dependency constraints of a set of components $\mathbb{C}$ defined in a CUDF document are mapped using the property key \verb+depends+,
whose syntax is defined as \verb+<depends>+ from the BNF grammar presented in figure \ref{formal.cudfdependssyntax}.



This syntax shows that the depends property is a list of package formula (as defined in figure \ref{formal.cudfpackageformulasyntax}) lists, 
first separated by the delimiter ``,'' then by the delimiter ``|''.
Each package formula list maps to a single dependency constraint, as described in section \ref{formal.step}.

The syntax of a \verb+<pkgflist>+ is in the form ``\verb+<pkgf>+$_1$ | \ldots | \verb+<pkgf>+$_n$'', where \verb+<pkgf>+$_i$ maps to $pf_i$.
Each \verb+<pkgflist>+ then maps to a set of package formulae $pkgflist$ such that $pkgflist = \{pf_1,\ldots, pf_n\}$.

The property \verb+<depends>+ is then of the form ``\verb+<pkgflist>+$_1$ ,\ldots, \verb+<pkgflist>+$_n$'', where \verb+<pkgflist>+$_i$ maps to a set of package formulae $pkgflist_i$. 
The property \verb+<depends>+ is mapped to a set of sets of package formulae $listpkgflist = \{pkgflist_1,\ldots,pkgflist_n\}$.

The function $dependsOn$ is then defined such that it takes a component and a package list to create a single dependency constraint of the form $a \rightarrow c_1 \vee \ldots \vee c_n$,
as defined in section \ref{formal.step}.
Given a component $a$ and a package list $pkgflist$, 
$dependsOn(a,pkgflist)$ equals the constraint $a \rightarrow \bigvee  \bigcup \limits_{pkgf \in pkgflist} packagesThatSatisfy(pkgf)$.
That is, $dependsOn(a,pkgflist)$ is $a$ implying the disjunction of the union of all components that satisfy a contained package formula to create the dependency constraint. 

The function $depends$ is then defined to return a set of all dependency constraints for a component.
Given a component $a$, the set of sets of package formulae mapped from $a$.\verb+depends+ denoted as $listpkgflist$,
$depends(a)$ is defined to equal $\bigcup \limits_{pkgflst \in listpkgflist} dependsOn(a,pkgflst)$.
That is, the set of dependency constraints for a given component is the union of all constraints created from individual \verb+depends+ properties.

Finally, the set of all dependency constraints is defined given the set of all components $\mathbb{C}$ defined in a CUDF document,
such that the set of dependency constraints equals $\bigcup \limits_{c\in \mathbb{C}} depends(a)$.

\paragraph{Conflict Constraint}
The conflict constraints of a given component defines the relationship where it will not be functional with another component in the system.
The syntax of the \verb+conflicts+ property value is defined as \verb+<conflicts>+ and is presented in figure \ref{formal.cudfconflictsyntax}.



This syntax is the same as defined above in the depends property syntax for \verb+<pkgflist>+ except it uses a different delimiter. 
The mapping is also the same, where the property value is in the form \verb+<pkgf>+$_1$ , \ldots , \verb+<pkgf>+$_n$ and maps to a set of package formulae $conflictPkgF$.

Given a component $a$ and the set $conflictPkgF$ that is mapped from the $a$.\verb+conflicts+;
the function $conflictsWith$ is defined to return a set of conflict constraints where each constraints is in the form $a \rightarrow \neg c$, as defined in section \ref{formal.step}.
This function is defined as, 
$conflictsWith(a) = [a \rightarrow \neg c \mid c \in packagesThatSatisfy(pf) \mbox{ and } pf \in conflictPkgF \mbox { and } c \not = a]$.
That is, a component conflicts with any component that satisfies a package formula defined in its \verb+conflicts+ property,
with the exception that it cannot conflict with itself.
This final caveat of a CUDF conflict is directly taken from the Debian package specification \citep{Barth2005}, 
as it allows a package to declare a conflict with itself and this forces similar packages to be removed if it is installed.  

Finally, given the $\mathbb{C}$ is the set of all components in a CUDF document,
the set of all conflict constraints for a CUDF document is defined as $\bigcup \limits_{c\in \mathbb{C}} conflicts(a)$.

\paragraph{Union}
Given a set of components $\mathbb{C}_t$, the set of component system $\alpha_{t-1}$, 
the set of all relationship constraints, $\omega_t$ is the union of the keep, depends and conflicts constraints defined above.
That is, 
\begin{defs}
$\omega_t = \bigcup \limits_{c \in \alpha_{t-1}} keep(c) \cup \bigcup \limits_{c \in \mathbb{C}_t} depends(a) \cup \bigcup \limits_{c\in \mathbb{C}_t} conflicts(a)$.
\end{defs}

\subsubsection{Request}
\label{formal.cudf.request}
In a CUDF document there exist exactly one request stanza, which has three optional properties \verb+install+, \verb+remove+ and \verb+upgrade+ respectively.
Each value for these properties has the same syntax, shown in figure \ref{formal.requestssyntax}.


The syntax of \verb+<pkgflist>+ is exactly the same defined above for the conflicts property, and can be mapped to the set of package formulae $pkgflist$.
The \verb+install+ property maps to the package formulae set $installpkgflist$; the \verb+remove+ property maps to the package formulae set $removepkgflist$;
the \verb+upgrade+ property maps to the package formulae set  $upgradepkgflist$.

\paragraph{Install}
Install requests are made of constraint type \ref{formal.keepconstraint}.
The function  $install(pf)$ is defined to take a package formula $pf$ and return one install constraint such that $\bigvee packagesThatSatisfy(pf)$.
Each package formulae in the set $installpkgflist$ creates one install constraint,
therefore the set of all install constraints is defined as $\bigcup \limits_{pf \in installpkgflist} install(pf)$.

\paragraph{Remove}
Remove requests are made of constraint type \ref{formal.removeconstraint}.
The function $remove(pf)$ is defined to take a package formula $pf$ and returns a set of remove constraints such that $[\neg a \mid  a \in packagesThatSatisfy(pf)]$.
Then the set of remove constraints is the union of all constraints created from the $removepkgflist$ set, i.e. $\bigcup \limits_{pf \in removepkgflist} remove(pf)$.

\paragraph{Upgrade}
%%%This is a difficult to express
The upgrade request in a CUDF document is the most complex request type, as discussed in section \ref{formal.cudfdes.request}
For each package formula $pf$ in $upgradepkgflist$, two constraint are created to satisfy:
\begin{enumerate}
  \item exactly one package that satisfies $pf$ is in the system
  \item no packages with a lesser version than the highest currently installed component with the name from $pf$ can be included.
\end{enumerate} 

The first upgrade constraint is the constraint type \ref{formal.upgradeconstraint}.
Given the package formula $pf$, the function $upgrade_1$ is defined to return an upgrade constraint,
such that $upgrade_1(pf) = \bigoplus packagesThatSatisfy(pf) = 1$.
That is, each package that satisfies the package formula is included in the cardinality constraint.

The second upgrade constraint is the constraint type \ref{formal.removeconstraint}.
To create the required constraints some utility functions $named$ and $maxversion$ are defined.

\begin{defs}
Given the a set of components $\beta$ and the package name $n$ the set of packages in $\beta$ of the name $n$ is returned by the function $named$, such that
$named(\beta,n) = \beta \cap packagesThatSatisfy(\langle n,0,> \rangle)$.
\end{defs} 

\begin{defs}
Given a set of components $\beta$ and a name $n$ the function $maxversion(\beta,n)$ returns the natural number $c$.\verb+version+ 
such that $c \in named(\beta,n)$ and $\nexists c' \in named(\beta,n)$ where $c'$.\verb+version+ $> c$.\verb+version+.
\end{defs}
That is, $maxversion(\beta,n)$ returns the highest version of any component with a name $n$.

Given the name $n$ and a set of component $\beta$, the set of components that are below this maximum version of $n$ in $\beta$ is defined as:
$packagesThatSatisfy(\langle n, maxversion(\beta,n), < \rangle)$
So to satisfy the second constraint of the upgrade request to have no package installed with the same name but lesser version that the highest currently installed version,
the function  $upgrade_2$ is defined as:
\begin{defs}
Given the component system $\alpha_{t-1}$ and a package formula $\langle n,v,op \rangle$,
$upgrade_2(\alpha_{t-1},\langle n,v,op \rangle) = [\neg a \mid a \in packagesThatSatisfy(\langle n, maxversion(\beta,n), < \rangle)]$
\end{defs}
That is, all components of name $n$ that have a lesser version than the highest version currently installed in $\alpha$ cannot be installed in the new system. 

The set of all upgrade constraints is then the union of all constraints created for all package formulae in $upgradepkgflist$,
i.e. $\bigcup \limits_{pf \in upgradepkgflist} (upgrade_1(pf) \cup upgrade_2(\alpha_{t-1},pf))$.

\paragraph{Union}
Given a set of components $\mathbb{C}_t$, the set of currently installed components $\alpha_{t-1}$,
and the sets of package formulae mapped from the request stanza properties \verb+install+, \verb+remove+ and \verb+upgrade+ 
(respectively $installpkgflist$, $removepkgflist$ and $upgradepkgflist$);
the set of all change constraints represented as $\Delta$ is the union of the install, remove and upgrade constraints above.
That is, 
\begin{defs}
Given 
\begin{itemize}
  \item $i = \bigcup \limits_{pf \in installpkgflist} install(pf)$
  \item $r = \bigcup \limits_{pf \in removepkgflist} remove(pf)$
  \item $u = \bigcup \limits_{pf \in upgradepkgflist} (upgrade_1(pf) \cup upgrade_2(\alpha_{t-1},pf))$
\end{itemize}
$\delta_t =  i \cup r \cup u$
\end{defs}

\subsection{Full Example}
\label{formal.example}
An example of a CUDF document is presented in figure \ref{formal.CUDFEXAMPLE} to illuminate the basic process of mapping a CUDF document to a set of constraints as expressed in section \ref{formal.step}.

\begin{figure}[htp] 
\begin{center}
\begin{alltt}
preamble:
property: size: int = [0]

package: syslib
version: 1
installed: true
conflicts: syslib

package: syslib
version: 2
conflicts: syslib

package: textEditor
version: 1
depends: spellChecker | spellCheckerService, syslib > 1

package spellChecker
version: 1
size: 1

package: tpspeller
version: 1
provides: spellCheckerService
size: 2

request:
install:textEditor

\end{alltt}
  \caption[CUDF Example]{Example of a CUDF request}
  \label{formal.CUDFEXAMPLE}
\end{center}
\end{figure} 

This example can be mapped to a set of components $\mathbb{C}_t$, a system $\alpha$, a set of constraints $R_t$ and a change request $\Delta_t$ in order to define the evolution problem.
These values must be first extracted from the document, as described below.

\subsubsection{Preamble}
%%%Describe the preamble
The preamble from the CUDF document presented in figure \ref{formal.CUDFEXAMPLE}, 
defines the addition of one property \verb+size+ of type \verb+int+ whose default value is \verb+0+.
This extension allows the component \verb+tpspeller+ version 1, to define its \verb+size+ as $2$.

\subsubsection{Constraints}

%%%Describe the set of components and the initial system
The set of components are defined in the package stanzas in the document,
such that $\mathbb{C}_t = \{syslib_1, syslib_2,  textEditor_1,  spellChecker_1,  tpspeller_1\}$.
This represents two system library versions (\verb+syslib+), a text editor component (\verb+textEditor+), a spell checker (\verb+spellChecker+) and a third party spell checker (\verb+tpspeller+).

The initial system that $\alpha$ includes all components whose package stanzas include the property \verb+installed+ set as \verb+true+.
As described above, if \verb+installed+ is not defined the property defaults to the value \verb+false+,
therefore $\alpha = \{ syslib_1 \}$.

%%%Describe the depends constraints (including features and inequalities)
The set of constraints $R_t$ for this CUDF document is extracted from the package description stanzas, where the relevant properties of \verb+depends+, \verb+conflicts+ and \verb+provides+ are
mapped as described in the previous sections. 
The only depends constraints in this document are from the $textEditor_1$ component;
where the depends property is broken into two \verb+<pkgflist>+, \verb+spellChecker | spellCheckerService+ and \verb+syslib > 1+.
The first \verb+<pkgflist>+ is broken into two package formulae, \verb+spellChecker+  and \verb+spellCheckerService+,
which are mapped to $\langle $\verb+spellChecker+$,0,>\rangle$ and $\langle $\verb+spellCheckerService+$,0,>\rangle$ denoted as $pf_1$ and $pf_2$ respectively.
The second has exactly one package formulae, mapped to $\langle $\verb+syslib+$,1,>\rangle$ denoted as $pf_3$.

The $packagesThatSatisfy(pf_1)$ equals $\{spellChecker_1\}$, and $packagesThatSatisfy(pf_2)$ equals $\{tpspeller_1\}$.
The function $dependsOn(textEditor_1 , \{pf_1,pf_2\} )$ 
then equals the constraint $textEditor_1 \rightarrow spellChecker_1 \vee tpspeller_1$,
expressing the text editor depends on either the spell checker component or a component that provides a third party spell checker service.

The $packagesThatSatisfy(pf_3)$ equals $\{syslib_2\}$,
and the function  $dependsOn(textEditor_1 , \{pf_3\} )$ returns the constraint  $textEditor_1 \rightarrow syslib_2$.
This expresses that for the text editor to be installed the component $syslib_2$ must be installed.

%%%Describe the conflicts constraints
In this example there are two components that declare conflicts, $syslib_1$ and $syslib_2$.
Both of these are the \verb+<pkgflist>+ with one package formulae mapped to  $\langle $\verb+syslib+$,0,>\rangle$, which is denoted as $pf_4$.
The function $packagesThatSatisfy(pf_4)$ equals $\{ syslib_1,syslib_2 \}$,
however the $conflictsWith$ function returns different conflicts because of the caveat that a component cannot conflict with itself.
Therefore, $conflictsWith(syslib_1)$ returns the set of constraints $\{syslib_1 \rightarrow \neg syslib_2\}$,
and $conflictsWith(syslib_2)$ returns the set of constraints $\{syslib_2 \rightarrow \neg syslib_1\}$.
Note: these constraints are semantically the same.

%%%All request constraints are then\ldots
Given this example the set of constraints $R_t$ is then the constraints
$\{ textEditor_1 \rightarrow spellChecker_1 \vee tpspeller_1,$ 
$textEditor_1 \rightarrow syslib_2,$ 
$syslib_2 \rightarrow \neg syslib_1,$   
$syslib_2 \rightarrow \neg syslib_1\}$.

\subsubsection{Request}
%%%Describe the request constraint
The user's request constraints $\Delta_t$ are defined in the request stanza, which includes the request to \verb+install+ the component \verb+textEditor+. 
This package formula maps to $\langle $\verb+textEditor+$,0,>\rangle$, where $packagesThatSatisfy(\langle textEditor,0,>\rangle)$ equals $\{textEditor_1\}$.
Through functions $install$ and $installpkgflist$ this returns the constraint $textEditor_1$,
which asserts that the text editor component will be included in the new system, i.e. $\Delta_t = \{textEditor_1\}$.

\subsubsection{Solutions}
%%%Describe the possible models that can satisfy all constraints 
The set solutions to the evolution problem $\delta_t \cup \omega_t$ is the intersection of all constraints.

By going through the constraints the solutions can be found.
Firstly, the request constraint ensures that the text editor component is included, the component $textEditor_1$ will be installed.
If $textEditor_1$ is installed then the system library component $syslib_2$ must be installed.
As the system library components conflict, $syslib_1$ must not be installed.
Of the two components that are left, $spellChecker_1$ and $tpspeller_1$, at least one must be installed due to the dependencies of the text editor.

This gives three possible solutions to this problem;
\begin{itemize}
  \item $s_1 = \{syslib_2, textEditor_1, spellChecker_1\}$,
  \item $s_2 = \{syslib_2, textEditor_1, tpspeller_1\}$,
  \item $s_3 = \{syslib_2, textEditor_1, spellChecker_1, tpspeller_1\}$
\end{itemize}

Given some criteria defined with the order $\prec_{\alpha}$, one of the solutions $s_1,s_2,s_3$ must be selected in the function $E(EP_t,\prec_{\alpha})$. 

\subsection{Mancoosi Optimisation Format}
\label{formal.mancoosioptimisationformat}
%%%Describe the format by which mancoosi has required optimisation criteria formatted
The CUDF specification does not specify the criteria used to select a solution.
For the purpose of the MISC competition, the Mancoosi organisation gave a specification to represent optimisation criteria.
This representation here is called the Mancoosi Optimisation Format (MOF), which can be mapped to the model described in section \ref{formal.opt}
This representation was designed to be passed to the CUDF solver on the command line, this meant that it must be expressible in a single line of human readable text.
This results in the relatively simple BNF grammar, as opposed to other possible specifications such as the framework presented in \citep{Treinen2009}. 
This grammar is described in figure \ref{formal.optbnf}.

\begin{figure}[h!]
\begin{center}
\begin{alltt}
<criteria> ::= <criterion> (, <criterion>)*
\end{alltt}
  \caption{Syntax of the optimisation criteria}
  \label{formal.optbnf}
\end{center}
\end{figure}
This defines a list of \verb+criterion+ with the delimiter \verb+,+ in the form $\langle criterion_1, \ldots, criterion_n \rangle$.
Each criterion is a unique string which expresses a criteria, e.g. $criterion_1 = \langle rank_1, \leq_1 \rangle$.
The criteria are then composed lexicographically into a single criterion $\langle rank_L, \leq_L \rangle$, 
where $criterion_1 \oplus \ldots \oplus criterion_n = \langle rank_L, \leq_L \rangle$. 
This can then be used to create the optimality order $\prec_{\alpha}$ as described in definition \ref{formal.defcrittooptimal}.

\subsubsection{Example}
An example of how to use this mapping for a practical problem can be extracted from the above CUDF document example presented in figure \ref{formal.CUDFEXAMPLE}.
In this example, the component system $\alpha_{t-1}$ was  $\{syslib_1\}$, and there were three possible solutions
\begin{itemize}
  \item $\alpha_t^1 = \{syslib_2, textEditor_1, spellChecker_1\}$,
  \item $\alpha_t^2 = \{syslib_2, textEditor_1, tpspeller_1\}$,
  \item $\alpha_t^3 = \{syslib_2, textEditor_1, spellChecker_1, tpspeller_1\}$
\end{itemize}

The criteria to select a solution could be defined by minimising the change to the solution, then minimising the total size of the components.
For this, first two criteria are defined as $crit_{change} = \langle rank_{change}, \leq_{change} \rangle$ and $crit_{size} = \langle rank_{size}, \leq_{size} \rangle$.

The criterion $crit_{change}$ is represented by the string \verb+-change+ in MOF.
$rank_{change}$ is defined as the cardinality of the symmetric difference between systems, i.e. $rank_{change}(\alpha,\beta) = |\alpha \Delta_t \beta|$.
The order $\leq_{change}$ is defined as $>$ over natural numbers, as less change is better. 

The criterion $crit_{size}$ is represented by the string \verb+-size+ in MOF.
$rank_{size}$ is defined as the sum of the property \verb+size+ of all components in the  proposed system, i.e. $rank_{size}(\alpha,\beta) = \sum_{c \in \beta} c$.\verb+size+.
The order $\leq_{size}$ is defined as $>$ over natural numbers, as a smaller system is better. 

For the MOF string \verb+-change,-size+, the resulting criteria would be $crit_{change} \oplus crit_{size} = \langle rank_L, \leq_L \rangle$, as shown in definition \ref{formal.defcritlex}.
This rank function applied to the possible solutions return in:
\begin{itemize}
  \item $rank_L(\alpha_{t-1},\alpha_t^1 ) = (4, 1)$
  \item $rank(\alpha_{t-1},\alpha_t^2 ) = (4, 2)$
  \item $rank(\alpha_{t-1},\alpha_t^3 ) = (5, 3)$
\end{itemize}
The order of these ranks over $\leq_L$ is then $rank(\alpha_{t-1},\alpha_t^3) \leq_L rank(\alpha_{t-1},\alpha_t^2) \leq_L rank_L(\alpha_{t-1},\alpha_t^1)$.
Therefore, the order of optimality ($\prec_{\alpha_{t-1}}$) over the possible solutions is $s_3 \prec_{\alpha} s_2$, $s_3 \prec_{\alpha} s_1$, and $s_2 \prec_{\alpha} s_1$,
which makes $s_1$ the optimal solution, as no other solution is greater. 

\section{Summary}
In this chapter the formal model of component system evolution was presented.
This evolution process was formally defined as the iterative application of an evolution step function,
which is defined to return an optimal solution to an evolution problem.
CUDF was used to represent an evolution problem, and MOF used to represent the criteria to select an optimal solution.
With these tools component system evolution can be studied, and automated.

In the following chapters, the implementation and strategies used to evolve a component system will be further discussed.
This will bring the ideas and concepts presented in this chapter to a concrete level, and show the practical challenges and benefits of automated component dependency resolution. 