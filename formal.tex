\chapter{Formal Model of Component System Evolution}
\label{formal}
\epigraph{In theory there is no difference between theory and practice. In practice there is.}
{\textit{Jan L. A. van de Snepscheut}}
In order to facilitate the study of the component system evolution process, a formal model has been developed.
Having such a model defines concepts and enables the discussion and investigation of component system evolution.

The component evolution process is modeled as a repetitive selection of solutions to evolution problems.
The two distinct parts of this model are the evolution problem, and the solution selection.
These are presented in sections \ref{formal.step} and \ref{formal.opt} respectively.

To represent an evolution problem and the criteria through which a solution is selected,
the Common Upgradeability Description Format (CUDF) \citep{treinen2009common}
and the Mancoosi Optimisation Format\footnote{http://www.mancoosi.org/misc-2011/criteria/ accessed 6/3/2012} (MOF) are used.
Both CUDF and MOF are presented and mapped to the formal model in section \ref{formal.cudf}. 

\section{Formal Model of Component System Evolution}
\label{formal.step}
Consider the problem where a user wants to install a text editor component into their system.
The selected text editor has a dependency on a spell checker;
meaning that a spell checker component must be installed for the text editor to be functional.
There are three spell checker components available that satisfy this dependency.
This means that at least one of these spell checkers must be selected for installation as well.
How can the user select which spell-checker to install? 

A formal model that can describe such evolution problems is presented in this section.

\subsection{Evolution Problem}
In this section a series of definitions are presented that make up the model of component system evolution.

%%%What a component is
First a component is must be defined.
\begin{defs}
\label{formal.componentdef}
Let $\mathcal{N}$ be the set of names, and $\mathcal{V}$ be the set of versions \footnote{Names and versions are finite alphanumeric sequences which can contain special some characters like ``.'' and ``-''}; 
a \textbf{component}\footnote{In recursive component models, such as Fractal \citep{Quma2006}, the definition ``component'' would include the concept of a composite component.
A composite component $c$ is defined as a set of components, i.e. $c \subseteq \mathbb{C}$.
This definition is not included in this model, though it may be possible to be modified to include it if required.} 
is in $\mathbb{C}$, where $\mathbb{C} = \mathcal{N} \times \mathcal{V}$. 
\end{defs}
The characters  $a,b,c$ are used to denote components, $m,n,o$ used to denote names, and $v,w,x$ used to denote versions.
A component $a$ is then a pair $\langle n,v \rangle$, where $n$ is its name and $v$ is its version.

\begin{defs}
\label{formal.componentsystemdef}
A \textbf{component system} is a finite subset of components, e.g. $\alpha$ is a component system and $\alpha \subseteq_{finite} \mathbb{C}$. 
\end{defs}
The characters $\alpha,\beta,\gamma$ are used to denote component systems.

Constraints are used to restrict possible system.
\begin{defs}
\label{formal.constraintdefs}
A \textbf{constraint} is a finite set of component systems, e.g. $con$ is a constraint and $con \subseteq_{finite} 2^{\mathbb{C}}$.
\end{defs}

Only certain types of constraints are allowed in this model, these types are:
\begin{enumerate}
  \item $\neg a := \{\alpha \in 2^{\mathbb{C}} \mid a \not \in \alpha \}$ \label{formal.removeconstraint}.
  \item $a \rightarrow \neg c := \{\alpha \in 2^{\mathbb{C}} \mid \mbox{if } a \in \alpha \mbox{ then } c \not \in \alpha\}$ \label{formal.conflictconstraint}.
  \item $a_1 \vee \ldots \vee a_n := \{\alpha \in 2^{\mathbb{C}} \mid a_1 \in \alpha \mbox{ or }\ldots \mbox{ or } a_n \in \alpha\}$ \label{formal.keepconstraint}.
  \item $a \rightarrow c_1 \vee \ldots \vee c_n := \{\alpha \in 2^{\mathbb{C}} \mid \mbox{if } a_1 \in \alpha \mbox{ then }  c_1 \in \alpha \mbox{ or } \ldots \mbox{ or } c_n \in \alpha\}$ \label{formal.dependencyconstraint}.
  \item $a_1 + \ldots + a_n = 1 := \{\alpha \in 2^{\mathbb{C}} \mid |\{a_1,\ldots,a_n\} \cap \alpha| = 1\}$ \label{formal.upgradeconstraint}.
\end{enumerate}
The set of constraints is restricted to these types as only these are necessary to represent component relationships, and user requests. 

\begin{defs}
\label{formal.constraintdefs}
A component system $\alpha$ \textbf{satisfies} a constraint $con$, iff $\alpha \in con$.
\end{defs}

\begin{defs}
An \textbf{evolution problem} $EP$ is a finite set of constraints.
\end{defs}

\begin{defs}
A \textbf{solution} $\alpha$ to an evolution problem $EP$ is a component system that is satisfies all constraints in the evolution problem, i.e. $\alpha \in con_i$ for all $con_i \in EP$.  
\end{defs}

\begin{defs}
An evolution problem is \textbf{unsatisfiable} if there exists no solution to it.  
\end{defs}


\subsubsection{Example}
Consider the evolution problem $EP = \{con_1,con_2\}$
$con_1$ is $b$ (type \ref{formal.keepconstraint}), which is the set of all component system with $b$ in them.
$con_2$ is $a \rightarrow c$ (type \ref{formal.dependencyconstraint}), which is the set of all component systems where if $a$ is included, then $c$ is included.
The intersection of these two constraints includes the solutions $\{a,b,c\}$ and $\{a,b,c,d\}$.

Given an evolution preference order, $\prec$, that is defined to prefer less components in the system, $\{a,b,c,d\} \prec \{a,b,c\}$.
As there are no solutions to $EP$ with less components than the solution $\{a,b,c\}$, $\{a,b,c\}$ is the optimal solution.

\subsubsection{Component System Evolution is NP-Complete}
Finding a solution that satisfies all constraints in an evolution problem can be shown to be NP-Complete \citep{cook1971}.
This is accomplished by mapping the finding of a solution to an evolution problem to a known NP-Complete problem called one-in-three satisfiability.
This problem is defined by \cite{Schaefer1978} as:
\begin{quote}
Given sets $S_1, \ldots, S_n$ each having at most 3 members, is there a subset $T$ of the members such that for each $i$, $|T \cap S_i|  =  1$.
\end{quote}

This can be mapped to an evolution problem where:
\begin{quote}
Given constraints $con_1,\ldots,con_m$, each of the type  $a_1 + \ldots + a_n = 1$ where $n = 3$, is there a solution $\alpha$ where for each $i$, $|\alpha \cap con_i|  =  1$
\end{quote}
This describes a problem formed by constraints of type \label{formal.upgradeconstraint}, where each constraint contains three components.
This mapping shows that an evolution problem can be NP-Complete.

\subsection{Constraints, Relationships, and Requests}
\label{formal.constraints}
An evolution problem is made of two sets of constraints; constraints created from relationships between components, 
and constraints created by the request the user has made to change the system.

\begin{defs}
The \textbf{component relationship} constraints $R$ is a set of constraints.
\end{defs}

\begin{defs}
The \textbf{user request} constraints $\Delta$ is a set of constraints.
\end{defs}
An evolution problem is then defined as $EP = R \cup \Delta$.

%%%Component realtionships constraints
The constraints in $R$ can be either: 
\begin{itemize}
  \item \textbf{keep} constraint of type \ref{formal.keepconstraint}, where $a \vee b$ mean keep component $a$ or $b$ in the system.
  \item \textbf{dependency} constraint of type \ref{formal.dependencyconstraint}, where $a \rightarrow b \vee c$ means $a$ depends on component $b$ or $c$.
  \item \textbf{conflict} constraints of type \ref{formal.conflictconstraint},  where $a \rightarrow \neg b$ means $a$ conflicts with component $b$.
\end{itemize}
These constraints are expressive enough to describe many of the relationships from the component models described in section \ref{background.models}.

%%%Change constraints
The constraints in $\Delta$ can be either:
\begin{itemize}
  \item an \textbf{installation} request constraint of type \ref{formal.keepconstraint}, where $a \vee b$ is a request by the user to install component $a$ or $b$ into the system.
  \item a \textbf{remove} request constraint of type \ref{formal.removeconstraint}, where $\neg a$ is a request by the user to remove component $a$ from the system.
  \item an \textbf{upgrade} request constraint of type \ref{formal.upgradeconstraint}, where $a + b = 1$ is a request by the user to upgrade a component to either $a$ or $b$.
\end{itemize} 
The upgrade constraint is used to state that exactly one component from a set of more ``up-to-date'' components, should be installed.


\subsection{Component System Evolution}
\label{formal.evo}
A component system is evolved from one system to another in response to a user requesting it to be changed.
The resulting system must satisfy the comopnent relationship constraints, and the user request.
\begin{defs}
\textbf{Component system evolution} is the changing of a component system $\alpha$, to a component system $\beta$.
given a users request $\Delta$, $\alpha \frac{\leadsto}{\Delta} \beta$, where $beta$ satisfies $R \cup \Delta$.
\end{defs}


The concept of time must be introduced into this model, where:
\begin{itemize}
  \item $\mathbb{C}_t$ is the set of components that exist at time $t$, i.e. $\mathbb{C}_t \subseteq \mathbb{C}$.
  \item The \textit{component relationship} constraints $R_t$ is a set of constraints at time $t$, where $con \in R_t \Rightarrow con \subseteq 2^{\mathbb{C_t}}$.
  \item The \textbf{user request} constraints $\Delta_t$ is a set of constraints at time $t$, where $con \in \Delta_t \Rightarrow con \subseteq 2^{\mathbb{C_t}}$.
  \item An \textit{evolution problem} $EP$ at time $t$, is defined as $EP_t = R_t \cup \Delta_t$.
\end{itemize}

As there may be many solutions to a given evolution problem, a preference over which solution to select can be defined.
This order may be over which changes are preferred, therefore the order must be with respect to the current component system. 
\begin{defs}
The \textbf{evolution preference order} is defined as $\prec: 2^{\mathbb{C}} \times 2^{\mathbb{C}}$.
\end{defs}

\begin{defs}
Given an evolution problem $EP$ and an evolution preference order $\prec$, 
an \textbf{optimal solution} is a solution $\beta_1$ to $EP$, where there is not other solution $\beta_2$ to $EP$ such that $\beta_1 \prec \beta_2$.
\end{defs}
That is, a solution is optimal if there does not exist another, more preferred solution.

\begin{defs}
The \textbf{installed system} $\alpha_t$ is the component system installed at time $t$.
\end{defs}

When evolving a system, the change of the system may effect the preference of the resulting system.
Therefore, the evolution preference order may be defined with respect to the installed system.
\begin{defs}
Given the installed system $\alpha_t$, the \textbf{evolution preference order} $\prec$, is defined with respect to the installed system, i.e. $\prec_{\alpha_t}$
\end{defs}

This iterative application of the evolutionary step function results in a series of installed systems.
The evolutionary step function is instigated by the user requesting to change their system.
\begin{defs}
Given a series of user requests $\Delta_{t_1},\ldots \Delta_{t_n}$ that occur at times $t_1,\ldots t_n$, 
the \textbf{evolution step} function $E$, changes an installed component system to satisfy a users request to change,
i.e. $E(\alpha_{t_{i-1}}, R_{t_i} \cup \Delta_{t_i}) = \alpha_{t_i}$ given the preference order $\prec_{\alpha_{t_{i-1}}}$.
\end{defs}

\begin{defs}
The \textbf{initial system}, $\alpha_{t_0}$, could either be a system with no components, or a system that is a pre-defined configuration of components.
\end{defs}

A caveat to the evolutionary step function occurs if it is unsatisfiable.
A practical solution to resolve this situation is:
Given an evolutionary problem $EP_t$, and the installed system $\alpha_{t_{i-1}}$, if $EP_{t_i}$ is unsatisfiable, then $E(\alpha_{t_{i-1}},EP_{t_i}) = \alpha_{t_{i-1}}$.

Another caveat to this process is that a users change request should not be undone with subsequent generations.
For example, if at time $t_1$ the user requests to install component $a$, then future generations should not remove $a$.
This could be represented as a hard constraint, where an evolution problem contains all previous user requests.
That is, $EP_{t_i} = R_{t_i} \cup \Delta_{t_i} \cup \Delta_{t_{i-1}} \cup \ldots \cup \Delta_{t_{0}}$.
This, however, can create an unsatisfiable evolution problems, as a users requests will often conflict.
Another way to ensure the maximum amount of previous requests are resolved would be to give the evolutionary preference order this responsibility.

\subsubsection{Example}
%%%This makes a sometimes counter intuitive complexity
The selection of an optimal solution to an evolutionary step, may not be optimal when considering generational evolution.

This can be demonstrated with an example:
Let the evolutionary preference order select solutions with the minimum number of components altered (the symmetric difference between the solutions), 
i.e. $\beta \prec_{\alpha} \beta'$ iff $|\alpha \Delta \beta| > |\alpha \Delta \beta'|$.
Let the initial system $\alpha_0 = \{\}$.
Let a series of user requests be $\Delta_1 = \{a\}$ and $ \Delta_2 = \{d\}$. 
Let the set of constraints $R_1 = R_2 = \{a \rightarrow b_1 \vee b_2, b_1 \rightarrow \neg b_2, b_2 \rightarrow c, d \rightarrow b_2\}$.

Consider component evolution from generation $\alpha_0$ to $\alpha_2$;
\begin{itemize}
  \item $\alpha_0 = \{\}$
  \item $\alpha_1 = E(\alpha_0,EP_1)$, given the preference order $<_{\alpha_0}$. $|\alpha_0 \Delta \{a,b_1\}| = 2$ is optimal, therefore $\alpha_1 = \{a,b_1\}$.
  \item $\alpha_2 = E(\alpha_1,EP_2)$, given the preference order $<_{\alpha_1}$. $|\alpha_1 \Delta \{a,b_2,c,d\}| = 4$ is optimal, therefore $\alpha_2 = \{a,b_2,c,d\}$.
\end{itemize}

From $\alpha_0$ to $\alpha_1$ components $a$ and $b_1$ are added, 
and from $\alpha_1$ to $\alpha_2$ components $b_1$ is removed, and $b_2$, $c$ and $d$ are added.
The total change across the generations is therefore $6$.
This is not the global minimal change.
If $\alpha_1 = \{a,b_2,c\}$, and $\alpha_2 = \{a,b_2,c,d\}$, the total change would be $4$.
This shows that although the evolution step function returned locally optimal solutions,
the global perspective across generations of systems was not optimal.

\section{Optimal Component System Selection}
\label{formal.opt}
%%%The formal definition of how to evolve a component system is complicated because it is a multicriteria problem
Any requested evolution of a component system can have many different possible resulting systems \citep{leBerre2010}.
This is because the problem is generally under-constrained \citep{Berre2008}, allowing multiple systems to satisfy evolution problems.
The order $\prec_{\alpha}$ is used to define a preference over the possible systems to select from.

%%%This is a multi criteria problem
By looking at the previously presented CDR implementations in chapter \ref{background} (such as Eclipse P2, apt-get, aptitude, and MPM), some requirements for the preference order have be extracted:
\begin{itemize}
  \item Multiple criteria to select an optimal solution.
  \item Different criteria may have different domains to be optimised for (e.g. versions, choices, components, age).
\end{itemize} 

%%%A naive solution is to map all criteria to real numbers, then aggregate them through addition multiplication with weights.
A naive way to create a preference order with these requirements is to create a function for each criteria that takes a component system and returns a real number.
Then for each possible solution the function is applied to return a value, which is then aggregated through addition or multiplication (possibly with weights).
The optimal system is then the system that returns the maximum (or minimum) real value. 

%%%This has draw backs, some criteria are infinitly more important, it is not intuitive for users to weight.
This method has some drawbacks; information is lost in the conversion to real numbers, e.g. the reason why a specific system was selected over another.
The relationships between criteria are also difficult to intuitively define.
Altering weights to express preference does not convey meaningful information about decisions or their impact.
For example, stating ``size is $.25$ more important than version'' is difficult to understand as versions and size are in two separate domains, 
and greater versions but smaller size is considered better.

%%%Using composed orders
A possibly more intuitive approach to this problem is to define an order for each criterion.
Then, an overall optimal order ($\prec_{\alpha}$) can be define by composing the different orders together using the lexicographic order.
This order is used to express that optimising one criteria is more important than another. 
This composition lets the user assign a preference to each criteria, without having to assign arbitrary weights.
This method is used in the MPM \citep{abate2011} CDR implementation, and will be presented in this section.

\subsection{Criteria and Lexicographic Composition}
In this section a criterion and the lexicographic composition of criteria are formally defined.

\begin{defs}
A \textbf{ranking function}, $rank$, is a function that takes two component systems and return a value in the set $A$, i.e. $rank : 2^{\mathbb{C}} \times 2^{\mathbb{C}} \rightarrow A$.
\end{defs}
A ranking function measures the change from a previous system to the range $A$.

\begin{defs}
\label{formal.defcriteria}
A \textbf{criterion} is a tuple $\langle rank, \leq \rangle$, where $rank$ is a ranking function, and $\leq$ (whose strict order is $<$) is a partial order over $A$.
\end{defs}
The order $\leq$ is a partial order, which is defined to be reflexive ($a \leq a$), antisymmetry ($if a \leq b and b \leq a then a = b$), and transitive ($if a \leq b and b \leq c then a \leq c$).

\begin{defs}
\label{formal.defcrittooptimal}
The \textbf{evolution preference order} $\prec_{\alpha}$ is defined given a criterion $\langle rank, \leq \rangle$, 
iff $rank(\alpha,\beta_1) < rank(\alpha,\beta_2)$ then $\beta_1 \prec_{\alpha} \beta_2$.
\end{defs}
The evolution preference order, is described with respect to a criterion.


\begin{defs}
\label{formal.defcritlex}
The \textbf{lexicographic composition} multiple criteria into a single criterion is defined with the operator $\oplus$.
Let the two criteria $crit_1 = \langle rank_1, \leq_{1} \rangle$, and $crit_2 = \langle rank_2, \leq_{2} \rangle$,
where the range of $rank_1$ is $A_1$, and the range of $rank_2$ is $A_2$.
The lexicographical composition of $crit_1$ and $crit_2$, $crit_1 \oplus crit_2$, equal the criterion $\langle rank_L,\leq_L \rangle$.
The range of $rank_L$ is $A_1 \times A_2$, and $rank_L(\alpha,\beta) = (rank_1(\alpha,\beta),rank_2(\alpha,\beta))$.
The order $\leq_L$ (whose strict order is $<_L$) is over $A_1 \times A_2$, such that $(a,b) \leq_L (a',b')$ iff $a <_1 a'$ or $(a = a'$ and $b \leq_2 b')$.
\end{defs}
$rank_L$ takes two component systems and returns a value in the set $A_1 \times A_2$, making it a ranking function.
The order $\leq_L$ is a partial order \citep{Schroder2003} over $A_1 \times A_2$.
Therefore, the tuple $\langle rank_L,\leq_L \rangle$ is a criterion.

The composition of multiple criteria, results in a criterion, which can be used to define the evolution preference order $\prec_{\alpha}$.

In section \ref{formal.mancoosioptimisationformat} a syntax to describe the composition of criteria is defined. 
In chapter \ref{implementation} an algorithm to find optimal solutions to such criteria is described.
In chapter \ref{strategies} various criteria are defined that fit within this framework.

\section{Common Upgradeability Description Format and Mancoosi Optimisation Format}
\label{formal.cudf}
%%%The description of the represnation of CUDF is described.
The Common Upgradeability Description Format (CUDF) specification presented by \citep{treinen2009common} is used as the syntax to represent evolution problems.
This specification was previously discussed in section \ref{background.models}, where an example of its meta-data was shown in figure \ref{CUDFmetadata}.
The Mancoosi Optimisation Format (MOF)\footnote{http://www.mancoosi.org/misc-2011/criteria/ accessed 6/3/2012}, is used as the syntax to define the evolution preference order.

CUDF and MOF were created to be an abstract representation of evolution problems and evolution preference order, to allow the comparison of various solvers.
CUDF and MOF were a success, in this respect.
The Mancoosi International Solver Competition (MISC)\footnote{http://www.mancoosi.org/misc/ accessed 6/3/2012} was held in both 2010 and 2011,
which compared various state of the art, and legacy, solvers that had been modified to solve CUDF problems with MOF preference order.

%%%In this section\ldots
In this section the design principles and requirements of CUDF are described.
A brief overview of a CUDF document is then presented.
The CUDF specification of the syntax of CUDF is then described, this will not cover all aspects of the CUDF specification, for instance the extensive type system of CUDF is left out.
The defined CUDF syntax is then mapped to our model of the a component system evolution through the constraints that have been defined.
This includes some minor extensions to the presented definition in section \ref{formal.step}.
Finally, the Mancoosi format for specifying optimisation criteria, denoted as MOF, is discussed.

\subsection{CUDF Design}
The Mancoosi organisation is a research project whose area is the improvement to the upgrading of Free and Open Source Software (FOSS) distributions.
This upgrade problem is the same problem defined in this chapter, the evolution of a component system.
Mancoosi looks at a broad area within this domain, and has made many contributions in the area.

One of these contributions was to organise a competition between competing solutions of the evolution problems of FOSS systems.
This was beneficial as it would encourage researchers and practitioners into researching the evolution problem.

An initial problem faced in organising such a competition is a format in which the competition could represent the upgrade problem.
The design of this format would have to follow some design principles to ensure the results would be useful.
These principles are presented in \citep{treinen2009common}, summarised as:

\begin{itemize}
  \item \textbf{Agnostic towards component model details}: 
  The specific component model and the implementation chosen to solve the problem, should be abstracted as to allow many problems and solutions to be used  
  \item \textbf{Stay close to the original problem}: 
  The original problem is still the focus of this research, therefore the format should not abstract so far as to be unrecognisable. 
  By using similar terms and syntax that already exists within the domain, the format will still directly represent the upgrade problem. 
  \item \textbf{Preserve the ability for humans to inspect encoded problems}:
  The analysis and design of a specific problem should be able to be directly accomplished through manual investigation.
  This will allow greater testing and debugging, also enable the direct inspection of the problem by researchers for study.
  \item \textbf{Avoid bias towards specific implementations or techniques}:
  Specific encoding of the problem, e.g. using propositional logic, or constraint programming, may create an advantage or disadvantage for a particular technique or solution.
  Since a goal of this research is to encourage the advancement of this area, the format should strive to be independent from any technique or implementation. 
  \item \textbf{Support legacy tools}:
  The comparison to tools that are already in use to solve such upgrade problems is a necessity when determining if this research is advancing the field.
  Ideally, a legacy or current solution should easily be able to be adapted and used with the format.
  Conversely though, the format should not stop state-of-the-art solutions from being used.
  \item \textbf{Extensible}:
  Although the format will attempt to abstract the common elements of the problem, there may still be necessary component model specific details that require inclusion.
  Also, some details are required for the optimisation of the problem, but which are not relevant to the specification of the format.
  The ability to extend the format is then required.
  \item \textbf{Transactional semantics}:
  The format should have the ability to completely represent a problem as a single unit, that can be passed to an implementation for solution.
  Also, the solution passed back should itself be a single unit, of the same format.
  This ignores aspects of the problem such as install order of the components, though this is outside the scope of this research.
  \item \textbf{Plain Text Format}:
  The use of plain text, as opposed to a binary format, will allow it to be human readable, as well as make it easier to parse and write.
  Although plain text may not be the most efficient way to encode a problem, the overhead required to parse other formats may decrease the interest to enter a competition.
  This also aligns with the morals of the community of FOSS developers, where plain text is the universal information interchange format \citep{raymond2003art}.
\end{itemize}

The result of these design goals is the CUDF specification, presented in \citep{treinen2009common}, and presented in the following sections.

\subsection{CUDF Document}
%%%Here the CUDF document is defined using text and trying to stay away from too many formalisms, just describing concepts to be used later
In this section a brief description of the CUDF format is presented.
Some aspects of CUDF are ignored (e.g. the formal type system) as a complete redefinition of the original specification is not the goal of this section.
Where details are removed, or glossed over a reference will be made as to ensure that misinformation is not conveyed. 

A CUDF document is a single plain text file, that represents all information necessary to define an evolutionary step as defined in section \ref{formal.step}.

This document is separated into three sections, the preamble, the package descriptions, and the request.

\begin{itemize}
  \item \textbf{preamble} stanza: Defines the additional types used in the CUDF document
  \item \textbf{package descriptions} stanzas: typically the bulk of a CUDF document, this defines the set of components (using the FOSS term package)
  \item \textbf{request} stanza: this defines the requested evolutionary change that should be made to the components 
\end{itemize}

This structure is presented in figure \ref{formal:cudfstruct}.

\begin{figure}[htp]
\centering
\begin{tabular}{|c|}
\hline preamble \\ \hline
\hline package description$_{1}$ \\ \hline
\hline package description$_{2}$ \\ \hline
 \multicolumn{1}{c}{\ldots}  \\ 
\hline package description$_{i}$\\ \hline
\hline request\\ \hline
\end{tabular}
\caption{Structure of the CUDF stanzas}
\label{formal:cudfstruct}
\end{figure}

Every stanza begins with a key of their type (\verb+preamble+, \verb+package+, \verb+request+), followed by several lines ending in a empty line.
Each stanza line defines a set of properties using key/value pairs separated by the delimiter ``:``, these are in no defined order.
This structure is presented in figure \ref{formal.cudfproperties}

\begin{figure}[htp] 
\begin{center}
\begin{alltt}
\textit{stanza}: \textit{value}
\textit{key_1}: \textit{value_1}
\ldots
\textit{key_n}: \textit{value_n}

\ldots

\textit{stanza}: \textit{value}
\textit{key_1}: \textit{value_1}
\ldots
\end{alltt}
  \caption[CUDF property structure]{Structure of CUDF properties}
  \label{formal.cudfproperties}
\end{center}
\end{figure}

\subsubsection{Package Description}
The package description stanza starts with the \verb+package+ key followed by the value of package name, a non-empty string.
The only mandatory property of this stanza is defined with the key \verb+version:+ who's value is the version of the package, a positive integer.
The pair $\langle name, version \rangle$ of a package is unique, there can exist at most one package description for a given name and version.
This name and version pair is the atomic unit for the CUDF document. 

Some relevant properties for a package are defined by the keys:
\begin{itemize}
  \item \verb+installed+: this Boolean property states whether the package is installed or not in the system. 
  As the CUDF document describes all packages, installed and not, the set of packages with the property \verb+installed: true+ defines the current component system.
  \item \verb+keep+: this property defines the keep constraints as defined in section \ref{formal.step}
  Some possible values\footnote{The keep property can also be assigned feature or none} are:
	  	\begin{itemize}
	  		\item \verb+version+: keep this particular version of the package installed
	  		\item \verb+package+: keep at least one version of this package installed
		\end{itemize}
  \item \verb+provides+: this is a list of names of features or services that this package provides separated by the delimiter ``,''.
  e.g. \verb+provides: a, b, c+ means this package provides the features \verb+a+, \verb+b+ and \verb+c+.
  Each feature name can be accompanied by a version, to state what particular version is provided, e.g. \verb+a=10+ means feature \verb+a+ version \verb+10+ is provided.
  When no version is specified for a feature, it is defined as all versions are provided.
  \item \verb+depends+: this is a list of lists of \textbf{package formulae}, first separated by the delimiter ``,'' then delimiter ``|''.
  The list represents a conjunction of disjunctions (conjunctive normal form), with each formulae defining a set of packages.
  A package is defined using a name of either a package or feature $n$ and optionally an operator and version of the form  $n = v$, $n$ != $v$, $n > v$, $n < v$, $n >= v$, or $n <= v$.
  For example, \verb+depends: a , b | c < 10+ means the package depends on a packages (or features) ``\verb+a+ AND (\verb+b+ OR \verb+c+ less than version \verb+10+)''.  
  \item \verb+conflicts+: is a list of \textbf{package formulae} as defined above separated by the delimiter ``,''.
  For example, \verb+conflicts: a , c > 2+ means this package conflicts with all packages (or features) with the name \verb+a+ AND \verb+c+ greater than the version \verb+2+
\end{itemize}

\subsubsection{Preamble}
The preamble stanza starts with the key \verb+preamble:+, no value is necessary for this key.
The main function of this stanza is to provide the description of addition properties and their types, that can be added to the package descriptions.
This is described under the key \verb+property+ where the value is a list of properties defining their name, type and optionally a default value separated by the delimiter ``,''.
Each additional property of name $n$ and type $t$ and optionally a default value is a pair or triple separated first by ``:'' then ``='' where the default is wrapped in ``['' and ``]''.

For example, \verb+property: size: int, bugs: int = [0]+ defines the integer property of \verb+size+ and the integer property of \verb+bugs+ with the default value \verb+0+.
Given this preamble, package descriptions can now use these properties as shown in figure \ref{formal.cudfextensionexample}.

\begin{figure}[htp] 
\begin{center}
\begin{alltt}
preamble:
property: size: int, bugs: int = [0]

package: textEditor
version: 1
bugs: 10
size: 2
depends: spellCheckerService

\ldots

\end{alltt}
  \caption[Example of Extendable CUDF syntax]{Example of Extendable CUDF syntax}
  \label{formal.cudfextensionexample}
\end{center}
\end{figure}

\subsubsection{Request}
\label{formal.cudfdes.request}
The request stanza starts with the \verb+request:+ key, no value is required for this key.
This stanza contains three properties that define the request to change the system,
each is a list of \textbf{package formulae} separated by the delimiter ``,'' such that:
\begin{itemize}
  \item \verb+install+: is a request to install a set of packages into the system,
  e.g. \verb+install: a, b >= 2+ means install component \verb+a+ and component \verb+b+ of version two or greater.
  \item \verb+remove+: is a request to remove a set of packages from the system 
  e.g. \verb+remove: a , b = 2+ means remove all components with name \verb+a+ and component \verb+b+ of version two.
  \item \verb+upgrade+: is a request to remove all versions of a package and install greater than or equal versions of the package,
  e.g. \verb+upgrade: a+ means to remove all packages of name \verb+a+ and install one package of equal or greater versions to that of the maximum version of \verb+a+ currently installed. 
\end{itemize}

%%%Installation of multiple components
CUDF as a specification mostly resembles the Debian package format, described in section \ref{background.models}.
A significant difference between these two specifications is that the CUDF model does not explicitly state that only one version of a package can be installed.
This is a practical decision as other component models, like Red Hat Package manager and OSGi, allow the installation of multiple versions of the same component.
Although models exist that allow multiple versions of a package to be installed, having multiple versions installed is seen as less optimal as it replicates functionality. 
This is then left up to the optimisation when finding a solution to try to identify solutions with only one version installed per component.

%%%Upgrading with multiple packages
A request to upgrade a component is significantly more complicated than the other requests.
This is partially due to CUDF allowing having multiple versions of the same component installed.
If a package is requested to be upgraded and there are multiple versions of that package installed,
then all but the highest version must be removed, and only one version can remain in the system.
For example, if a system has $a_1$ and $a_2$ installed and it is requested to upgrade $a$,
then $a_1$ must be removed, and either $a_2$ can remain, or $a_2$ can be removed and a higher version of $a$ can be installed.

Given these semantics, requesting to upgrade a component can actually do nothing to the system
For example, is $a$ is requested to be upgraded and the only version of $a$ installed is $a_1$, then the system does not have to change to satisfy the request.
This means that the intuitive request to upgrade a system is left to the optimisation function.
That is, to get newer versions of component installed it is necessary to define an appropriate $rank$ function.

\subsection{CUDF Specification}
In this section, the model presented in section \ref{formal.step} is mapped to this CUDF specification.
The package stanzas are used to define to the current component system $\alpha$ and the component relationship constraints $R$, 
while the request stanza is used to define the user request constraints $\Delta$. 

The first definition is that of the CUDF document, which is made up of three sections; the preamble stanza, a set of package description stanzas, and a request stanza:
\begin{defs}
A CUDF document then is described as $CUDF = \langle preamble, PD, request \rangle$ where $PD$ is the set of package description stanzas.
\end{defs} 
Each stanza is made of a set of properties, where each property is a tuple of key/value, i.e. $stanza = \{\langle $\verb+key+, \verb+value+$\rangle\}$.
This syntax is described in figures \ref{formal:cudfstruct} and \ref{formal.cudfproperties}.

The function $property$ is defined such that it takes a stanza and key and returns a value,
i.e. $property: STANZA \times key \rightarrow value$ such that given a stanza $s$ and key \verb+key+,
$property(s,$\verb+key+$) = $ \verb+value+ where $\langle$\verb+key+, \verb+value+$ \rangle \in s$.

If the key does not exist in the stanza, the default value of the property is returned.
For instance, the default value in a package description stanza for the \verb+installed+ property is defined as \verb+false+;
therefore, if the key \verb+installed+ is not defined in a package description stanza $pd$, then $property(pd,$\verb+installed+$)$ equals \verb+false+.
Further, if a property does not have a defined default value, then $\emptyset$ is returned.

\subsubsection{Preamble}
%%%Description of a basic preamble, as much of the specification is not used
The first stanza of any CUDF document is the $preamble$.
The core goal of this is to define additional properties (and their default values) that can be used to describe a component.
This property definition is accomplished through using an extensively defined type system in CUDF, and has a complete and complicated specification found in \citep{treinen2009common}.
However, as much of this specification is not used in this research only a basic syntax and semantics will be described.
The syntax of the preamble \verb+property+ value is defined in the BNF grammar as \verb+<properties>+ in figure \ref{formal.cudfpropertysyntax}.

\begin{figure}[htp] 
\begin{center}
\begin{alltt}
<properties> ::= <property> ["," <property>]*
<property> :: = <pname> ":" <type> ("=" "["<defaultvalue>"]")?
<type> ::= "int"
\end{alltt}
  \caption{Preamble property syntax}
  \label{formal.cudfpropertysyntax}
\end{center}
\end{figure}

This syntax defines each property as a name, a type and a default value, i.e. $\langle name, type, default \rangle$, where $name = $ \verb+<pname>+, $type = $ \verb+<type>+,
and the $default =$ \verb+<defaultvalue>+. 
In the full CUDF specification there are more types other than \verb+int+, such as \verb+enum+ and \verb+string+,
some having a different syntax than described here.

\subsubsection{Components}
Each component is defined by a name and version, as described in section \ref{formal.step}.
This information is extracted from the package descriptions in a CUDF document.
The function $pd2c$ takes a package description stanza and returns a component, such that $pd2c(pd) = \langle property(pd, $ \verb+name+ $), property(pd, $ \verb+version+ $) \rangle$.
The set of components, $\mathbb{C}$, equals the set of converted package descriptions, i.e. $\mathbb{C} = [ pd2c(pd) \mid pd \in PD]$.

To refer to a property assigned to a component $a$, of the key \verb+key+, it is written $a$.\verb+key+.
That is, $a$.\verb+key+ $= property(pd, $\verb+key+$)$ where $a = pd2c(pd)$.
For example, the name of a component $a$ can be written as $a$.\verb+name+, its version as $a$.\verb+version+.
A component can still be denoted as $n_v$, where $n$ = $a$.\verb+name+ and $v$ = $a$.\verb+version+.

As described above, 
if a request property does not exist for the component, then the default value of that property is returned, and if no default is defined then $\emptyset$ is returned.

A CUDF document not only describes the set of all components, but the set of components that defines the current system.
The set of components in the current system (denoted as $\alpha$) is defined using the key \verb+installed+,
such that, $c \in \alpha$ iff  $c.$\verb+installed+ equals \verb+true+.
That is, only the components whose property \verb+installed+ is set to \verb+true+, are in the current component system.

\subsubsection{Features}
%%%Features or services
CUDF specifies an additional aspect to component relationships, that of a feature or service.
Each component can provide a set of features, where each feature is represented by a name, and a set of versions.
Unlike a component, which has exactly one version, a component can provide multiple versions of a feature.

A feature is then a pair $(n,V)$ where all features are in the set $F$, $n$ is the name of the feature, and $V$ is a subset of positive integers representing versions, i.e $V \subseteq \mathbb{N}$.
The features provided by a component are defined as the property with the key \verb+provides+, 
whose value follows \verb+<provides>+ from the BNF grammar presented in figure \ref{formal.cudfprovidessyntax}.

\begin{figure}[htp] 
\begin{center}
\begin{alltt}
<provides> ::= <feature> ["," <feature>]*
<feature> :: = <fname> ("=" <ver>)?
\end{alltt}
  \caption[Provides syntax]{CUDF Provides syntax}
  \label{formal.cudfprovidessyntax}
\end{center}
\end{figure}

Each feature represented by \verb+<feature>+ is in the form ``\verb+<fname>+'' or  ``\verb+<fname>+ = \verb+<ver>+'', 
which is mapped to a feature $($\verb+<fname>+$,\mathbb{N})$ or $($\verb+<fname>+$,\{$\verb+<ver>+$\})$ respectivly.
That is, a component provides all versions of a feature if a specific version is not defined, and if a version is defined it provides a singleton set of that version.
 
The list of features defined by \verb+<provides>+, in the form ``\verb+<feature>+$_1$,\ldots,\verb+<feature>+$_n$'', can then be mapped to a set of features.
This property is wrapped with the function $providedFeatures$,
such that given a component $c$, $providedFeatures(c)$ equals the set of features mapped from $c$.\verb+provides+.

\subsubsection{Package formula}
A package formula is a query to retrieve a set of components from a CUDF document.
This formula is the mechanism to define all relationships and requests in the CUDF specification.

Each package formula is syntactically defined as \verb+<pkgf>+ in the BNF grammar in figure \ref{formal.cudfpackageformulasyntax}.
This also defines \verb+<pkgname>+ as the package name, \verb+<ver>+ as the package version, and \verb+<relop>+ as a relational operator expressing the constraint of the query.

\begin{figure}[htp] 
\begin{center}
\begin{alltt}
<pkgf> ::= <pkgname> (<relop> <ver>)?
<relop> ::=  "=" | "!=" | ">=" | ">" | "<=" | "<"
\end{alltt}
  \caption[Package Formulae syntax]{Structure of CUDF package Formulae syntax}
  \label{formal.cudfpackageformulasyntax}
\end{center}
\end{figure}

The syntax of \verb+<relop>+ is parsed to a mathematical relation with the function:  
$\{$ \verb+"="+ $\rightarrow$ $=$, \verb+"!="+ $\rightarrow \not =$, 
\verb+">="+ $\rightarrow$ $\geq$, \verb+">"+ $\rightarrow$ $>$, \verb+"<="+ $\rightarrow$ $\leq$, \verb+"<"+ $\rightarrow$ $<$$\}$.
The package formula is in the form ``\verb+<pkgname>+'' or  ``\verb+<pkgname>+ \verb+<relop>+ \verb+<ver>+'',
given \verb+<relop>+ is mapped to $op$, each form is mapped to a triple $\langle $\verb+<pkgname>+$,0,>\rangle$ or $\langle$\verb+<pkgname>+$,op,$ \verb+<ver>+ $\rangle$ respectively.
That is, each package formula is a triple of name, operation and version.
If \verb+<relop>+ and \verb+<ver>+ are not defined, the operation defaults to greater than version 0.

%%%Find all packages which satisfy the package formula
Package formulae (whose set is denoted as $PF$) can be mapped to a set of components through the function $packages: PF \rightarrow 2^{\mathbb{C}}$,
which takes a package formula and returns all packages that conform to its definition.
This is defined as:
\begin{defs}
Given a set of components $\mathbb{C}$ defined in a CUDF document, and a package formulae $\langle n,v,op\rangle$
$packages(\langle n,v,op\rangle) = [\langle n_c,v_c \rangle \mid \langle n_c,v_c \rangle \in \mathbb{C} \mbox{ and } n_c = n \mbox{ and } v_c \mbox{ op } v]$.
\end{defs}
That is, any component whose name is the same as that in the package formulae and whose version is related through the defined $op$ will be included in the set.

%%%Find all packages who provides a feature which satisfies the package formula
A package formula does not distinguish between components and features, so a package formula is also used to search for components providing a feature.
The function $features: PF \rightarrow 2^{\mathbb{C}}$ takes a package formula and returns a set of components that provide the described feature.
\begin{defs}
Given a set of components $\mathbb{C}$ defined in a CUDF document, and a package formulae $\langle n,v,op\rangle$
$features(\langle n,v,op\rangle)$ equals 
$[c \mid c\in \mathbb{C} \mbox{ and } (n,V) \in providedFeatures(c) \wedge \exists v_f \in V \mbox { such that } v_f \mbox{ op } v ]$.
\end{defs}
That is, given a package formula, 
$features$ returns a set of components that provide a feature where the name of the feature is the name in the package formula 
and there exists a version of that feature that satisfies the relation. 

Give the functions $packages$ and $features$ the resolution of a package formula $pf$ can be described as the function 
\begin{defs}
$packagesThatSatisfy(pf) = packages(pf) \cup features(pf)$.
\end{defs}
That is, $packagesThatSatisfy$ takes a package formula and returns a set of packages that either directly satisfy it, or that provide a feature that satisfy the it.

\subsubsection{Relationships}
Given the function $packagesThatSatisfy$, the CUDF document can be mapped to the relationship constraints described in section \ref{formal.step}.

There are three constraints:
\begin{itemize}
  \item keep constraint: derived from the property \verb+keep+ of a package descriptions, only included if the property \verb+installed+ is true.
  \item dependency constraint: derived from the property \verb+depends+ from all package descriptions in a CUDF document.
  \item conflict constraints: derived from the property \verb+conflicts+ from all package descriptions in a CUDF document.
\end{itemize}

\paragraph{Keep Constraint}
The keep constraint states that a system should maintain either a specific package, or a version of a package in the system.
In the CUDF specification only the keep constraints of installed components are considered.

The function $keeppf$ is defined to take a component and to return a package formula such that can be used to create a keep constraint.
Given a component $\langle n,v \rangle = c$, $keeppf$ is defined such that:
\begin{itemize}
	\item if $c$.\verb+keep+ equals \verb+version+: $keeppf(c) = \langle n, =, v \rangle$
	\item if $c$.\verb+keep+ equals \verb+package+: $keeppf(c) = \langle n, >, 0 \rangle$
\end{itemize}

A keep constraint, of the form $c_1 \vee \ldots \vee c_n$, for a package is then created using the function $keep$,
where $keep(c) = \bigvee packages(keeppf(c))$.
That is, the package formula from $keeppf$ is used to query for a set of packages whose disjunction forms the keep constraint.
This creates a constraint to ensure one of the resulting components to be included in the system.

To create the set of all keep constraints, all installed packages must be mapped to the function $keep$.
Given a set of components $\mathbb{C}$ defined in a CUDF document, 
the set of components $\alpha$ which denotes all installed components, is used to create the set of keep constraints $\bigcup \limits_{c \in \alpha} keep(c)$.

\paragraph{Dependency Constraint}
The dependency constraints of a set of components $\mathbb{C}$ defined in a CUDF document are mapped using the property key \verb+depends+,
whose syntax is defined as \verb+<depends>+ from the BNF grammar presented in figure \ref{formal.cudfdependssyntax}.

\begin{figure}[htp] 
\begin{center}
\begin{alltt}
<depends> ::= <pkgflist> ("," <pkgflist>)*
<pkgflist> ::= <pkgf> ("|" <pkgf>)*
\end{alltt}
  \caption[CUDF Package depends syntax]{Structure of CUDF depends syntax}
  \label{formal.cudfdependssyntax}
\end{center}
\end{figure}

This syntax shows that the depends property is a list of package formula (as defined in figure \ref{formal.cudfpackageformulasyntax}) lists, 
first separated by the delimiter ``,'' then by the delimiter ``|''.
Each package formula list maps to a single dependency constraint, as described in section \ref{formal.step}.

The syntax of a \verb+<pkgflist>+ is in the form ``\verb+<pkgf>+$_1$ | \ldots | \verb+<pkgf>+$_n$'', where \verb+<pkgf>+$_i$ maps to $pf_i$.
Each \verb+<pkgflist>+ then maps to a set of package formulae $pkgflist$ such that $pkgflist = \{pf_1,\ldots, pf_n\}$.

The property \verb+<depends>+ is then of the form ``\verb+<pkgflist>+$_1$ ,\ldots, \verb+<pkgflist>+$_n$'', where \verb+<pkgflist>+$_i$ maps to a set of package formulae $pkgflist_i$. 
The property \verb+<depends>+ is mapped to a set of sets of package formulae $listpkgflist = \{pkgflist_1,\ldots,pkgflist_n\}$.

The function $dependsOn$ is then defined such that it takes a component and a package list to create a single dependency constraint of the form $a \rightarrow c_1 \vee \ldots \vee c_n$,
as defined in section \ref{formal.step}.
Given a component $a$ and a package list $pkgflist$, 
$dependsOn(a,pkgflist)$ equals the constraint $a \rightarrow \bigvee  \bigcup \limits_{pkgf \in pkgflist} packagesThatSatisfy(pkgf)$.
That is, $dependsOn(a,pkgflist)$ is $a$ implying the disjunction of the union of all components that satisfy a contained package formula to create the dependency constraint. 

The function $depends$ is then defined to return a set of all dependency constraints for a component.
Given a component $a$, the set of sets of package formulae mapped from $a$.\verb+depends+ denoted as $listpkgflist$,
$depends(a)$ is defined to equal $\bigcup \limits_{pkgflst \in listpkgflist} dependsOn(a,pkgflst)$.
That is, the set of dependency constraints for a given component is the union of all constraints created from individual \verb+depends+ properties.

Finally, the set of all dependency constraints is defined given the set of all components $\mathbb{C}$ defined in a CUDF document,
such that the set of dependency constraints equals $\bigcup \limits_{c\in \mathbb{C}} depends(a)$.

\paragraph{Conflict Constraint}
The conflict constraints of a given component defines the relationship where it will not be functional with another component in the system.
The syntax of the \verb+conflicts+ property value is defined as \verb+<conflicts>+ and is presented in figure \ref{formal.cudfconflictsyntax}.

\begin{figure}[htp] 
\begin{center}
\begin{alltt}
<conflicts> ::= <pkgf> ("," <pkgf>)*
\end{alltt}
  \caption[CUDF Package conflicts syntax]{Structure of CUDF conflicts syntax}
  \label{formal.cudfconflictsyntax}
\end{center}
\end{figure}

This syntax is the same as defined above in the depends property syntax for \verb+<pkgflist>+ except it uses a different delimiter. 
The mapping is also the same, where the property value is in the form \verb+<pkgf>+$_1$ , \ldots , \verb+<pkgf>+$_n$ and maps to a set of package formulae $conflictPkgF$.

Given a component $a$ and the set $conflictPkgF$ that is mapped from the $a$.\verb+conflicts+;
the function $conflictsWith$ is defined to return a set of conflict constraints where each constraints is in the form $a \rightarrow \neg c$, as defined in section \ref{formal.step}.
This function is defined as, 
$conflictsWith(a) = [a \rightarrow \neg c \mid c \in packagesThatSatisfy(pf) \mbox{ and } pf \in conflictPkgF \mbox { and } c \not = a]$.
That is, a component conflicts with any component that satisfies a package formula defined in its \verb+conflicts+ property,
with the exception that it cannot conflict with itself.
This final caveat of a CUDF conflict is directly taken from the Debian package specification \citep{Barth2005}, 
as it allows a package to declare a conflict with itself and this forces similar packages to be removed if it is installed.  

Finally, given the $\mathbb{C}$ is the set of all components in a CUDF document,
the set of all conflict constraints for a CUDF document is defined as $\bigcup \limits_{c\in \mathbb{C}} conflicts(a)$.

\paragraph{Union}
Given a set of components $\mathbb{C}$, the set of currently installed components $\alpha$, 
the set of all relationship constraints, $R$, is the union of the keep, depends and conflicts constraints defined above.
That is, 
\begin{defs}
$R = \bigcup \limits_{c \in \alpha} keep(c) \cup \bigcup \limits_{c\in \mathbb{C}} depends(a) \cup \bigcup \limits_{c\in \mathbb{C}} conflicts(a)$.
\end{defs}

\subsubsection{Request}
\label{formal.cudf.request}
In a CUDF document there exist exactly one request stanza, which has three optional properties \verb+install+, \verb+remove+ and \verb+upgrade+ respectively.
Each value for these properties has the same syntax, shown in figure \ref{formal.requestssyntax}.

\begin{figure}[htp] 
\begin{center}
\begin{alltt}
<install> ::= <pkgflist>
<remove> ::= <pkgflist>
<upgrade> ::= <pkgflist>
<pkgflist> ::= <pkgf> ("," <pkgf>)*
\end{alltt}
  \caption[CUDF Package conflicts syntax]{Structure of CUDF conflicts syntax}
  \label{formal.requestssyntax}
\end{center}
\end{figure}

The syntax of \verb+<pkgflist>+ is exactly the same defined above for the conflicts property, and can be mapped to the set of package formulae $pkgflist$.
The \verb+install+ property maps to the package formulae set $installpkgflist$; the \verb+remove+ property maps to the package formulae set $removepkgflist$;
the \verb+upgrade+ property maps to the package formulae set  $upgradepkgflist$.

\paragraph{Install}
An install constraint is of the form $a_1 \vee \ldots \vee a_n$,
this is defined semantically as $a_1 \in E_{R \cup \Delta}(\alpha)$ or \ldots or $a_n \in E_{R \cup \Delta}(\alpha)$.

The function  $install(pf)$ is defined to take a package formula $pf$ and return one install constraint such that $\bigvee packagesThatSatisfy(pf)$.
Each package formulae in the set $installpkgflist$ creates one install constraint,
therefore the set of all install constraints is defined as $\bigcup \limits_{pf \in installpkgflist} install(pf)$.

\paragraph{Remove}
A remove constraint is of the form $\neg a$,
this is defined semantically as $a \not \in E_{R \cup \Delta}(\alpha)$.

The function $remove(pf)$ is defined to take a package formula $pf$ and returns a set of remove constraints such that $[\neg a \mid  a \in packagesThatSatisfy(pf)]$.
Then the set of remove constraints is the union of all constraints created from the $removepkgflist$ set, i.e. $\bigcup \limits_{pf \in removepkgflist} remove(pf)$.

\paragraph{Upgrade}
%%%This is a difficult to express
The upgrade semantics of CUDF are the most difficult to express, this is because of the complicated relationships it causes as discussed in section \ref{formal.cudfdes.request}.
The upgrade semantics of CUDF state that two constraints must be satisfied for each package formula $pf$ in $upgradepkgflist$:
\begin{enumerate}
  \item exactly one package that satisfies $pf$ is in the system
  \item no packages with a lesser version than the highest currently installed component with the name from $pf$ can be included.
\end{enumerate} 

The first upgrade constraint is the cardinality constraint of the form $a_1 + \ldots + a_i = 1$, as described in section \ref{formal.step}.
Given the package formula $pf$, the function $upgrade_1$ is defined to return an upgrade constraint,
such that $upgrade_1(pf) = \bigoplus packagesThatSatisfy(pf) = 1$.
That is, each package that satisfies the package formula is included in the cardinality constraint.

The second type of constraint is of the form $\neg a$, defined as the removal constraint described in section \ref{formal.step}.
To create the required constraints some utility functions $named$ and $maxversion$ are defined.

\begin{defs}
Given the a set of components $\beta$ and the package name $n$ the set of packages in $\beta$ of the name $n$ is returned by the function $named$, such that
$named(\beta,n) = \beta \cap packagesThatSatisfy(\langle n,0,> \rangle)$.
\end{defs} 

\begin{defs}
Given a set of components and a name $n$ the function $maxversion(\beta,n)$ returns the integer $c$.\verb+version+ 
such that $c \in named(\beta,n)$ and $\nexists c' \in named(\beta,n)$ where $c'$.\verb+version+ $> c$.\verb+version+.
\end{defs}
That is, $maxversion(\beta,n)$ returns the highest version of any component with a name $n$.

Given the name $n$ and a set of component $\beta$, the set of components that are below this maximum version of $n$ in $\beta$ is defined as:
$packagesThatSatisfy(\langle n, maxversion(\beta,n), < \rangle)$
So to satisfy the second constraint of the upgrade request to have no package installed with the same name but lesser version that the highest currently installed version,
the function  $upgrade_2$ is defined as:
\begin{defs}
Given the currently installed system $\alpha$ and a package formula $\langle n,v,op \rangle$,
$upgrade_2(\alpha,\langle n,v,op \rangle) = [\neg a \mid a \in packagesThatSatisfy(\langle n, maxversion(\beta,n), < \rangle)]$
\end{defs}
That is, all components of name $n$ that have a lesser version than the highest version currently installed in $\alpha$ cannot be installed in the new system. 

The set of all upgrade constraints is then the union of all constraints created for all package formulae in $upgradepkgflist$,
i.e. $\bigcup \limits_{pf \in upgradepkgflist} (upgrade_1(pf) \cup upgrade_2(\alpha,pf))$.

\paragraph{Union}
Given a set of components $\mathbb{C}$, the set of currently installed components $\alpha$,
and the sets of package formulae mapped from the request stanza properties \verb+install+, \verb+remove+ and \verb+upgrade+ 
(respectively $installpkgflist$, $removepkgflist$ and $upgradepkgflist$);
the set of all change constraints represented as $\Delta$ is the union of the install, remove and upgrade constraints above.
That is, 
\begin{defs}
Given 
\begin{itemize}
  \item $i = \bigcup \limits_{pf \in installpkgflist} install(pf)$
  \item $r = \bigcup \limits_{pf \in removepkgflist} remove(pf)$
  \item $u = \bigcup \limits_{pf \in upgradepkgflist} (upgrade_1(pf) \cup upgrade_2(\alpha,pf))$
\end{itemize}
$\Delta =  i \cup r \cup u$
\end{defs}

\subsection{Full Example}
\label{formal.example}
An example of a CUDF document is presented in figure \ref{formal.CUDFEXAMPLE} to illuminate the basic process of mapping a CUDF document to a set of constraints as expressed in section \ref{formal.step}.

\begin{figure}[htp] 
\begin{center}
\begin{alltt}
preamble:
property: size: int = [0]

package: syslib
version: 1
installed: true
conflicts: syslib

package: syslib
version: 2
conflicts: syslib

package: textEditor
version: 1
depends: spellChecker | spellCheckerService, syslib > 1

package spellChecker
version: 1
size: 1

package: tpspeller
version: 1
provides: spellCheckerService
size: 2

request:
install:textEditor

\end{alltt}
  \caption[CUDF Example]{Example of a CUDF request}
  \label{formal.CUDFEXAMPLE}
\end{center}
\end{figure} 

This example can be mapped to a set of components $\mathbb{C}_t$, a system $\alpha$, a set of constraints $R_t$ and a change request $\Delta_t$ in order to define the evolution problem.
These values must be first extracted from the document, as described below.

\subsubsection{Preamble}
%%%Describe the preamble
The preamble from the CUDF document presented in figure \ref{formal.CUDFEXAMPLE}, 
defines the addition of one property \verb+size+ of type \verb+int+ whose default value is \verb+0+.
This extension allows the component \verb+tpspeller+ version 1, to define its \verb+size+ as $2$.

\subsubsection{Constraints}

%%%Describe the set of components and the initial system
The set of components are defined in the package stanzas in the document,
such that $\mathbb{C}_t = \{syslib_1, syslib_2,  textEditor_1,  spellChecker_1,  tpspeller_1\}$.
This represents two system library versions (\verb+syslib+), a text editor component (\verb+textEditor+), a spell checker (\verb+spellChecker+) and a third party spell checker (\verb+tpspeller+).

The initial system that $\alpha$ includes all components whose package stanzas include the property \verb+installed+ set as \verb+true+.
As described above, if \verb+installed+ is not defined the property defaults to the value \verb+false+,
therefore $\alpha = \{ syslib_1 \}$.

%%%Describe the depends constraints (including features and inequalities)
The set of constraints $R_t$ for this CUDF document is extracted from the package description stanzas, where the relevant properties of \verb+depends+, \verb+conflicts+ and \verb+provides+ are
mapped as described in the previous sections. 
The only depends constraints in this document are from the $textEditor_1$ component;
where the depends property is broken into two \verb+<pkgflist>+, \verb+spellChecker | spellCheckerService+ and \verb+syslib > 1+.
The first \verb+<pkgflist>+ is broken into two package formulae, \verb+spellChecker+  and \verb+spellCheckerService+,
which are mapped to $\langle $\verb+spellChecker+$,0,>\rangle$ and $\langle $\verb+spellCheckerService+$,0,>\rangle$ denoted as $pf_1$ and $pf_2$ respectively.
The second has exactly one package formulae, mapped to $\langle $\verb+syslib+$,1,>\rangle$ denoted as $pf_3$.

The $packagesThatSatisfy(pf_1)$ equals $\{spellChecker_1\}$, and $packagesThatSatisfy(pf_2)$ equals $\{tpspeller_1\}$.
The function $dependsOn(textEditor_1 , \{pf_1,pf_2\} )$ 
then equals the constraint $textEditor_1 \rightarrow spellChecker_1 \vee tpspeller_1$,
expressing the text editor depends on either the spell checker component or a component that provides a third party spell checker service.

The $packagesThatSatisfy(pf_3)$ equals $\{syslib_2\}$,
and the function  $dependsOn(textEditor_1 , \{pf_3\} )$ returns the constraint  $textEditor_1 \rightarrow syslib_2$.
This expresses that for the text editor to be installed the component $syslib_2$ must be installed.

%%%Describe the conflicts constraints
In this example there are two components that declare conflicts, $syslib_1$ and $syslib_2$.
Both of these are the \verb+<pkgflist>+ with one package formulae mapped to  $\langle $\verb+syslib+$,0,>\rangle$, which is denoted as $pf_4$.
The function $packagesThatSatisfy(pf_4)$ equals $\{ syslib_1,syslib_2 \}$,
however the $conflictsWith$ function returns different conflicts because of the caveat that a component cannot conflict with itself.
Therefore, $conflictsWith(syslib_1)$ returns the set of constraints $\{syslib_1 \rightarrow \neg syslib_2\}$,
and $conflictsWith(syslib_2)$ returns the set of constraints $\{syslib_2 \rightarrow \neg syslib_1\}$.
Note: these constraints are semantically the same.

%%%All request constraints are then\ldots
Given this example the set of constraints $R_t$ is then the constraints
$\{ textEditor_1 \rightarrow spellChecker_1 \vee tpspeller_1,$ 
$textEditor_1 \rightarrow syslib_2,$ 
$syslib_2 \rightarrow \neg syslib_1,$   
$syslib_2 \rightarrow \neg syslib_1\}$.

\subsubsection{Request}
%%%Describe the request constraint
The user's request constraints $\Delta_t$ are defined in the request stanza, which includes the request to \verb+install+ the component \verb+textEditor+. 
This package formula maps to $\langle $\verb+textEditor+$,0,>\rangle$, where $packagesThatSatisfy(\langle textEditor,0,>\rangle)$ equals $\{textEditor_1\}$.
Through functions $install$ and $installpkgflist$ this returns the constraint $textEditor_1$,
which asserts that the text editor component will be included in the new system, i.e. $\Delta_t = \{textEditor_1\}$.

\subsubsection{Solutions}
%%%Describe the possible models that can satisfy all constraints 
The set solutions to the evolution problem $EP_t = R_t \cup \Delta_t$ is the intersection of all constraints in $R_t \cup \Delta_t$.

By going through the constraints the solutions can be found.
Firstly, the request constraint ensures that the text editor component is included, the component $textEditor_1$ will be installed.
If $textEditor_1$ is installed then the system library component $syslib_2$ must be installed.
As the system library components conflict, $syslib_1$ must not be installed.
Of the two components that are left, $spellChecker_1$ and $tpspeller_1$, at least one must be installed due to the dependencies of the text editor.

This gives three possible solutions to this problem;
\begin{itemize}
  \item $s_1 = \{syslib_2, textEditor_1, spellChecker_1\}$,
  \item $s_2 = \{syslib_2, textEditor_1, tpspeller_1\}$,
  \item $s_3 = \{syslib_2, textEditor_1, spellChecker_1, tpspeller_1\}$
\end{itemize}

Given some criteria defined with the order $\prec_{\alpha}$, one of the solutions $s_1,s_2,s_3$ must be selected in the function $E(EP_t,\prec_{\alpha})$. 

\subsection{Mancoosi Optimisation Format}
\label{formal.mancoosioptimisationformat}
%%%Describe the format by which mancoosi has required optimisation criteria formatted
The CUDF specification does not specify the criteria used to select a solution.
For the purpose of the MISC competition, the Mancoosi organisation gave a specification to represent optimisation criteria.
This representation here is called the Mancoosi Optimisation Format (MOF), which can be mapped to the model described in section \ref{formal.opt}
This representation was designed to be passed to the CUDF solver on the command line, this meant that it must be expressible in a single line of human readable text.
This results in the relatively simple BNF grammar, as opposed to other possible specifications such as the framework presented in \citep{Treinen2009}. 
This grammar is described in figure \ref{formal.optbnf}.

\begin{figure}[h!]
\begin{center}
\begin{alltt}
<criteria> ::= <criterion> (, <criterion>)*
\end{alltt}
  \caption{Syntax of the optimisation criteria}
  \label{formal.optbnf}
\end{center}
\end{figure}
This defines a list of \verb+criterion+ with the delimiter \verb+,+ in the form $\langle criterion_1, \ldots, criterion_n \rangle$.
Each criterion is a unique string which expresses a criteria, e.g. $criterion_1 = \langle rank_1, \leq_1 \rangle$.
The criteria are then composed lexicographically into a single criterion $\langle rank_L, \leq_L \rangle$, 
where $criterion_1 \oplus \ldots \oplus criterion_n = \langle rank_L, \leq_L \rangle$. 
This can then be used to create the optimality order $\prec_{\alpha}$ as described in definition \ref{formal.defcrittooptimal}.

\subsubsection{Example}
An example of how to use this mapping for a practical problem can be extracted from the above CUDF document example presented in figure \ref{formal.CUDFEXAMPLE}.
In this example, the initial system $\alpha$ was  $\{syslib_1\}$, and there were three possible solutions
\begin{itemize}
  \item $s_1 = \{syslib_2, textEditor_1, spellChecker_1\}$,
  \item $s_2 = \{syslib_2, textEditor_1, tpspeller_1\}$,
  \item $s_3 = \{syslib_2, textEditor_1, spellChecker_1, tpspeller_1\}$
\end{itemize}

The criteria to select a solution could be defined by minimising the change to the solution, then minimising the total size of the components.
For this, first two criteria are defined as $crit_{change} = \langle rank_{change}, \leq_{change} \rangle$ and $crit_{size} = \langle rank_{size}, \leq_{size} \rangle$.

The criterion $crit_{change}$ is represented by the string \verb+-change+ in MOF.
$rank_{change}$ is defined as the cardinality of the symmetric difference between systems, i.e. $rank_{change}(\alpha,\beta) = |\alpha \Delta_t \beta|$.
The order $\leq_{change}$ is defined as $>$ over natural numbers, as less change is better. 

The criterion $crit_{size}$ is represented by the string \verb+-size+ in MOF.
$rank_{size}$ is defined as the sum of the property \verb+size+ of all components in the  proposed system, i.e. $rank_{size}(\alpha,\beta) = \sum_{c \in \beta} c$.\verb+size+.
The order $\leq_{size}$ is defined as $>$ over natural numbers, as a smaller system is better. 

For the MOF string \verb+-change,-size+, the resulting criteria would be $crit_{change} \oplus crit_{size} = \langle rank_L, \leq_L \rangle$, as shown in definition \ref{formal.defcritlex}.
This rank function applied to the possible solutions return in:
\begin{itemize}
  \item $rank_L(\alpha,s_1) = (4, 1)$
  \item $rank(\alpha,s_2) = (4, 2)$
  \item $rank(\alpha,s_3) = (5, 3)$
\end{itemize}
The order of these ranks over $\leq_L$ is then $rank(\alpha,s_3) \leq_L rank(\alpha,s_2) \leq_L rank(\alpha,s_1)$.
Therefore, the order of optimality ($\prec_{\alpha}$) over the possible solutions is $s_3 \prec_{\alpha} s_2$, $s_3 \prec_{\alpha} s_1$, and $s_2 \prec_{\alpha} s_1$,
which makes $s_1$ the optimal solution, as no other solution is greater. 

\section{Summary}
In this chapter the formal model of component system evolution was presented.
This evolution process was formally defined as the iterative application of an evolution step function,
which is defined to return an optimal solution to an evolution problem.
CUDF was used to represent an evolution problem, and MOF used to represent the criteria to select an optimal solution.
With these tools component system evolution can be studied, and automated.

In the following chapters, the implementation and strategies used to evolve a component system will be further discussed.
This will bring the ideas and concepts presented in this chapter to a concrete level, and show the practical challenges and benefits of automated component dependency resolution. 