\chapter{Formal Component System Evolution}
\label{cdr}
The exact definition of component system evolution is required in order to express and study it.
This definition is abstracted from any algorithm or process, as the evolution of a system could be performed manually.

The evolution of a system is made through iterative evolutionary steps over a period of time.
As any evolutionary step can have many outcomes, the optimisation of the process is necessary.
This optimisation may also include many various criteria that must be combined and optimised for.
The overall evolution of a system can then be defined, and the process discussed in a formal light.
This evolution then requires a representation, a format in which to describe then evolve a system.

In this chapter, the formal definition of an evolutionary step is given and shown to be NP-Hard problem in section \ref{formal.step}.
Then the definition of an optimisation framework for this process is described in section \ref{formal.opt}.
The overall formal description of an evolving system is then defined in section \ref{formal.evo}.
Finally, the CUDF description language (previously discussed in chapter \ref{background}) is defined for this problem in section \ref{formal.cudf}.

\section{Formal Definition}
\label{formal.step}
Suppose a user wants to install a new text editor component into their component system.
The selected text editor has a dependency on a spell checker;
this means a spell checker component must be installed for the text editor to be functional.
There are three spell checker components available that satisfy this dependency,
this means that one of these spell checkers should be selected for installation as well.

Or suppose, the use already has the text editor installed, and wants to update it to a newer version to increase stability and functionality.
There are two newer versions available, however the newest version of the text editor requires the system to install a new spell checker,
where the lesser up to date text editor can use the current spell checker.
This requires a selection of which to install, based on the users objectives for the system.

The first step in solving these problems is to represent them formally, this allows the study of the problems properties.
This definition must represent the component relationships and the change that is requested to be made. 
It also must include some way to choose between solutions, an optimisation framework that lets the users criteria be expressed.

In this section, a formal definition for a evolutionary step of a component based system is given.
This definition includes the ability to be optimised to choose a solution using a distance metric.
This problem is then shown to be NP-Complete in finding a solution and NP-Hard when finding the best solution.

\subsection{Formal Definition}
%%%What a component is
First the space of components is denoted as $\mathbb{C}$.
Each component is described by a name and version ($\langle n, v\rangle$), such that no two components can have the same name and version.

%%%What a component system is and the relationships
A component system is represented by a set of components.
The relationships between all components are described by a set of constraints denoted as $R$.

%%%What the change is
The evolutionary change that is requested to a system is defined as a set of constraints $\Delta$.

%%%The evolutionary function
The function that takes a component system and evolves it to another system is defined as $E$.
The evolutionary step function is then defined as $E_{R \cup \Delta}: 2^\mathbb{C} \rightarrow 2^\mathbb{C}$, 
such that it takes a component system and returns another component system that satisfy all component constraints in $R$ and the requested change $\Delta$.
This function will then take a component system, the constraints from the component relationships and the change request,
and return a system that satisfies all component relationships and the change request.

%%%Component realtionships constraints
The constraint in $R$ can be either: 
\begin{itemize}
  \item keep constraint in the form $a \vee \ldots \vee b$, e.g. $a \vee b$ means the $a$ or $b$ must be in the system
  \item dependency constraint in the form $a \rightarrow c_1 \vee \ldots \vee c_n$, e.g. $a \rightarrow b \vee c$ means $a$ depends on $b$ or $c$
  \item conflict constraints in the form $a \rightarrow \neg c$, meaning $a$ conflicts with $c$
\end{itemize}
These constraints are defined semantically such that
a keep constraint  $a \vee \ldots \vee b$ means $a \in E_{R \cup \Delta}(X)$ or \ldots or $b \in E_{R \cup \Delta}(X)$ (note: this can be unit i.e. $a$ is a valid keep constraint),
a dependency constraint $a \rightarrow c_1 \vee \ldots \vee c_n$ means if $a \in E_{R \cup \Delta}(X)$ then $c_1 \in E_{R \cup \Delta}(X)$ or \ldots or $c_n \in E_{R \cup \Delta}(X)$,
and a conflict constraint $a \rightarrow \neg c$ means if $a \in E_{R \cup \Delta}(X)$ then $c \not \in E_{R \cup \Delta}(X)$.
These constraints are expressive enough to describe many of the component models described in section \ref{background.models}.

%%%Change constraints
The constraints in $\Delta$ are of the form of either adding or removing a single component.
they can be in the form of $a$ or $\neg a$, where $a$ means to install component $a$ and $\neg a$ means to remove component $a$.
Semantically $a$ means to $a \in E_{R \cup \Delta}(X)$ and $\neg a$ means $a \not \in E_{R \cup \Delta}(X)$. 
This is a limited set of changes that can be requested to be made to the system.
This will be extended in section \ref{formal.cudf} to express more, but for now is all that is required.

%%%What is the change conflicts with R
A possibility that can occur is that the requested change creates constraints that conflict with the set of component relationships,
i.e. $R \cup \Delta$ is unsatisfiable.
For instance, a component $a$ depends on component $b$, 
if a request to add $a$ and remove $b$ will cause a conflict as no system exists that satisfy both $R$ and $\Delta$  
Given the subtle relationships between components, a request may be in conflict that intuitively should not cause a conflict.
To resolve this issue, many component systems check the request to ensure that it is consistent, and if it is not make no change.
This is the resolution used here;
if $R \cup \Delta$ is unsatisfiable, $E_{R \cup \Delta}(X) = X$.
Therefore, if the constraints are unable to be saisfied, the system will not be changed.

\subsection{Solution Selection}
\label{formal.solsel}
This definition of an evolutionary step requires a mechanism to select between solutions.
This is an optimisation problem as the solution that is selected should be optimal by some criterion.

For instance, given there are three components $a$,$b$ and $c$, and there is a component system of two components $a$ and $b$ (i.e. $\{a,b\}$).
There is only one relationship where $a$ depends on $b$, i.e. $R$ consists of only the dependency constraint $a \rightarrow b$,
and the defined change is to add a component $c$, i.e. $\Delta = \{c\}$.

The resulting system $E_{R \cup \Delta}(\{a,b\})$ could be one of three systems; $\{c\}$, $\{b,c\}$ or $\{a,b,c\}$.
Intuitively the correct answer is $\{a,b,c\}$, because unnecessarily removing a component from the system may be detrimental.
Therefore, some mechanism to select between the returning system is required in the function.
  
%%%The defintiion if extended to include the ability to minimise a heuristic
The function $E_{R \cup \Delta}$ is then extended to include the ability to select to return a solution that is superior to other possible solutions by some criterion.
The evolutionary step function is then extended to return a minimal system given some criterion given by the function $d: 2^\mathbb{C} \times 2^\mathbb{C} \rightarrow A$,
where the set $A$ is ordered by some order $<: A \times A$.

Therefore, given a component system $X$, a set of constraints $R$ and a change request $\Delta$,
$E_{R \cup \Delta}(X) = X_1$ iff there does not exist another system $X_2$, such that $X_2$ satisfies $R$ and $\Delta$, 
and $d(X,X_2) < d(X,X_1)$.
That is, $E_{R \cup \Delta}$ will return a solution that is minimal given the function $d$ and the order $<$.

%%%This optimisation function can be simplified to a function where the previous solution is not compared, but some static metric of the system is measured.
The function $d$ then compares the previous system to the evolved system, this could be seen as measuring the distance the system evolved.
This kind of criterion is \textit{dynamic}, it compares the change necessary for an evolutionary step.
A dynamic criterion could then be used to minimise the amount of components removed from the system, as it compares the previous system to the possible returned one.

This function can be simplified to represent \textit{static} measurements by defining, $d: 2^\mathbb{C} \rightarrow A$, which returns a direct measure of the evolved system.
This type of criterion could represent system size, which does not require the comparison with the previous system.

\subsection{Component System Evolution is NP-Complete}
Finding a solution that satisfies all relationship and request constraints is shown to be NP-Complete through reduction to a Boolean Satisfiability (SAT) problem,
and not belonging to a class given in Schaefer's dichotomy theorem \cite{Schaefer1978}.
The problem of optimising the evolutionary step function is then shown to be NP-Hard.
This is not the first proof that this problem is NP-Complete \cite{edos2005report}, 
though it may be the first through using Schaefer's dichotomy theorem which may be found to be more intuitive than reduction to 3-SAT.

SAT problems where the initial problem given the class NP-Complete in \cite{cook1971}.
This class of problem is described by its properties of being able to verify a solution quickly, but have no efficient way to find a solution initially.
To show that this problem is NP-Complete, the first step is to reduce the problem into SAT problem represented by a Boolean equation in Conjuctive Normal Form (CNF).
CNF is a conjunction of clauses, where each clause is a disjunction of literals.

The constraints in this problem are converted to CNF clauses:
\begin{itemize}
  \item keep constraint: $a \vee \ldots \vee b$ is directly represented as a single clause in CNF
  \item dependency constraint: $a \rightarrow c_1 \vee \ldots \vee c_n$ can be represented in CNF as a clause $\neg a \vee c_1 \vee \ldots \vee c_n$
  \item conflict constraint: $a \rightarrow \neg c$ can be represented in CNF as a clause $\neg a \vee \neg c$
  \item request constraint: $a$ and $\neg a$ can be represented directly as CNF clauses
\end{itemize}
All clauses are combined through $\wedge$ to form a complete CNF formula, the representative SAT problem.

According to Schaefer's dichotomy theorem \cite{Schaefer1978}, iff a SAT problem can be represented in CNF as one of six classes the problem is not NP-Complete.
Therefore showing that a problem SAT created by the evolution step can be in none of these classes, then the problem can be NP-Complete.
These classes are:
\begin{enumerate}
  \item the problem is solvable by assigning each variable false
  \item the problem is solvable by assigning each variable true
  \item every clause has at most one negated variable
  \item every clause has at most one unnegated variable
  \item every clause has 2 literals (2-SAT problem)
  \item all relations are equivalent to a conjunction of affine formulae (i.e. $x_1 \oplus \ldots \oplus x_n = true$ or $x_1 \oplus \ldots \oplus x_n = false$)
\end{enumerate} 

As each literal represents whether a component is included or excluded from the system, these classes can be described in terms of the component system.
The first two classes state that this problem is not NP-Complete if a component system can be created with no components or all components.
As the request constraints can state that a component has to be included or has to be excluded, the problem may exist such that it is not in either of these classes.  

The third and fourth classes state that either the problem can be represented by a set of Horn or dual-Horn clauses, such problems are known to be solvable in linear time \cite{dowling1984linear}.
Given a component and conflict with another creating a clause such as $\neg a \vee \neg c$, and a component can depend on multiple other components represented by a constraint such as
$\neg a \vee c_1 \vee c_2$, this problem does not belong to either of these classes.

The fifth class states that the CNF problem cannot be represented as a series of clauses with only 2 literals.
This class will exist in the problem if the dependence tree creates a strongly connected component, 
which has been shown to be reducible to 2-SAT \cite{aspvall1979linear} and therefore solvable in linear time.

The sixth class states that for this problem to be NP-Complete it must not be representable as a linear equation over a two element field $\{0,1\}$
That is, the CNF formula can be represented as a conjunction of clauses using the XOR ($\oplus$) operator.
 
The evolutionary step problem can be shown to be in neither the fifth or sixth classes 
through mapping to an equivalent problem called ``exactly one in three'' presented in \cite{Schaefer1978} as problem ``NP1.
This problem describes a series of clauses that result in solutions where only one of three components can be selected. 
For example, given components $a$,$b$ and $c$, the only possible solutions that satisfy the constraints ($R \cup \Delta$) are $\{a\}$,$\{b\}$ and $\{c\}$.
This problem is shown to not belong to any of the above classes in lemmas 3.1A, 3.1B and 3.1W in \cite{Schaefer1978}.
By stating the keep clause of $a \vee b \vee c$ and the conflict clauses of $\neg a \vee \neg b$, $\neg b \vee \neg c$ and $\neg a \vee \neg c$, 
the only possible solutions are $\{a\}$,$\{b\}$ and $\{c\}$. 

%%%This problem may be in fact P if it can exist to one of these classes
This evolutionary step problem then has the potential to be NP-Complete, though many practical problems may be solvable in linear time.
For instance, a problem that has no conflict constraints would be in the third class where it would have at most one negated variable in each clause.
As some component models, such as Maven, have no means of defining conflicting components, they will be in this class of problems and therefore not be NP-Complete. 

The complexity of the problem impacts the possiblility of completeing the evolution manually, or if automated through CDR, the implementation possibilities.

\subsection{Component System Evolution is NP-Hard}
As noted by \cite{leberre2008}, this problem is often under constrained, creating many possible component systems that satisfy all constraints.
Also noted, is the fact that some of these solutions are not as good as others.
By creating a function to attribute a measurement to each set of possible solutions and searching for the optimal system given this measurement, this problem becomes NP-Hard. 
This can be shown through mapping it to an equivilant problem of that has already been shown to be NP-Hard, the Binate Covering Problem \cite{Coudert1996}.

This problem is defined:
\begin{itemize}
  \item $v$ is the set $\{0,1\}$, $y$ is a variable, and $y^v$ is the assignment of $y$ to $v$
  \item $f(y_1, \ldots, y_n)$ is a Boolean function from $\{0,1\}^n$ to $\{0,1\}$
  \item $cost$ is a function that associates a positive cost with the assignment of a variable $y_k$ to $1$ or $0$
  \item the cost of a n-tuple $(v_1,\ldots,v_n)$ is defined as $\sum^n_{k=1}cost(y^{v_k}_{k})$
\end{itemize}
The binate covering problem then consists of finding a minimum $cost$ n-tuple that evaluates $f$ to $1$.

This evolutionary step can be mapped to this problem by defining:
\begin{itemize}
  \item each variable $y_1,\ldots,y_n$ represents a component in $\mathbb{C}$
  \item an n-tuple assignment represents a component system such that any component $y_k$ is assigned $1$ iff it is in the component system 
  \item $f(v_1,\ldots,v_n)$ returns $1$ if the n-tuple assignment creates a system that satisfies $R$ and $\Delta$
  \item the cost of a component system is is defined as the function $d : {0,1}^n \rightarrow A$ defined as $\sum^n_{k=1}cost(y^{v_k}_{k})$
\end{itemize}
The goal of the evolutionary step problem then consists of finding an n-tuple that creates a system that satisfies $R$ and $\Delta$,
with the minimum value for $d$.
This cost function only considers \textit{static} measurements, as described in section \ref{formal.solsel}, though could be extended to consider \textit{dynamic} measurements.

This NP-Hard class of problem is notably intractable to solve, and will impact any attempt to solve it, manual or computational.
The attempts to mitigate this complexity are discussed in chapter \ref{implementation}.

\subsection{Generational Component System Evolution}
\label{formal.evo}
The evolution of a component system is typically made up of many of the evolutionary steps defined above. 
With each successive change, the system resembles less of the starting system.
Each stage of the system is an analogy of a generation in the evolution of a biological organism, this process is the generational evolution of a component system.
This is a time dependent, recursive and complex process. 

%%%This process depends on time
This process can occur over large periods of time, over which the set of components can change making the evolution of a system time dependent.
Due to component evolution, newer versions of components can be added to the set of components.
Also newer components can be developed and added to the set.
This means that the set of components changes in relation to the time, which in turn changes the relationships between components changing the constraints in $R$.
For example, component $a$ depends on all versions of a component whose name is $b$.
Initially there is only one version of $b$, $bv1$, making the dependence constraint $a \rightarrow bv1$.
However, due to component evolution at a latter date a newer version of $b$ is created, $bv2$, this then created the constraint $a \rightarrow bv1 \vee bv2$.
This time dependence is defined, given a specific time $t$, the component constraints that exist at time $t$ are denoted as $R_t$.

%%%The requests should be aggregated into one request, if there is a conflict then newer requests should be prioritised
The requested changes to the system should also be considered even after they have been made.
A request to change the system is usually performed in order to maintain or extend the system.
A possible problem occurs when after the change has been made, the next evolution may undo that change, even if it is not necessary.
For instance, if a component is requested to be installed, in a latter evolution it may be removed even though it was avoidable.

The simple solution to this is to aggregate all previous requests into one set of constraints;
Given a series of evolutionary changes denoted as the tuple $\langle \Delta_1, \ldots, \Delta_i \rangle$ in order from least to most recent,
the constraints for the request would be the $\Delta_1 \cup \ldots \cup \Delta_i$.
However, these requests can conflict, e.g. a component is requested to be installed, and later requested to be removed.
As a more recent request is of higher importance than an older request, a simple process of finding a non-conflicting set of request constraints can be defined.
Therefore: given a series of requests $\langle \Delta_1, \ldots, \Delta_i \rangle$ in order from least to most recent,
the set of request constraints is defined as $\Delta_G = [\Delta_n \mid n \in \{1, \ldots , i\} \mbox{ and } \Delta_n \cup \ldots \cup \Delta_i \mbox{ is satisfiable}]$.
That is, $\Delta_G$ is the subset of request constraints that includes all constraints that do not conflict with a more recent constraint.

%%%This process is then defined as
Given the tuple of evolutionary changes denoted as $\langle \Delta_1, \ldots, \Delta_n \rangle$
which occur at times  $\langle t_1, \ldots, t_n \rangle$.
A generation is defined as $G_i = E_{R_{t_i} \cup \Delta_G}(G_{i-1})$ where $i$ is an integer between $1$ and $n$.
The initial generation of this process, $G_0$, is the starting point that could either be an system with no components, or a system that is a pre-defined configuration of components.

%%%This makes a sometimes counter intuitive complexity
This process can be counter-intuitive and complex.
For instance, a single step of evolution that is optimised to reduce change may cause more change over generations of evolution.
Given an initial system $G_0 = \{\}$ a series of changes is defined as $\langle \{a\}, \{d\}\rangle$, 
and a set of constraints (time invariant) $R = \{a \rightarrow bv1 \vee bv2, bv1 \rightarrow \neg bv2, bv2 \rightarrow c, d \rightarrow bv2\}$;
if the evolution function is optimised to minimise change the first generation would be $G_1 = \{a,bv1\}$ as this system would install $a$ with only changing two components (installing $a$ and $bv1$).
The second generation when attempting to install $d$ would result in $G_2 = \{a,bv2,c,d\}$, which changed four components (removed $bv1$ and installed $a$,$bv2$,$c$ and $d$).
A better evolution of this system would of been $G_1 = \{a,bv2,c\}$ then $G_2 = \{a,bv2,c,d\}$ which would change a total of four times across its evolutions as apposed to the six previously described.

This complexity is the reason for the study of the evolution process throughout this research. 
This counter-intuitive impact on the evolution of component systems, opens up research questions that should be answered to use component systems.

\subsubsection{Belief Revision}
This formalism of generational evolution is similar to the formal logic of belief revision \cite{alchourron1985logic}.
This logic deals with the process in which a set of beliefs can be revised when confronted with new information.
The complexity of belief revision comes from the many ways in which a set of beliefs can be revised when necessary.
For instance, if you see an object that is black and is flying towards you, where you also know that birds fly; then you infer it is a bird.
However, an expert in flying things then tells you that it is a bat that is flying towards you; given this new information your previous beliefs require revision to stay consistent.
How this revision occurs can be complex; for instance, is the object still black?

The Alchourrón, G\"ardenfors, and Makinson (AGM) \cite{alchourron1985logic} postulates for belief revision give a set of eight properties 
that a such a revision operator needs to satisfy in order to be considered ``\textit{rational}''.
These postulates (not enumerated here) were rephrased for propositional languages by \cite{katsuno1991propositional}. 
Given a set of propositional formula $Y$ representing the belief set and a single formula $A$ representing new information, the revision of $Y$ by $A$, denoted by $Y \circ A$,
should have these properties:

\begin{itemize}
  \item (KM1) \textit{ $Y \circ A$  implies $A$}
  \item (KM2) \textit{ If $Y \wedge A$  is satisfiable, then $Y \circ A \equiv Y \wedge A$}
  \item (KM3) \textit{ If $A$ is satisfiable, then $Y \circ A$  is also satisfiable}
  \item (KM4) \textit{ If $Y_1 \equiv Y_2$ and $A_1 \equiv A_2$, then $Y_1 \circ A_1 \equiv Y_2 \circ A_2$}
  \item (KM5) \textit{ $(Y \circ A) \wedge B$  implies $Y \circ (A \wedge B)$}
  \item (KM6) \textit{ If $(Y \circ A) \wedge B$ is satisfiable, then $Y \circ (A \wedge B)$ implies $(Y \circ A) \wedge B$}
\end{itemize} 

The first four KM postulates are equivalent to the first six AGM postulates, describing the basic nature of revision;
new information is always included in the new beliefs (KM1); if the new information does not conflict with old information the revision is equviliant to conjunction (KM2);
if the new information is satisfiable then the revised beliefs should be satisfiable (KM3); revision should be deterministic where given equal scenarios the results are equal (KM4).

The last two KM postulates are equivalent to the last two AGM postulates, which describe the intended minimal change of revision.
That is, revision should only change a minimal set of beliefs given new information is conflicting.
Through weakening (KM6) to two more postulates (KM7) and (KM8), \cite{katsuno1991propositional} further define the revisions minimal change.

\begin{itemize}
  \item (KM7) \textit{ $Y \circ A_1$  implies $A_2$ and $Y \circ A_2$ implies $A_1$ then $Y \circ A_1$ is equivalent to $Y \circ A_2$}
  \item (KM8) \textit{ $(Y \circ A_1) \wedge (Y \circ A_2)$ implies $A$}
\end{itemize}

\cite{katsuno1991propositional} go on to describe a model theoretic characterisation of minimal change; 
given the set of all models $M$, a function is defined that assigns to a set of formula $Y$ a pre-order $\leq_{Y}$ over $M$,
where the strict order is defined as $m <_Y m'$ if and only if $m \leq_Y m'$ and $m' \not \leq_Y m$. 
This assignment is described as ``\textit{faithful}'' if three conditions hold:
\begin{enumerate}
  \item If $m,m' \in Mod(Y)$, then $m <_Y m'$ does not hold
  \item If $m \in Mod(Y)$ and $m' \not\in Mod(Y)$, then $m <_Y m'$ holds
  \item If $Y \equiv Z$, then $\leq_Y = \leq_Z$  
\end{enumerate}

That is, a model of $Y$ cannot be strictly less than any other model of $Y$ and must be strictly less than all non-models of $Y$.

Katsuno and Mendelzon then use this assignment to define minimality and a revision operator; 
let $J$ be a subset of $M$, 
a model $m$ is minimal in $J$ with respect to $\leq_{Y}$ if $m \in J$ and there is no $m' \in J$ such that $m' <_Y m$. 
The function $Min(J,\leq_{Y}) = \{ m \mid m$ is minimal in $J$ with respect to $\leq_{Y} \}$.
A revision operator $\circ$ will satisfy the postulates (KM1)-(KM5) if and only if
their exists a faithful assignment that maps each set of propositional formula $Y$ to a pre-order $\leq_{Y}$
such that $Mod(Y \circ A) = Min(Mod(A),\leq_{Y})$.
Katsuno and Mendelzon show that (KM6) will also be satisfied iff $\leq_{Y}$ is a total order,
and (KM7) and (KM8) will also be satisfied iff $\leq_{Y}$ is a partial order.

\paragraph{Component System Evolution Mapping}
This propositional belief revision can be used to describe component system evolution, it proposes a formal basis to give component system evolution ``rational'' properties.
However, there are incompatibilities with this mapping, significantly this logic's dependence on minimal change.

%%%Define the mapping
The set of beliefs, $Y$, defines the propositional formulae whose model is the component system,
and the new information, $A$, is the propositional formulae that are requested change to the system.
The variables in these formula represent the components, and a model is represented by a set, where if a variable is in a set iff it is assigned $true$, 
and a variable is not in the set iff it is assigned $false$. 
Then set $Y$ is the set of formulae that is ``believed" to create a component system best suited for the user.
The formula $A$ defines a change to the beliefs of what is best for the user, which may require the component system to be revised.

%%%Discuss the mapping of the function to the revision operator
The component relationships are facts in this logic, and not beliefs; they are axioms that are defined as integrity constraints by \cite{katsuno1991propositional}.
The revision operator is then denoted with respect to the component relationships $R$ as $\circ_R$.
This revision operator $\circ_R$ is mapped to the the evolutionary function $E$;
given the evolutionary function $E_{R \cup \Delta}(X) = X_1$, $Mod(Y) = \{X\}$ and $Mod(Y \circ_R \Delta) = \{X_1\}$.
This restricts the possible models of $Y$ and the revised models to a singleton sets of $\{X\}$ and $\{X_1\}$,
as there can only exist a single component system at a time.

%%%What does this mapping give us, a foundation
An order $\leq_{Y}$ that holds to the properties stated previously must be defined in order to consider this revision operator ``rational''.
This property, that is the basis of belief revision operators gives component system evolution a foundation.
It states that the changes that are made to a component system are reasonable with respect to the beliefs that it is satisfiable for the user.
The benefit of this mapping would provide evolution with a set of revision operators already defined, and another set of research to contribute to.

%%%However, this mapping is incompatible with our definition.
Although this mapping may provide some benefits to component system evolution, their are fundamental differences which make the mapping incompatible.
The optimisation function $d$ with its order $<$ is analogous to the order $\leq_{Y}$.
They both describe the measures of optimality, however $d$ can be static, measure the optimality of a system separate from a previous system,
where $\leq_Y$ is only dynamic, measuring the change from previous to new system.
This difference creates a incompatibility, given the constraint on $\leq_Y$ which requires no change if necessary,
and $d$ which can make changes which may not be minimal.
For example, if a system is requested to install a component that is already installed, a belief revision operator will never change the system,
however a component evolution function may identify there exists a newer version and attempt to update the component.

%%%Therefore it is not used
This fundamental difference excludes the use of belief revision as the basis of component system evolution formalisation.
Although, the extension of belief revision may be possible to accurately describe component system evolution, 
the necessary changes will remove belief revision from its foundation of minimal change,
therefore is seen as extreme.
Instead, this research directly defines the problem using belief revision as inspiration.

\section{Evolution Optimisation}
\label{formal.opt}
%%%The formal definition of how to evolve a component system is complicated because it is a multicriteria problem
Any requested evolution of a component system can have many different possible resulting systems \cite{leBerre2010}.
This is because the problem is generally under-constrained \cite{leberre2008}, which enables many various possible systems available to satisfy the component relationships.
Up till now in this chapter, the function to optimise the evolution of the system has been left largely undefined.

The lack of definition is due to the practical aspect that an evolution step is a multi-crititeria optimisation problem \cite{leBerre2010}. 

%%%This can be seen from the examples described in the background
The necessity of using multiple criteria can be seen in the examples of current CDR application criteria presented in \ref{background.models},
where no examples consisted of only one only one measurement to select an optimal system.
These different measures are expressed and combined through various means.
Criteria like APT's upgrade constraint saying that ``under no circumstances are currently installed packages removed'' form a hard constraint,
that is the upgrade will fail if a component is required to be removed.
MPM's criteria are related lexicographically, where one criteria is infinitely more important than another.

%%%Information from differnet loactions and meta data can be used to define the criteria.
Information from component meta-data, component contracts \cite{Watkins1999}, repositories \cite{Guo2000}, 
composition testing \cite{XuejieZhang2008} and user preferences could be used to define such criteria.
Additional criteria, such as size, reliability or licence, may change a systems' desirability, 
therefore during evolution the optimisation of such criteria may return better solution.

Through the formal definition and exploration of this multi-criteria optimisation problem,
a solution can be defined formally.
This formal definition should be able to compose multiple various criteria into a single optimisation function that can be used to evolve a component system.

\subsection{Multi-Criteria Component System Evolution}
%%%Combining criteira is a challenge because criteria have different domains and orders, some have partial orders, arbitrary rankings, criterion orderings.
Optimising multiple criteria proposes some challenges; firstly criteria may have different domains and orders, 
e.g., minimising the size in bytes while maximising percentages of reliability. 
Some criteria may have partial orders where two solutions can be incomparable,
e.g., one licence may not be better or worse than another.
Criteria may have arbitrary rankings, 
e.g., preferences for licences can differ significantly between users.
A criterion could also be more important than another, 
e.g., correct functionality of a system will always be more important than its size.

%%%A naive solution is to map all criteria to real numbers, then aggregate them through addition multiplication with weights.
A naive solution for this problem is to create a function that for each criteria maps all components to a set of real numbers.
Then by aggregating these numbers through addition or multiplication (possibly with weights) a single function to minimise can be created. 

%%%This has draw backs, some criteria are infinitly more important, it is not intuitive for users to weight.
This method has some drawbacks;
information is lost in the conversion to the totally ordered real numbers,
e.g. the reason why one system was selected over another.
The relationships between criteria are also difficult to define, as getting an intuitive system order requires altering weights which makes the function complicated to maintain.
This leads to the problem that assigning preferences to criteria with arbitrary weights is not intuitive,
e.g., stating ``size is $.25$ more important than vendor'' does not convey meaningful information about the weighting decision, or its impact.

%%%We approach this problem formally using orders over partially ordered sets, where any sub set is bounded, this is a complete lattice.
The formal approach to solve this problem is to use orders over sets, 
where each criterion is a set ($A$) with an order ($\leq$).
Each criterion is then a partially ordered set (the order must be reflexive, antisymmetric and transitive).
Furthermore, it is requires that any set of elements in a criterion must be bounded, 
i.e. have a least upper bound and a greatest lower bound.
A complete lattices satisfies these requirements, therefore is used as the representation. 

%%%these complete lattice criteria using the product and lexicographic orders.
These complete lattices are able to be composed using the lexicographic and product orders.
This provides a convenient, intuitive way to express relationships between criteria.

%%%This framework can then be used to describe and discuss the multicritera problem of CDR.
This framework defines criteria as a ranking system over a complete lattice.
The ranking system describes a mechanism in which to rank a solution to a complete lattice. 
The complete lattice gives an order to the solutions based on their ranking.
By combining these criteria (ranking systems and complete lattices) multi-criteria problems can be composed.
Then using a general algorithm that can search these structures, 
optimal solutions for any defined problem can be found.

\subsection{Complete Lattice}
%%%Complete Lattices have been used in other optimisation frameworks.
Complete lattices are an effective abstraction to represent rankings,
and have been used before when describing such criteria \cite{Bistarelli1997,Fernandez}.
They can represent problems that involve partial orders,
be combined into new lattices,
and be easily visualised and presented using Hasse diagrams \cite{davey1990introduction}.
They also have strict bounding, which enables general methods, such as branch and bound \cite{Land1960}, to find solutions.

%%%The formal definition for comlpete lattices is a partially ordered set where all subsets have a unique least upper bound and unique greatest lower bound
A complete lattice is a partially ordered set where all subsets have a unique least upper bound and unique greatest lower bound.
Formally this is defined:
\begin{defs}
A complete lattice is a pair $L = \langle A, \leq \rangle$ where $A$ is a non empty set 
and $\leq \subseteq A \times A$ is a relation such that:
\begin{itemize}
  \item $\leq$ is a partial order
  \item for all subsets of $A$ there exists a unique least upper bound (join or $\vee$) and a unique greatest lower bound (meet or $\wedge$)
\end{itemize}
\end{defs}

%%%The domiain of the complete lattice represents the value domain of the criteria.
The domain of the complete lattice ($A$) defines the value space (e.g., probability, cost, \ldots) 
that is used to rank solutions. 
The core attribute of a complete lattice is that all subsets of the lattice have both a unique least upper bound (join or $\vee$) 
and a unique greatest lower bound (meet or $\wedge$).
Using these operators the greatest ($1$) and least ($0$) elements can be defined as
the join of the entire domain ($\bigvee A = 1$) and the meet of the domain ($\bigwedge A = 0$).

\subsection{Ranking and Solution}
%%%We define a ranking system and function, which returns a value for the complete lattice domain.
An optimal solution can now be defined through a ranking system with respect to complete lattices.

%%%A ranking system is a lattice a finite domain of variables, and their assignment domain
\begin{defs}
Consider a complete lattice $L = \langle A, \leq \rangle$; 
a ranking system is defined over this lattice as a triple $RS = \langle L, D, V \rangle$, 
where $V$ is a finite set of variables and $D$ is their finite domain.
\end{defs}

%%%Given we specifically look at components, the variables are components and their domain is \{T,F\}, whether they are installed or not
Given the focus of this research is on component system evolution,
this abstract definition of a ranking system can be further defined.
Within dependency resolution, 
each variable in this problem is a component and their domain is whether they are included or excluded from the final solution.
Therefore, $D = \{F,T\}$ and $V = C$, where $C$ is the set of components in the problem.

%%%A solution (system) is a mapping of variables to the domain
\begin{defs}
A solution is a variable binding $\gamma: V \rightarrow D$, a mapping of each variable to an element in the domain,
and $\Gamma$ is the set of all solution functions.
\end{defs}

This definition of solution does not take order into account, where a solution could be the worst possible solution.

%%%The ranking function, takes two solutions, and returns the distance between them 
%TODO increase the ranking function to take two solutions and return a distance between them
\begin{defs}
Consider a complete lattice $L = \langle A, \leq \rangle$ and a ranking system $RS = \langle L, D, V \rangle$.
A ranking function ($Rank$) maps the distance from the current solution and a new solution to elements from $A$,
$Rank: \Gamma \times \Gamma \rightarrow A$.
\end{defs}

%%%The set of optimal solutions is then the set of solutions where there are no better solutions
\begin{defs}
Consider a complete lattice $L = \langle A, \leq \rangle$, a ranking system $RS = \langle L, D, V \rangle$, a previous solution $\gamma$ and a ranking function $Rank$.
The set of optimal solutions ($OSol \subseteq \Gamma$) is the set of solutions where there is no other solution whose rank is better,
such that $OSol = \{ s \in \Gamma : \nexists s' \mbox{ such that } Rank(\gamma,s) < Rank(\gamma,s')\}$
\end{defs}

%%%The set of optimial solutions may still be undesirable, as it is only solutions that are available
The set of optimal solutions only includes the highest ranked solutions,
as with the definition of solutions, these optimal solutions could be undesirable.
For instance given a problem which is ranked with either $Correct$ or $Incorrect$, 
the optimal solution could be $Incorrect$ if there exists no solutions that are $Correct$. 

\subsection{Composition of Complete Lattices}
%%%This section is mostly identicle to the section in our APSEC paper, it just proves that combining two complete lattices with lexicographic or product order returns a complete lattice
\label{sec:composition}
As a complete lattice with a ranking system is the representation of a criterion,
the composition of criteria is the way of expressing their relationships to one another. 
Two separate composition operators of complete lattices are defined as the product and lexicographic orders.

It is shown here that the lexicographical and product compositions of complete lattices result in a complete lattice,
this enables any combination of these orders to be used and remain within our framework.
This is proven by deriving the join (unique least upper bound) and meet (unique greatest lower bound) operations,
and showing there exists a least element ($0$) within the lattice \cite{davey1990introduction}. 

The ranking systems are defined to be composed with these orderings.

\begin{defs}
\label{def:product_order}
Consider two complete lattices $L_1 = \langle A_1, \leq_1 \rangle$ and $L_2 = \langle A_2, \leq_2 \rangle$;
$L_1 \otimes L_2$ creates a product composition $L_P = \langle A_1 \times A_2, \leq_P \rangle$
where $\leq_P$ is a product order; 
$(a,b) \leq_{P} (a',b') \mbox{ iff } a \leq_{1} a' \mbox{ and } b \leq_{2} b'$.
\end{defs}

The product order of a classical lattice $L = \langle \{T,F\}, \leq \rangle$ 
composed with its self is given in the diagram in Figure \ref{fig:product}.
%\begin{figure}[htp]
%\begin{center}
%  \includegraphics[height=.1\textheight]{productorder.png}
%  \caption{Hasse diagram of the product composition of classical lattices}
%  \label{fig:product}
%\end{center}
%\end{figure}

The product order is trivially reflexive, anti-symmetric and transitive, therefore it is a partial order.
\begin{prop}
The product composition of two complete lattices is a complete lattice.  
\end{prop}
\begin{prof}
For any two points $(a,b)$ and $(a',b')$;
their join is the join of each element $(a \vee a', b \vee b')$, 
inversely their meet is the meet of each element $(a \wedge a', b \wedge b')$.
This lattice is also complete as its least bound is the least bound of each set $(0_1,0_2)$.
$\Box$\end{prof}

\begin{defs}
\label{def:lex_order}
Consider two complete lattices $L_1 = \langle A_1, \leq_1 \rangle$ and $L_2 = \langle A_2, \leq_2 \rangle$;
$L_1 \odot L_2$ creates a lexicographical composition  $L_L = \langle A_1 \times A_2, \leq_L \rangle$
where $\leq_L$ is a lexicographic order;
$(a,b) \leq_{L} (a',b')$ iff $a <_{1} a'$ or $(a = a'$ and $b \leq_{2} b')$.
\end{defs}

The lexicographic order of a classical lattice $L = \langle \{T,F\}, \leq \rangle$ 
composed with its self is given in the diagram in Figure \ref{fig:lex}.
%\begin{figure}[htp]
%\begin{center}
%  \includegraphics[height=.1\textheight]{lexicograhicorder.png}
%  \caption{Hasse diagram of the lexicographical composition of classical lattices}
%  \label{fig:lex}
%\end{center}
%\end{figure}

The lexicographical order is trivially reflexive, anti-symmetric and transitive, therefore it is a partial order.
\begin{prop}
The lexicographical composition of two complete lattices is a complete lattice.
\end{prop}
\begin{prof}
Consider two points $(a,b)$ and $(a',b')$; 
the join of $(a,b)$ and $(a',b')$ is $(a',b')$ if $a <_1 a'$,
$(a,b)$ if $a' <_1 a$,
$(a, b \vee b')$ if $a = a'$,
or if $a$ and $a'$ are incomparable ($a||a'$) it is $(a \vee a', 0_2)$
as this is an upper bound, and any other upper bound must be bigger than this.
The meet is defined dually where the meet of $(a,b)$ and $(a',b')$ is $(a',b')$ if $a' <_1 a$,
$(a,b)$ if $a <_1 a'$,
$(a, b \wedge b')$ if $a = a'$,
or if $a$ and $a'$ are incomparable ($a||a'$) it is $(a \wedge a',1_2)$
as this is a lower bound, and any other lower bound must be smaller than this.

This lattice is also complete as its least bound is the least bound of each set $(0_1,0_2)$.
$\Box$\end{prof}

There are two things to note about the lexicographical composition; 
first it does not create a distributive lattice i.e. $\wedge_L$ does not distribute over $\vee_L$.
\begin{prop}
The lexicographic composition does not result in a distributive lattice.
\end{prop}
\begin{prof}
Consider two pairs $(a,b)$ and $(a', b') \in L_1 \odot L_2$ where $a || a'$ and $a = a''$ and $a' || a''$,
then $(a,b) \wedge_{L} ((a', b') \vee_{L} (a'', b'')) = (a,b)$,
where under the same conditions $((a,b) \wedge_{L} (a', b')) \vee_{L} ((a,b) \wedge_{L} (a'', b'')) = (a,b \wedge_2 b'')$.
$\Box$\end{prof}

Secondly, two lattices (not complete lattices) lexicographically combined together may not be a lattice. 
This is another reason for the choice of complete lattices as the structure of representation.
\begin{prop}
The lexicographic composition of two lattices may not result in a lattice.
\end{prop}
\begin{prof}
Suppose a lattice $K$ has a non linear order, and a lattice $L$ has no least bound ($0_L$). 
For two pairs $(a,b)$ and $(a',b)$ in $K \odot L$ have no join if $a$ and $a'$ are incomparable.
This would be defined as $(a,b) \vee (a',b) = (a \vee a',0_L)$, as $0_L$ does not exist this join does not exist.
$\Box$\end{prof}

In figure \ref{fig:stacking} is presented some examples of how our composition operators can be stacked
by using a classical lattice ($L = \langle \{T,F\}, \leq \rangle$) composed in different ways.
In these examples the domain has been simplified for brevity, 
e.g., $\langle T, \langle T,T\rangle\rangle$ is represented with $\langle T,T,T\rangle$
%\begin{figure}[htp]
%\begin{center}
%  \includegraphics[width=.45\textwidth]{all.png}
%  \caption{Hasse diagrams of the composition of a classical complete lattice}
%  \label{fig:stacking}
%\end{center}
%\end{figure}

The composition of the ranking systems is defined as:
\begin{defs}
Consider two complete lattices $L_1 = \langle A_1, \leq_1 \rangle$ and $L_2 = \langle A_2,\leq_2 \rangle$ and
the ranking systems over them $RS_1 = \langle L_1,D,V \rangle $ and $RS_2 = \langle L_2,D,V \rangle$,
with defined ranking functions as $Rank_1: \Gamma \rightarrow A_1 $ and $Rank_2: \Gamma \rightarrow A_2$.
The combination $RS_1 \odot RS_2$ (resp. $RS_1 \otimes RS_2$) results in the ranking system 
$RS = \langle L_1 \odot L_2, D, V \rangle$ (resp. $RS = \langle L_1 \otimes L_2, D, V \rangle$), 
and the combination of the ranking functions is 
$Rank: \Gamma \rightarrow A_1 \times A_2$ where $Rank(\gamma) = \langle Rank_1(\gamma), Rank_2(\gamma) \rangle$.
\end{defs}

The main point in this definition is that to combine ranking systems they must have the same set of variables 
and the same domain.

\subsection{Semi-ring constraint incompatibility}
%%%Discussion of the related yet incompatible work C-semirings; how they inspired this work but due to lexicographic order we are unable to use it.
A large part of this formalisation was inspired by research into the representation of constraints as a c-semiring \cite{Bistarelli1997}.
This research shows that all instances of their framework are complete lattices, and their $+$ operator coincides with join
and if their $\times$ operator is idempotent, it coincides with meet.
Their examples include fuzzy, weighted, probabilistic and valued constraint problems which can be used in our framework.
In their framework $\times$ must distribute over $+$, this gives a distributive lattice.
However, since lexicographic orders may create non-distributive lattices, our overall frameworks are incompatible.


\section{Common Upgradeability Description Format}
\label{formal.cudf}
%%%The description of the represnation of CUDF is described.
Described in this chapter is the formal model of evolution of a component system, its constraints and it's optimisation.
The representation of such an evolution problem, how the problem is described has been, so far, left undefined.
In this section, the representation of such a problem is described through using the Common Upgradeability Description Format (CUDF) specification presented by \cite{treinen2009common}.
This specification was previously described in section \ref{background.models}, where an example of its meta-data was shown in figure \ref{CUDFmetadata}.

CUDF was defined as an abstract representation of this evolution problem.
This allows the comparison of various implementations designed to solve evolution problems, and the creation of generlisatiable solvers to be used across component models.
In both aspects CUDF has succeeded;
competitions, like the Mancoosi International Solver Competition (MISC)\footnote{http://www.mancoosi.org/misc-2011/}, have been held to compare various state of the art, and legacy, solvers.
the creation of the solver MPM \cite{abate2011}, that can solve problems represented in CUDF for different component models.

In this section first the design principles of CUDF are described, this will show the motivations of this definition are aligned to this research.
The syntax of CUDF is then described, this will not be as in-depth a description as given in the full specification \cite{treinen2009common},
however it will be enough detail to give a broad understanding of the format.
This CUDF syntax is then mapped to our model of the a component system evolutionary step.
This includes some minor extensions to the presented definition in section \ref{formal.step}.
Finally, although the definition of optimisation is not directly in the CUDF specification, the Mancoosi format for specifying optimisation criteria is discussed.

\subsection{CUDF Design}
%%%It was made to standardise the problem, for two reasons, to make building solvers generalisable, and to compete solvers in the MISC competetions to compare solutions.
The Mancoosi organisation is a research project whose area is the improvement to the upgrading of Free and Open Source Software (FOSS) distributions.
This upgrade problem is the same problem defined in this chapter, the evolution of a component system.
This is a broad topic, with many smaller objectives defined as milestones.

One of these objectives was to organise a competition between competing solutions of the upgrade problems of FOSS systems.
This was defined as it would hopefully encourage researchers and practitioners into researching the upgrade problem.

An initial problem faced in organising a competition is a format in which the competition could represent the upgrade problem.
The design of this format would have to follow some design princples to ensure the results would be useful.
These principles are presented in \cite{treinen2009common}, summarised as:

\begin{itemize}
  \item \textbf{Agnostic towards component model details}: 
  The specific component model and the implementation chosen to solve the problem, should be abstracted as to allow many problems and solutions to be used  
  \item \textbf{Stay close to the original problem}: 
  The original problem is still the focus of this research, therefore the format should not abstract so far as to be unrecognisable. 
  By using similar terms and syntax that already exists within the domain, the format will still directly represent the upgrade problem. 
  \item \textbf{Preserve the ability for humans to inspect encoded problems}:
  The analysis and design of a specific problem should be able to be directly accomplished through manual investigation.
  This will allow greater testing and debugging, also enable the direct inspection of the problem by researchers for study.
  \item \textbf{Avoid bias towards specific implementations or techniques}:
  Specific encoding of the problem, e.g. using propositional logic, or constraint programming, may create an advantage or disadvantage for a particular technique or solution.
  Since a goal of this research is to encourage the advancement of this area, the format should strive to be independent from any technique or implementation. 
  \item \textbf{Support legacy tools}:
  The comparison to tools that are already in use to solve such upgrade problems is a necessity when determining if this research is advancing the field.
  Ideally, a legacy or current solution should easily be able to be adapted and used with the format.
  Conversely though, the format should not stop state-of-the-art solutions from being used.
  \item \textbf{Extensible}:
  Although the format will attempt to abstract the common elements of the problem, there may still be necessary component model specific details that require inclusion.
  Also, some details are required for the optimisation of the problem, but which are not relevant to the specification of the format.
  The ability to extend the format is then required.
  \item \textbf{Transactional semantics}:
  The format should have the ability to completely represent a problem as a single unit, that can be passed to an implementation for solution.
  Also, the solution passed back should itself be a single unit, of the same format.
  This ignores aspects of the problem such as install order of the components, though this is outside the scope of this research.
  \item \textbf{Plain Text Format}:
  The use of plain text, as opposed to a binary format, will allow it to be human readable, as well as make it easier to parse and write.
  Although plain text may not be the most efficient way to encode a problem, the overhead required to parse other formats may decrease the interest to enter a competition.
  This also aligns with the morals of the community of FOSS developers, where plain text is the universal information interchange format \cite{ray2003}.
\end{itemize}

The result of these design goals is the CUDF specification, presented in \cite{treinen2009common}.
This format is presented in the following sections.

\subsection{CUDF Document}
%%%Here the CUDF document is defined using text and trying to stay away from too many formalisms, just describing concepts to be used later
In this section a brief description of the CUDF format is presented.
Some aspects of CUDF are ignored as a complete redefinition of the original specification is not the goal of this section.
For example, the CUDF specification describes a formal type system, which is left out here.
Where details are removed, or glossed over a reference will be made as to ensure that mis-information is not conveyed. 

CUDF is defined given the design goals presented in the previous section;
a CUDF document is a single plain text file, that represents all information necessary to define an evolutionary step as defined in section \ref{formal.step}.

This document is separated into three stanzas, the preamble, the package descriptions, and the request.

\begin{itemize}
  \item \textbf{preamble}: Defines the additional types used in the CUDF document
  \item \textbf{package descriptions}: typically the bulk of a CUDF document, this defines the set of components (using the FOSS term package)
  \item \textbf{request}: this defines the requested evolutionary change that should be made to the components 
\end{itemize}

This structure is presented in figure \ref{formal:cudfstruct}.

\begin{figure}[htp]
\centering
\begin{tabular}{|c|}
\hline preamble \\ \hline
\hline package description$_{1}$ \\ \hline
\hline package description$_{2}$ \\ \hline
 \multicolumn{1}{c}{\ldots}  \\ 
\hline package description$_{i}$\\ \hline
\hline request\\ \hline
\end{tabular}
\caption{Structure of the CUDF stanzas}
\label{formal:cudfstruct}
\end{figure}

Every stanza begins with a key of their type (\verb+preamble+, \verb+package+, \verb+request+), followed by several lines ending in a empty line.
Each stanza line defines a set of properties using key/value pairs separated by the delimiter ``:``, these are in no defined order.
This structure is presented in figure \ref{formal.cudfproperties}

\begin{figure}[htp] 
\begin{center}
\begin{alltt}
\textit{stanza}: \textit{value}
\textit{key1}: \textit{value1}
\ldots
\textit{key2}: \textit{value2}

\textit{stanza}: \textit{value}
\textit{key1}: \textit{value1}
\ldots
\end{alltt}
  \caption[CUDF property structure]{Structure of CUDF properties}
  \label{formal.cudfproperties}
\end{center}
\end{figure}

\subsubsection{Package Description}
The package description stanza starts with the \verb+package+ key followed by the value of package name, a non-empty string.
The only mandatory property of this stanza is defined with the key \verb+version:+ who's value is the version of the package, a positive integer.
The pair $\langle name, version \rangle$ of a package is unique, there can exist at most one package description for a given name and version.
This name and version pair is the basic unit for the CUDF document. 

The most relevant properties for a package are defined by the keys:
\begin{itemize}
  \item \verb+installed+: this Boolean property states whether the package is installed or not in the system. 
  As the CUDF document describes all packages, installed and not, the set of packages with the property \verb+installed: true+ defines the current component system.
  \item \verb+keep+: this property defines the keep constraints as defined in section \ref{formal:step}
  Some possible values\footnote{The keep property can also be assigned feature or none} are:
	  	\begin{itemize}
	  		\item \verb+version+: keep this particular version of the package installed
	  		\item \verb+package+: keep at least one version of this package installed
		\end{itemize}
  \item \verb+provides+: this is a list of names of features or services that this package provides separated by the delimiter ``,''.
  e.g. \verb+provides: a, b, c+ means this package provides the feature \verb+a+, \verb+b+ and \verb+c+.
  Each feature name can be accompanied by a version, to state what particular version is provided, e.g. \verb+a=10+ means feature \verb+a+ version \verb+10+ is provided.
  When no version is specified for a feature, it is defined as all possible versions are provided.
  \item \verb+depends+: this is a list of lists of \textbf{package formulae}, first separated by the delimiter ``,'' then delimiter ``|''.
  The list represents a conjunction of disjunctions (conjunctive normal form), with each formulae defining a set of packages.
  A package is defined using a name of either a package or feature $n$ and optionally an operator and version of the form  $n = v$, $n != v$, $n > v$, $n < v$, $n >= v$, or $n <= v$.
  For example, \verb+depends: a , b | c < 10+ means the package depends on a packages (or features) with the name \verb+a+ AND \verb+b+ or \verb+c+ less than version \verb+10+.  
  \item \verb+conflicts+: is a list of \textbf{package formulae} as defined above separated by the delimiter ``,''.
  For example, \verb+conflicts: a , c > 2+ means this package conflicts with all packages (or features) with the name \verb+a+ AND \verb+c+ greater than the version \verb+2+
\end{itemize}

\subsubsection{Preamble}
The preamble stanza starts with the key \verb+preamble:+, no value is necessary for this key.
The main function of this stanza is to provide the description of addition properties and their types, that can be added to the package descriptions.
This is described under the key \verb+property+ where the value is a list of properties defining their name, type and optionally a default value separated by the delimiter ``,''.
Each addition property of name $n$ and type $t$ and optionally a default value is a pair or triple separated first by ``:`` then ``=`` where the default is wrapped in ``[`` and ``]''.

For example, \verb+property: size: int, bugs: int = [0]+ defines the integer property of \verb+size+ and the integer property of \verb+bugs+ with the default value \verb+0+.
Given this preamble, package descriptions can now use these properties as shown in figure \ref{formal.cudfextensionexample}

\begin{figure}[htp] 
\begin{center}
\begin{alltt}
preamble:
property: size: int, bugs: int = [0]

package: textEditor
version: 1
bugs: 10
size: 2
depends: spellCheckerService

\ldots

\end{alltt}
  \caption[Example of Extendable CUDF syntax]{Example of Extendable CUDF syntax}
  \label{formal.cudfextensionexample}
\end{center}
\end{figure}

\subsubsection{Request}
The request stanza starts with the \verb+request:+ key, no value is required for this key.
This stanza contains three properties that define the request to change the system,
each is a list of \textbf{package formulae} separated by the delimiter ``,'' such that:
\begin{itemize}
  \item \verb+install+: is a request to install a set of packages into the system,
  e.g. \verb+install: a, b >= 2+ means install component \verb+a+ and component \verb+b+ of version two or greater.
  \item \verb+remove+: is a request to remove a set of packages from the system 
  e.g. \verb+remove: a , b = 2+ means remove all components with name \verb+a+ and component \verb+b+ of version two.
  \item \verb+upgrade+: is a request to remove all versions of a package and install greater than or equal versions of the package,
  e.g. \verb+upgrade: a+ means to remove all packages of name \verb+a+ and install one package of equal or greater versions to that of the maximum version of the 
\end{itemize}

%%%Installation of multiple components
CUDF as a specification is probably most derived from the Debian package format, described in section \ref{background.models}.
A significant difference between these two specifications is that the CUDF specification does not explicitly state that only one version of a package can be installed.
This is a practical decision as other component models, like Red Hat Package manager and OSGi, allow the installation of multiple versions of the same component.
However, although these models do allow this, a system that does have multiple versions of a package installed can be seen as less optimal to one that doesn't. 
This is then left up to the optimisation when finding a solution to try to identify solutions with only one version installed per component.

%%%Upgrading with multiple packages
The semantics of upgrading a package in CUDF are the most complicated request to define.
This is due to the possibility of having multiple installed versions of a component installed.
If a package is requested to be upgraded and there is only one version, then either the package is not altered or a package with the same name and a higher version replaces it.
However, if there are multiple versions of a package that is requested to be upgraded, the most significant constraint is that only one version of the package can exist in the final system.
The second constraint is that the version that remains in the system is of greater or equal value of the maximum installed version of the component.
This means that all versions lower than the highest installed version will be removed, and the highest installed version can be replaced with only a higher version.

%%%Upgrading can do nothing to a system
These constraints have an interesting side effect on a system where there exists at most one version per component,
an upgrade request may not change the system.
This makes the definition of criteria for optimisation of a solution an important aspect of upgrading the system.
As any criteria that express that minimal change is the most important has the possibility of not changing the system with an upgrade request.

\subsection{CUDF Specification}
In this section, the model presented in section \ref{formal.step} is extended and mapped to this CUDF specification.

The first definition is that of the CUDF document, which is made up of three stanzas preamble, a set of package descriptions and a request, 
i.e. $CUDF = \langle preamble, PD, request \rangle$ where $PD$ is the set of package description stanzas.
Each stanza is made of a set of properties, where each property is a tuple of key/value, i.e. $stanza = \{\langle $\verb+key+, \verb+value+$\rangle\}$.
This syntax is described in figures \ref{formal:cudfstruct} and \ref{formal.cudfproperties}.

The function $property$ is defined such that it takes a stanza and key and returns a value,
i.e. $property: STANZA \times key \rightarrow value$ such that given a stanza $s$ and key \verb+key+,
$property(s,$\verb+key+$) = $ \verb+value+ where $\langle$\verb+key+, \verb+value+$ \rangle \in s$.

Components in a CUDF document, as defined in section \ref{formal.step} each component is defined by a name and version.
The function $c$ takes a package description stanza and returns a component, such that $c(pd) = \langle property(pd, $\verb+name+$), property(pd, $\verb+version+$) \rangle$.
Therefore given $PD$ is the set of package descriptions in a CUDF document,
the set of components $\mathbb{C}$ equals $[ c(pd) \mid pd \in PD]$.

A CUDF document not only described the set of all components, but the bub set of components that defines the current system.
The set of components in the system (denoted as $X$) is defined using the key \verb+installed+,
such that given a package description $pd$ and component $c = c(pd)$, $c \in X$ iff  $property(pd, $\verb+installed+$)$ equals \verb+true+.
That is, only package descriptions that contains the value \verb+true+ for key \verb+installed+ are mapped to components in the component system.

\subsubsection{Features}
%%%Features or services
CUDF specifies an additional aspect to component relationships, that of a feature or service.
This attributes a set of features to a component, where each feature is represented by a name, and a set of versions.
Unlike a component, which has exactly one version, a component can provide multiple versions of a feature.

A feature is then a pair $(n,V)$ where all features are in the set $F$, $n$ is the name of the feature, and $V$ is a subset of positive integers representing versions, i.e $V \subseteq \mathbb{N}$.
The features provided by a component are defined as the property with the key \verb+provides+, whose value follows the BNF grammar \verb+Provides+, shown in figure \ref{formal.cudfprovidessyntax}.

\begin{figure}[htp] 
\begin{center}
\begin{alltt}
Provides ::= Feature ["," Feature]*
Feature :: = FName ("=" Ver)?
\end{alltt}
  \caption[Provides syntax]{CUDF Provides syntax}
  \label{formal.cudfprovidessyntax}
\end{center}
\end{figure}

Each feature represented by \verb+Feature+ is in the form ``\verb+FName+'' or  ``\verb+FName+ = \verb+Ver+'', 
which is mapped to a feature $($\verb+FName+$,\mathbb{N})$ or $($\verb+FName+$,\{$\verb+Ver+$\})$ respectivly.
That is, a component provides all versions of a feature if no version is defined, where if a version is defined it provides a singleton set of that version. 
The list of features defined by \verb+Provides+, in the form ``\verb+Feature+$_1$,\ldots,\verb+Feature+$_n$'', can then be mapped to a set of features.
This property is wrapped with the function $providedFeatures$,
such that given a package description stanza $pd$ and component $c = c(pd)$, $providedFeatures(c)$ equals the set of features mapped from $property(pd,$\verb+provides+$)$.

\subsubsection{Package formula}
A package formula is a query to retrieve a set of components from a CUDF document.
This formula is the mechanism to define all relationships and requests in the CUDF specification,
and is then necessary to define outside of a particular property definition. 

Each package formula is syntactically defined as \verb+PkgF+ in the BNF grammar in figure \ref{formal.cudfpackageformulasyntax}.
This also defines \verb+PkgName+ as the package name, \verb+Ver+ as the package version, and \verb+RelOp+ as a relational operator expressing the constraint of the query.

\begin{figure}[htp] 
\begin{center}
\begin{alltt}
PkgF ::= PkgName (RelOp Ver)?
RelOp ::=  "=" | "!=" | ">=" | ">" | "<=" | "<"
\end{alltt}
  \caption[Package Formulae syntax]{Structure of CUDF package Formulae syntax}
  \label{formal.cudfpackageformulasyntax}
\end{center}
\end{figure}

The syntax of \verb+RelOp+ is parsed to a mathematical relation with the function:  
$\{$ \verb+"="+ $\rightarrow$ $=$, \verb+"!="+ $\rightarrow \not =$, \verb+">="+ $\rightarrow$ $\geq$, \verb+">"+ $\rightarrow$ $>$, \verb+"<="+ $\rightarrow$ $\leq$, \verb+"<"+ $\rightarrow$ $<$$\}$.
The package formula is in the form ``\verb+PkgName+'' or  ``\verb+PkgName+ \verb+RelOp+ \verb+Ver+'',
given \verb+RelOp+ is mapped to $op$, each form is mapped to a triple $\langle $\verb+PkgName+$,0,>\rangle$ or $\langle$\verb+PkgName+$,op,$ \verb+Ver+ $\rangle$.
That is, each package formula is a triple of name, operation and version. 
Also in the situation where \verb+Ver+ and \verb+RelOp+ are not defined, the query returns searches for all version greater than 0.

%%%Find all packages which satisfy the package formula
A package formula (whose set is denoted as $PF$) can be mapped to a set of components through the function $packages: PF \rightarrow 2^{\mathbb{C}}$,
which takes a package formula and returns all packages that conform to its definition.
This is defined as:
given a set of components $\mathbb{C}$ defined in a CUDF document, and a package formulae $\langle n,v,op\rangle$
$packages(\langle n,v,op\rangle) = [\langle n_c,v_c \rangle \mid \langle n_c,v_c \rangle \in \mathbb{C} \mbox{ and } n_c = n \wedge v_c op v]$.
That is, any component whose name is the same as that in the package formulae and whose version is related through the defined $op$ will be included in the set.

%%%Find all packages who provides a feature which satisfies the package formula
A package formula does not distinguish between components and features, so a package formulae is also used to search for components providing a feature.
The function $features: PF \rightarrow 2^{\mathbb{C}}$ also takes a package formula and returns a set of components that provide the described feature.
Given a set of components $\mathbb{C}$ defined in a CUDF document, and a package formulae $\langle n,v,op\rangle$
$features(\langle n,v,op\rangle)$ equals 
$[c \mid c\in \mathbb{C} \mbox{ and } (n,V) \in providedFeatures(c) \wedge \exists v_f \in V \mbox { such that } v_f op v ]$.
That is, given a package formula, 
$features$ returns a set of components that provide a feature where the name of the feature is in the package formula and the exists a version of that feature that satisfies the relation. 

Give the functions $packages$ and $features$ the resolution of a package formula $pf$ can be described as the function $packagesThatSatisfy(pf) = packages(pf) \cup features(pf)$.
That is, $packagesThatSatisfy$ takes a package formula and returns a set of packages that either directly satisfy it, or that provide a feature that satisfy the it.

\subsubsection{Relationships}
Given the function $packagesThatSatisfy$, the CUDF document can be mapped to the relationship constraints described in section \ref{formal.step}.

There are three constraints:
\begin{itemize}
  \item keep constraint: derived from the property \verb+keep+ of a package descriptions where property \verb+installed+ is true.
  \item dependency constraint: derived from the property \verb+depends+ from all package descriptions in a CUDF document.
  \item conflict constraints: derived from the property \verb+conflicts+ from all package descriptions in a CUDF document.
\end{itemize}

\paragraph{Keep Constraint}
The keep constraint states that a system should maintain either a specific package, or a version of a package in the system.
In the CUDF specification only the keep constraints of installed components are considered.

The function $keeppf$ is defined to take a component and to return a package formula such that can be used to create a keep constraint.
Given a package description $pd$, component $\langle n,v \rangle = c(pd)$, $keeppf$ is defined such that:
\begin{itemize}
	\item if $property(pd,$\verb+keep+$)$ equals \verb+version+: $keeppf(c) = \langle n, =, v \rangle$
	\item if $property(pd,$\verb+keep+$)$ equals \verb+package+: $keeppf(c) = \langle n, >, 0 \rangle$
\end{itemize}

A keep constraint, of the form $c_1 \vee \ldots \vee c_n$, for a package is then created using the function $keep$,
where $keep(c) = \bigvee packages(keeppf(c))$.
That is, the package formula from $keeppf$ is used to query for a set of packages whose disjunction forms the keep constraint.
This creates a constraint that forces one of the resulting packages to be included in the system.

To create the set of all keep constraints, all installed packages must be mapped to the function $keep$.
Given a set of components $\mathbb{C}$ defined in a CUDF document, 
the set of component $X$ which denotes all installed components, is used to create the set of keep constraints $\bigcup \limits_{c \in X} keep(c)$.

\paragraph{Dependency Constraint}
The dependency constraints of a set of components $\mathbb{C}$ defined in a CUDF document are mapped using the property \verb+depends+.
The syntax of the \verb+depends+ property value is defined as \verb+Depends+ and is presented in figure \ref{formal.cudfdependssyntax}.

\begin{figure}[htp] 
\begin{center}
\begin{alltt}
Depends ::= PkgFList ("," PkgFList)*
PkgFList ::= PkgF ("|" PkgF)*
\end{alltt}
  \caption[CUDF Package depends syntax]{Structure of CUDF depends syntax}
  \label{formal.cudfdependssyntax}
\end{center}
\end{figure}

This syntax shows that the depends property is a list of package formula (as defined in figure \ref{formal.cudfpackageformulasyntax}) lists, first separated by the delimiter ``,'' then by the delimiter ``|''.
Each package formula list maps to a single dependency constraint, as described in section \ref{formal.step}.

The syntax of \verb+PkgFList+ is in the form ``\verb+PkgF+$_1$ | \ldots | \verb+PkgF+$_n$''.
Given \verb+PkgF+$_i$ maps to $pf_i$, \verb+PkgFList+ maps to a set of package formulae $pkgflist$ such that $pkgflist = \{pf_1,\ldots, pf_n\}$
Therefore, the property \verb+Depends+ of the form ``\verb+PkgFList+$_1$ ,\ldots, \verb+PkgFList+$_n$'',
where \verb+PkgFList+$_i$ maps to a set of package formulae $pkgflist_i$, \verb+Depends+ maps to a set of sets of package formulae $listpkgflist = \{pkgflist_1,\ldots,pkgflist_n\}$.

The function $dependsOn$ is then defined such that it takes a component and a package list to create a single dependency constraint of the form $a \rightarrow c_1 \vee \ldots \vee c_n$ as defined in section \ref{formal.step}.
Given a component $a$ and a package list $pkgflist$, 
$dependsOn(a,pkgflist)$ equals $a \rightarrow \bigvee  \bigcup \limits_{pkgf \in pkgflist} packagesThatSatisfy(pkgf) $.
That is, $dependsOn(a,pkgflist)$ takes a the union of all components that satisfy a contained package formula to create the dependency constraint. 

The function $depends$ is then defined to return a set of all dependency constraints for a component.
Given a package description $pd$, a component $a = c(pd)$, the set of sets of package formulae mapped from $property(pd,$\verb+depends+$)$ denoted as $listpkgflist$,
$depends(a)$ is defined to equal $\bigcup \limits_{pkgflst \in listpkgflist} dependsOn(a,pkgflst)$.
That is, the set of dependency constraints for a given component is the union of all constraints created from individual package formulae lists.

Finally, the set of all dependency constraints is defined given the set of all components $\mathbb{C}$ defined in a CUDF document,
such that the set of dependency constraints equals $\bigcup \limits_{c\in \mathbb{C}} depends(a)$.

\paragraph{Conflict Constraint}
The conflict constraints of a given component defines the relationship where it will not be functional with another component in the system.
The syntax of the \verb+conflicts+ property value is defined as \verb+Conflicts+ and is presented in figure \ref{formal.cudfconflictsyntax}.

\begin{figure}[htp] 
\begin{center}
\begin{alltt}
Conflicts ::= PkgF ("," PkgF)*
\end{alltt}
  \caption[CUDF Package conflicts syntax]{Structure of CUDF conflicts syntax}
  \label{formal.cudfconflictsyntax}
\end{center}
\end{figure}

This syntax is the same as defined above in the depends property syntax for \verb+PkgFList+ except it uses a different delimiter. 
The mapping is also the same, where the property value is in the form \verb+PkgF+$_1$ , \ldots , \verb+PkgF+$_n$ and maps to a set of package formulae $conflictPkgF$.

Given a package description $pd$, a component $a = c(pd)$ and the set $conflictPkgF$ that is mapped from the package descriptions \verb+conflicts+ property.
The function $conflictsWith$ is defined to return a set of conflict constraints, each of the form $a \rightarrow \neg c$ as defined in section \ref{formal.step}.
Such that, $conflictsWith(a) = [a \rightarrow \neg c \mid c \in packagesThatSatisfy(pf) \mbox{ and } pf \in conflictPkgF]$.
That is, a component conflicts with any component that satisfies a package formula in defined in its \verb+conflicts+ property.

Finally, given the $\mathbb{C}$ is the set of all components in a CUDF document,
the set of all conflict constraints for a CUDF document is defined as $\bigcup \limits_{c\in \mathbb{C}} conflicts(a)$.

\subsubsection{Request}
In section \ref{formal.step}, this request, denoted as $\Delta$, was simplified to only include the installation of one component, or removal of one components.
However, in a CUDF document there are three possible requests, install, remove, or update, which can be defined using complex sets of package formulas.
Here, the definition in section \ref{formal.step} of the request constraints are extended to include the semantics of the possible requests of a CUDF document.

In a CUDF document there exist exactly one request stanza, which has three optional properties \verb+install+, \verb+remove+ and \verb+update+ respectively.
Each value for these properties has the same syntax, shown in figure \ref{formal.requestssyntax}.

\begin{figure}[htp] 
\begin{center}
\begin{alltt}
Install ::= PkgFList
Remove ::= PkgFList
Update ::= PkgFList
PkgFList ::= PkgF ("," PkgF)*
\end{alltt}
  \caption[CUDF Package conflicts syntax]{Structure of CUDF conflicts syntax}
  \label{formal.requestssyntax}
\end{center}
\end{figure}

The syntax of \verb+PkgFList+ is exactly the same defined above for the conflicts property, and can be mapped to the set of package formulae $pkgflist$.
The installs property maps to the package formulae set  $installpkgflist$; the remove property maps to the package formulae set $removepkgflist$;
the update property maps to the package formulae set  $updatepkgflist$.

\paragraph{Install}
An install constraint is of the form $a_1 \vee \ldots \vee a_n$,
this is defined semantically as $a_1 \in E_{R \cup \Delta}(X)$ or \ldots or $a_n \in E_{R \cup \Delta}(X)$.

The function  $install(pf)$ is defined to take a package formula $pf$ and return one install constraint such that $\bigvee packagesThatSatisfy(pf)$.
Each package formulae in the set $installpkgflist$ creates one install constraint,
therefore the set of all install constraints is defined as $\bigcup \limits_{pf \in installpkgflist} install(pf)$

\paragraph{Remove}
A remove constraint is of the form $\neg a$,
this is defined semantically as $a \not \in E_{R \cup \Delta}(X)$.

The function $remove(pf)$ is defined to take a package formula $pf$ and returns a set of remove constraints such that $[\neg a \mid  a \in packagesThatSatisfy(pf)]$.
Then the set of remove constraints is the union of all constraints created from the $removepkgflist$ set, i.e. $\bigcup \limits_{pf \in removepkgflist} remove(pf)$.

\paragraph{Upgrade}
%%%This is a difficult to express
The upgrade semantics of CUDF are the most difficult to express, this is because it more closely resembles an optimisation criteria not a hard constraint on the system.
i.e. to find if the upgrade request is sucessful it requires measuring the ``upgradeness'' of the system, not only satisfying some set of constraints.
However, there are some constraints that are expressed in the CUDF semantics, in order to ensure the system is upgraded:
For each package formula $pf$ in $updatepkgflist$, two types of constraints must be satisfied:
\begin{enumerate}
  \item exactly one package that satisfies $pf$ is in the system
  \item no packages with a lesser version than the highest currently installed component with the name from $pf$ can be included.
\end{enumerate} 

Creating these constraints is a more complex challenge than the previous requests, as they require the excelusive-or operator $\oplus$, and comparison to the installed system. 

The first type of constraint is of the form $a_1 \oplus \ldots \oplus a_i$, 
whose defined semantics are $\{a_1,\ldots,a_i\} \subseteq E_{R \cup \Delta}(X)$ iff $|\{a_1,\ldots,a_i\}| = 1$.
That is, a set of exactly one component that satisfies can be included in the resulting system.
Given the package formula $pf$, the function $upgrade_1$ is defined to return an upgrade constraint,
such that $upgrade_1(pf) = \bigoplus packagesThatSatisfy(pf)$

The second type of constraint is of the form $\neg a$,
this is defined semantically as $a \not \in E_{R \cup \Delta}(X)$.

Given the current system $X$ and the package formula $\langle n,v,op \rangle$ the set of installed packages with the same name as the package formula are defined as 
$named(X,n) = X \wedge packagesThatSatisfy(\langle n,0,> \rangle)$.
The greatest version of packages in this set is defined 
$maxversion(X,n) = cv$  such that $\langle cn,cv \rangle \in named(X,n)$ and $\nexists \langle cn',cv' \rangle \in named(X,n)$ where $cv' > cv$.
The set of components that are below this maximum version is then defined as
$lowerC(X,n) = [\langle cn,cv \rangle \mid \langle cn,cv \rangle \in \mathbb{C} \mbox{ and } cv < maxversion(X,n)]$.
This leads to the definition, $upgrade_2(X,\langle n,v,op \rangle) = [\neg a \mid a \in lowerC(X,n)]$.

The set of all upgrade constraints is then the union of all constraints created for all package formulae in $updatepkgflist$,
i.e. $\bigcup \limits_{pf \in updatepkgflist} (upgrade_1(pf) \cup upgrade_2(X,pf))$.

\subsubsection{Full Example}
%%%TODO


\subsection{Mancoosi Optimisation Format}
%%%Describe the format by which mancoosi has required optimisation criteria formatted
The description of how to represent the optimisation criteria is not defined in the CUDF specification.
However, for the purpose of the MISC competition, the Mancoosi organisation did define a syntax and specification to represent different optimisation criteria.
This representation was designed to be passed to the CUDF solver on the command line, therefore it has a simple BNF grammar as described in figure \ref{formal.optbnf}:

%\usepackage{graphics} is needed for \includegraphics
\begin{figure}
\begin{center}
\begin{alltt}
Optimisation ::= criteria (, criteria)*
\end{alltt}
  \caption[CUDF Package conflicts syntax]{Structure of CUDF conflicts syntax}
  \label{formal.optbnf}
\end{center}
\end{figure}


