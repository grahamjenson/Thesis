\chapter{Formal Model of Component System Evolution}
\label{formal}
\epigraph{In theory there is no difference between theory and practice. In practice there is.}
{\textit{Jan L. A. van de Snepscheut}}
In order to facilitate the study of the component system evolution process, a novel formal model has been developed.
Having such a model allows the definition of concepts, and enables the discussion and investigation of component system evolution.

The component evolution process is modeled as a repetitive selection of solutions to evolution problems.
The two distinct parts of this model are the evolution problem, and the solution selection.
These are presented in sections \ref{formal.step} and \ref{formal.opt} respectively.

To represent an evolution problem and the criteria through which a solution is selected,
the Common Upgradeability Description Format (CUDF) \citep{treinen2009common}
and the Mancoosi Optimisation Format\footnote{http://www.mancoosi.org/misc-2011/criteria/ accessed 6/3/2012} (MOF) are used as languages.
Both CUDF and MOF are presented and mapped to the formal model in section \ref{formal.cudf}. 

\section{Formal Model of Component System Evolution}
\label{formal.step}
Consider the problem where a user wants to install a text editor component into their system.
The selected text editor has a dependency on a spell checker;
meaning that a spell checker component must be installed for the text editor to be functional.
There are three spell checker components available that satisfy this dependency.
This means that at least one of these spell checkers must be selected for installation as well.
How can the user select which spell-checker to install? 

A formal model that can describe such evolution problems is presented in this section.

\subsection{Evolution Problem}
In this section a series of definitions are presented that make up the model of component system evolution.

%%%What a component is
First a component is must be defined.
\begin{defs}
\label{formal.componentdef}
Let $\mathcal{N}$ be the set of names, and $\mathcal{V}$ be the set of versions \footnote{Names and versions are finite alphanumeric sequences which can contain special some characters like ``.'' and ``-''}; 
a \textbf{component}\footnote{In recursive component models, such as Fractal \citep{Quma2006}, the definition ``component'' would include the concept of a composite component.
A composite component $c$ is defined as a set of components, i.e. $c \subseteq \mathbb{C}$.
This definition is not included in this model, though it may be possible to be modified to include it if required.} 
is an element of $\mathbb{C}$, where $\mathbb{C} = \mathcal{N} \times \mathcal{V}$. 
\end{defs}
A component $a$ is then a pair $\langle n,v \rangle$, where $n$ is its name and $v$ is its version.
The characters  $a,b,c,\ldots$ are used to denote components, $m,n,o,\ldots$ used to denote names, and $v,w,x,\ldots$ used to denote versions.

\begin{defs}
\label{formal.componentsystemdef}
A \textbf{component system} is a finite subset of components, e.g. $\alpha$ is a component system and $\alpha \subseteq_{finite} \mathbb{C}$. 
\end{defs}
The characters $\alpha,\beta,\gamma$ are used to denote component systems.

Constraints are used to restrict possible systems.
\begin{defs}
\label{formal.constraintdefs}
A \textbf{constraint} is set of component systems, e.g. $con$ is a constraint and $con \subseteq 2^{\mathbb{C}}$.
\end{defs}

Only certain types of constraints are allowed in this model, these types are:
\begin{enumerate}
  \item $\neg a := \{\alpha \in 2^{\mathbb{C}} \mid a \not \in \alpha \}$ \label{formal.removeconstraint}.
  \item $a \rightarrow \neg c := \{\alpha \in 2^{\mathbb{C}} \mid \mbox{if } a \in \alpha \mbox{ then } c \not \in \alpha\}$ \label{formal.conflictconstraint}.
  \item $a_1 \vee \ldots \vee a_n := \{\alpha \in 2^{\mathbb{C}} \mid a_1 \in \alpha \mbox{ or }\ldots \mbox{ or } a_n \in \alpha\}$ \label{formal.keepconstraint}.
  \item $a \rightarrow c_1 \vee \ldots \vee c_n := \{\alpha \in 2^{\mathbb{C}} \mid \mbox{if } a_1 \in \alpha \mbox{ then }  c_1 \in \alpha \mbox{ or } \ldots \mbox{ or } c_n \in \alpha\}$ \label{formal.dependencyconstraint}.
  \item $a_1 + \ldots + a_n = 1 := \{\alpha \in 2^{\mathbb{C}} \mid |\{a_1,\ldots,a_n\} \cap \alpha| = 1\}$ \label{formal.upgradeconstraint}.
\end{enumerate}
The set of constraints is restricted to these types as only these are necessary to represent required evolution problems. 

\begin{defs}
\label{formal.constraintdefs}
A component system, $\alpha$, \textbf{satisfies} a constraint $con$, iff $\alpha \in con$.
\end{defs}

\begin{defs}
An \textbf{evolution problem}, $EP$, is a finite set of constraints.
\end{defs}

\begin{defs}
A \textbf{solution}, $\alpha$, to an evolution problem, $EP$, is a component system that satisfies all constraints in the evolution problem, i.e. $\alpha \in con_i$ for all $con_i \in EP$.  
\end{defs}

\begin{defs}
An evolution problem is \textbf{unsatisfiable} if there exists no solution to it.  
\end{defs}


\subsubsection{Example}
Assume the evolution problem $EP = \{con_1,con_2\}$.
The constraints $con_1$ is $b$ (constraint type \ref{formal.keepconstraint}), which is defined as the set of all component system with $b$ in them.
The constraint $con_2$ is $a \rightarrow c$ (constraint type \ref{formal.dependencyconstraint}), which is defined as the set of all component systems where if $a$ is included, then $c$ is included.
The intersection of these two constraints includes all component systems that are solutions to $EP$, 
such as $\{b\}$, $\{a,b,c\}$ and $\{a,b,c,d\}$.

\subsubsection{Solving Evolution Problem is NP-Complete}
Finding a solution that satisfies all constraints in an evolution problem is NP-Complete \citep{cook1971}.
This can be shown by mapping the evolution problem to a known NP-Complete problem called one-in-three satisfiability.
This problem is defined by \cite{Schaefer1978} as:
\begin{quote}
Given sets $S_1, \ldots, S_n$ each having at most 3 members, is there a subset $T$ of the members such that for each $i$, $|T \cap S_i|  =  1$.
\end{quote}

This can be mapped to an evolution problem where:
\begin{quote}
Given sets $S_1, \ldots, S_n$ each containing 3 components, and constraints $con_1,\ldots,con_n$
such that for each $i$, $S_i = \{a,b,c\}$ iff $con_i$ equals constraint $a + b + c = 1$ (constraint type \ref{formal.upgradeconstraint}).
A set of components $\alpha$ is such that for each $i$, $|\alpha \cap S_i|  =  1$ iff $\alpha$ is a solution to the evolution problem $EP = \{con_1,\ldots,con_m\}$.
\end{quote}
This mapping shows that an evolution problem can be NP-Complete, but not all evolution problems are so difficult.
A trivial evolution problem could be constructed that could be solved efficiently.
For example, an evolution problem with not explicit (or implicit) component conflicts 
(constraint types \ref{formal.removeconstraint},\ref{formal.conflictconstraint} and \ref{formal.upgradeconstraint}), can create simple problems \citep{abate2011}.

\subsection{Constraints, Relationships, and Requests}
\label{formal.constraints}
An evolution problem is made of two sets of constraints; constraints created by the request the user has made to change the system, 
and constraints created from relationships between components.

\begin{defs}
The set of \textbf{all user requests}, $\Delta$, is the set of all constraints where each constraint in $\Delta$ is either:
\begin{itemize}
  \item an \textbf{installation} request of constraint type \ref{formal.keepconstraint}, e.g. $a \vee b$ is a request by the user to install component $a$ or $b$ into the system.
  \item a \textbf{remove} request of constraint type \ref{formal.removeconstraint}, e.g. $\neg a$ is a request by the user to remove component $a$ from the system.
  \item an \textbf{upgrade} request of constraint type \ref{formal.upgradeconstraint}, e.g. $a + b = 1$ is a request by the user to upgrade a component to either $a$ or $b$, but not both.
\end{itemize}
\end{defs}


\begin{defs}
The set of \textbf{all component relationships}, $\Omega$, is a set of all constraints where each constraint in $\Omega$ is either: 
\begin{itemize}
  \item a \textbf{keep} relationship of constraint type \ref{formal.keepconstraint}, e.g.  $a \vee b$ mean keep component $a$ or $b$ in the system.
  \item a \textbf{dependency} relationship of constraint type \ref{formal.dependencyconstraint}, e.g.  $a \rightarrow b \vee c$ means $a$ depends on component $b$ or $c$.
  \item a \textbf{conflict} relationship of constraint type \ref{formal.conflictconstraint},  e.g. $a \rightarrow \neg b$ means $a$ conflicts with component $b$.
\end{itemize}
\end{defs}

At any point in time, there exists only a finite set of components. 
\begin{defs}
$\mathbb{C}_t$ is the finite set of components that exist at time $t$, $\mathbb{C}_t \subset_{finite} \mathbb{C}$
\end{defs}

\begin{defs}
Given time $t$, and the set of components $\mathbb{C}_t$, the set of \textbf{component relationships w.r.t. time} is $\Omega_{t}$, where $\Omega_t = \{con \cap 2^{\mathbb{C}_t} \mid con \in \Omega\}$
\end{defs}

\begin{defs}
Given time $t$, and the set of components $\mathbb{C}_t$, the set of \textbf{user requests w.r.t. time} is $\Delta_{t}$, where $\Delta_t = \{con \cap 2^{\mathbb{C}_t} \mid con \in \Delta\}$
\end{defs}

\begin{defs}
Given a time $t$, a \textbf{user request}, $\delta_t$, is a finite set of user requests at time $t$, where if $con \in \delta_t$ then $con \in \Delta_t$.
\end{defs}

\begin{defs}
Given a time $t$, a set of \textbf{component relationships}, $\omega_t$, is a finite set of component relationships at time $t$, where if $con \in \omega_t$ then $con \in \Omega_t$.  
\end{defs}

An evolution problem, $EP$, can be constructed by combining a user request $\delta_t$ and a set of component relationships $\omega_t$, such that $EP = \delta_t \cup \omega_t$.

\subsubsection{Example}
At time $t$, the components $a$ and $b$ exist, therefore $\mathbb{C}_t = \{a,b\}$.
The set of all component systems at time $t$ is $2^{\mathbb{C}_t} = \{\{\},\{a\},\{b\},\{a,b\}\}$.
A component relationship constraint, $con_1 \in \Omega$, is defined as $a \rightarrow b \vee d$.
The constraint $con_1$ is satisfied by the component systems $\{a,b\}$, $\{a,b,d\}$ and $\{a,d\}$.
The constraint $con_1' \in \Omega_t$, is such that $con_1' = con_1 \cap 2^{\mathbb{C}_t}$, where $con_1' = \{\{\},\{b\},\{a,b\}\}$.

The user request constraint $con_2$ is defined as $a$, which is satisfied by the component systems $\{a\}$ and $\{a,b\}$.
The constraint $con_2' \in \Delta_t$, is such that $con_2' = con_2 \cap 2^{\mathbb{C}_t}$, where $con_2' = \{\{a\},\{a,b\}\}$.

A set of component relationships $\omega_t = \{con_1'\}$, and a user request $\delta_t = \{con_2'\}$, make the evolution problem $\delta_t \cup \omega_t$.
There only solution to $\delta_t \cup \omega_t$ is the component system $\{a,b\}$.  

\subsection{Component System Evolution}
\label{formal.evo}
A component system is evolved from one system to another to satisfy an evolution problem consisting of a user request and set of component relationships.

\begin{defs}
Given a component system $\alpha$, an \textbf{evolution preference order} is defined w.r.t. $\alpha$,  $\prec_{\alpha} \subseteq 2^{\mathbb{C}} \times 2^{\mathbb{C}}$.
\end{defs}

\begin{defs}
Given a component system $\alpha$, an evolution preference order w.r.t. $\alpha$, $\prec_{\alpha}$, and an evolution problem $EP$;
an \textbf{optimal} component system, $\beta$, is a solution to $EP$, where there exists no other solution to $EP$, $\beta'$, such that $\beta \prec_{\alpha} \beta'$.   
\end{defs}

\begin{defs}
Given a component system $\alpha_{t-1}$, an evolution preference order w.r.t. $\alpha_{t-1}$, $\prec_{\alpha_{t-1}}$, 
a user request $\delta_t$,a set of component relationships $\omega_t$, and time $t$;
the \textbf{evolution step} function $\epsilon$ returns an optimal solution, $\alpha_t$, to the evolution problem $\delta_t \cup \omega_t$, 
where $\epsilon(\alpha_{t-1},\delta_t \cup \omega_t) = \alpha_t$.
\end{defs}

\begin{defs}
Given an initial component system $\alpha_{0}$, a series of user requests $\delta_1,\ldots,\delta_{n}$, a series of sets of component relationships $\omega_1,\ldots,\omega_{n}$;
the \textbf{evolution} function $\epsilon^*$ is defined as\\
$\epsilon^*(\alpha_0,\langle \delta_1 \cup \omega_1,\ldots,\delta_{n} \cup \omega_n \rangle)$ $=$ $\epsilon(\epsilon(\ldots \epsilon(\alpha_0,\delta_1 \cup \omega_1),\ldots),\delta_n \cup \omega_n)$
$=$ $\alpha_n$.
\end{defs}

A caveat to the evolutionary step function occurs if it is unsatisfiable.
A possible solution to resolve this situation is:
Given an evolutionary problem $\delta_t \cup \omega_t$, and the component system $\alpha_{t-1}$, if $\delta_t \cup \omega_t$ is unsatisfiable, 
then $\epsilon(\alpha_{t-1},\delta_t \cup \omega_t) = \alpha_{t-1}$.
This solution is implemented in current solvers, like apt-get,
where when an evolution step fails, no change is made and output describing the failure to the user is generated. 

Another caveat to this process is that a users change request should not be undone with subsequent generations.
For example, is a user requests to install component $a$, future generations should not remove $a$.
This can be a difficult task, as in the future the user may request to remove $a$, which creates an unsatisfiable problem to keep and remove $a$.
A possible solution is to give the evolutionary preference order this responsibility to ensure the maximum amount of previous user requests are satisfied.
This is a similar problem that is faced by revision function in the domain of belief revision \citep{alchourron1985logic}.
Revision functions try to preserve consistency across a set of beliefs as new, and possibly inconsistent, information is included. 
This aspect of the evolution process is not further explored in this research, though belief revision may provide inspiration for future research.

\subsubsection{Example}
%%%This makes a sometimes counter intuitive complexity
The selection of an optimal solution to an evolutionary step, may not be optimal over multiple evolutions.

This can be demonstrated with an example:
Let the evolutionary preference order select solutions with the minimum number of components altered (the symmetric difference between the solutions), 
i.e. $\beta \prec_{\alpha} \beta'$ iff $|\alpha \Delta \beta| > |\alpha \Delta \beta'|$.
Let the initial system $\alpha_0 = \{\}$.
Let a series of user requests be $\Delta_1 = \{a\}$ and $ \Delta_2 = \{d\}$. 
Let the set of constraints $\omega_1 = \omega_2 = \{a \rightarrow b_1 \vee b_2, b_1 \rightarrow \neg b_2, b_2 \rightarrow c, d \rightarrow b_2\}$.

Consider component evolution from $\alpha_0$ to $\alpha_2$;
\begin{itemize}
  \item $\alpha_0 = \{\}$
  \item $\alpha_1 = \epsilon(\alpha_0,\delta_1 \cup \omega_1)$, given the preference order $\prec_{\alpha_0}$. $|\alpha_0 \Delta \{a,b_1\}| = 2$ is optimal, therefore $\alpha_1 = \{a,b_1\}$.
  \item $\alpha_2 = \epsilon(\alpha_1,\delta_2 \cup \omega_2)$, given the preference order $\prec_{\alpha_1}$. $|\alpha_1 \Delta \{a,b_2,c,d\}| = 4$ is optimal, therefore $\alpha_2 = \{a,b_2,c,d\}$.
\end{itemize}

From $\alpha_0$ to $\alpha_1$ components $a$ and $b_1$ are added, 
and from $\alpha_1$ to $\alpha_2$ components $b_1$ is removed, and $b_2$, $c$ and $d$ are added.
The total change across the generations is therefore $6$.
This, however, is not the optimal change over the multiple evolutions.
If $\alpha_1 = \{a,b_2,c\}$, and $\alpha_2 = \{a,b_2,c,d\}$, the total change would be $4$.
This shows that although the evolution step function returned locally optimal solutions,
globally (across multiple evolutions) the selection of solutions was not optimal.

%Should define prefernce with repect to future evolution
%should define 
 
\section{Optimal Component System Selection}
\label{formal.opt}
%%%The formal definition of how to evolve a component system is complicated because it is a multicriteria problem
Any requested evolution of a component system can have many different possible resulting systems \citep{leBerre2010}.
This is because the problem is generally under-constrained \citep{Berre2008}, allowing multiple systems to satisfy evolution problems.
The order $\prec_{\alpha}$ is used to define a preference over the possible systems to select from.

%%%This is a multi criteria problem
By looking at the previously presented CDR implementations in chapter \ref{background} (such as Eclipse P2, apt-get, aptitude, and MPM), some requirements for the preference order have be extracted:
\begin{itemize}
  \item Multiple criteria to select an optimal solution.
  \item Different criteria may have different domains to be optimised for (e.g. versions, changed components, age).
\end{itemize} 

%%%A naive solution is to map all criteria to real numbers, then aggregate them through addition multiplication with weights.
A naive way to create a preference order with these requirements is to create a function for each criteria that takes a component system and returns a real number.
Then for each possible solution the function is applied to return a value, which is then aggregated through addition or multiplication (possibly with weights).
The optimal system is then the system that returns the maximum (or minimum) real value. 

%%%This has draw backs, some criteria are infinitly more important, it is not intuitive for users to weight.
This method has some drawbacks:
\begin{itemize}
  \item Information is lost in the conversion to real numbers, e.g. the reason why a specific system was selected over another.
  \item The relationships between criteria are also difficult to intuitively define, e.g. ``size $\times$ version'' combination of criteria is confusing.
  \item Altering weights to express order over criteria does not convey meaningful information about decisions or their impact.
  For example, stating ``size is $.25$ $\times$ version'' is difficult to understand as versions and size are in two separate domains, 
and greater versions are preferred where smaller size is preferred.
\end{itemize}

%%%Using composed orders
A possibly more intuitive approach to this problem is to define each criterion as an order over component systems.
Then, the preference for one criterion over another, can be expressed by combining them together using a lexicographic order.
This composition lets the user assign a preference to criteria, without having to assign arbitrary weights.
This method has been used before in the MPM \citep{abate2011} CDR implementation, and will be presented in this section.

\subsection{Criteria and Lexicographic Composition}
In this section a criterion and the lexicographic composition of criteria are formally defined.

\begin{defs}
A \textbf{ranking function}, $rank$, is a function that takes two component systems and returns a value in the set $A$, i.e. $rank : 2^{\mathbb{C}} \times 2^{\mathbb{C}} \rightarrow A$.
\end{defs}
A ranking function measures the change from a previous system to the range $A$.

\begin{defs}
\label{formal.defcriteria}
A \textbf{criterion} is a tuple $\langle rank, \leq \rangle$, where $rank$ is a ranking function, and $\leq$ (whose strict order is $<$) is a partial order over $A$.
\end{defs}
The order $\leq$ is a partial order, which is defined to be reflexive ($a \leq a$), antisymmetry ($if a \leq b and b \leq a then a = b$), and transitive ($if a \leq b and b \leq c then a \leq c$).

\begin{defs}
\label{formal.defcrittooptimal}
The \textbf{evolution preference order} $\prec_{\alpha}$ is defined given a criterion $\langle rank, \leq \rangle$, 
iff $rank(\alpha,\beta_1) < rank(\alpha,\beta_2)$ then $\beta_1 \prec_{\alpha} \beta_2$.
\end{defs}
The evolution preference order, is described with respect to a criterion.


\begin{defs}
\label{formal.defcritlex}
The \textbf{lexicographic composition} multiple criteria into a single criterion is defined with the operator $\oplus$.
Let the two criteria $crit_1 = \langle rank_1, \leq_{1} \rangle$, and $crit_2 = \langle rank_2, \leq_{2} \rangle$,
where the range of $rank_1$ is $A_1$, and the range of $rank_2$ is $A_2$.
The lexicographical composition of $crit_1$ and $crit_2$, $crit_1 \oplus crit_2$, equal the criterion $\langle rank_L,\leq_L \rangle$.
The range of $rank_L$ is $A_1 \times A_2$, and $rank_L(\alpha,\beta) = (rank_1(\alpha,\beta),rank_2(\alpha,\beta))$.
The order $\leq_L$ (whose strict order is $<_L$) is over $A_1 \times A_2$, such that $(a,b) \leq_L (a',b')$ iff $a <_1 a'$ or $(a = a'$ and $b \leq_2 b')$.
\end{defs}
$rank_L$ takes two component systems and returns a value in the set $A_1 \times A_2$, making it a ranking function.
The order $\leq_L$ is a partial order \citep{Schroder2003} over $A_1 \times A_2$.
Therefore, the tuple $\langle rank_L,\leq_L \rangle$ is a criterion.

The composition of multiple criteria, results in a criterion, which can be used to define the evolution preference order $\prec_{\alpha}$.

In section \ref{formal.mancoosioptimisationformat} a syntax to describe the composition of criteria is defined. 
In chapter \ref{implementation} an algorithm to find optimal solutions to such criteria is described.
In chapter \ref{strategies} various criteria are defined that fit within this framework.

\section{Common Upgradeability Description Format and Mancoosi Optimisation Format}
\label{formal.cudf}
%%%The description of the represnation of CUDF is described.
The Common Upgradeability Description Format (CUDF)\footnote{This specification was previously discussed in section \ref{background.models}, with an example shown in figure \ref{CUDFmetadata}.
}, 
specification presented by \citep{treinen2009common}, is a language to describe an evolution problem ($\delta_t \cup \omega_t$) and a component system ($\alpha_{t-1}$). 
The Mancoosi Optimisation Format (MOF)\footnote{http://www.mancoosi.org/misc-2011/criteria/ accessed 6/3/2012}, is a language to describe an evolution preference order ($\prec_{\alpha_{t-1}}$).
Together, CUDF and MOF provide a language in which to express enough information for the evolutionary step function.

CUDF and MOF were to allow the comparison of various solvers in the Mancoosi International Solver Competition (MISC)\footnote{http://www.mancoosi.org/misc/ accessed 6/3/2012}.
MISC competition was held in both 2010 and 2011,
and was entered by various state of the art, and legacy, solvers that had been created, or modified, to solve CUDF problems with MOF preference order.

%%%In this section\ldots
In this section the design principles and requirements of CUDF are described.
A brief overview of a CUDF document is then presented.
The CUDF specification is then mapped to our model of component system evolution.
Finally, the MOF for specifying optimisation criteria is mapped to the model.

\subsection{CUDF Design}
\label{formal.cudfDesign}
The Mancoosi organisation is a research project committed to the improvement of the process of evolving Free and Open Source Software (FOSS) distributions.
Mancoosi looks at various problems within this domain, and have made many contributions.
One such contribution was to organise a competition between solvers of the evolution problems of FOSS systems, MISC.
This designed to encourage researchers and practitioners into researching the evolution problem.

An initial problem faced by the organisers of MISC, is that a common format was required to describe evolution problems.
The design of this format would have to follow some design principles to ensure the results would be useful.
These principles are presented in \citep{treinen2009common}, and are summarised as:

\begin{itemize}
  \item \textbf{Agnostic towards component model details}: 
  The specific component model chosen to represent the problem, should be abstracted to allow many various component models to be described.  
  \item \textbf{Stay close to the original problem}: 
  The evolution problem should be the focus of the format, therefore it should not be abstracted so far as to be unrecognisable. 
  By using similar terms and syntax that already exists within the domain, the format will still directly represent the evolution problem. 
  The analysis and design of a specific problem should be able to be directly accomplished through manual investigation.
  \item \textbf{Preserve the ability for humans to inspect encoded problems}:
  This will allow greater testing and debugging, also enable the direct inspection and creation of problems by researchers.
  \item \textbf{Avoid bias towards specific implementations or techniques}:
  Specific encoding of the evolution problem, e.g. using propositional logic, or constraint programming, may create an advantage or disadvantage for a particular technique or solution.
  Since a goal of the format is to encourage the advancement of the component system evolution area, it should strive to be independent from any technique or implementation. 
  \item \textbf{Support legacy tools}:
  The comparison to tools that are already in use to solve such evolution problems, is a necessity when determining if this research is advancing the field.
  Ideally, a legacy, or current solution, should easily be able to be adapted and used with the format.
  Conversely though, the format should not stop state-of-the-art solutions from being used.
  \item \textbf{Extensible}:
  Although the format will attempt to abstract the common elements of the problem, there may still be necessary component model specific details that require inclusion.
  Also, some details are required for the optimisation of the problem, but which are not relevant to the specification of the format.
  The ability to extend the format is then required.
  \item \textbf{Transactional semantics}:
  The format should have the ability to completely represent a problem as a single unit, that can be passed to an implementation for solution.
  Also, the solution passed back should itself be a single unit, of the same format.
  This ignores aspects of the problem such as install order of the components, though this is outside the scope of the format.
  \item \textbf{Plain Text Format}:
  The use of plain text, as opposed to a binary format, will allow it to be human readable, as well as make it easier to parse and write.
  Although plain text may not be the most efficient way to encode a problem, 
  the overhead required to parse other formats may decrease the interest of researchers, or practitioners, into researching the evolution problem.
  This also aligns with the morals of the community of FOSS developers, where plain text is the universal information interchange format \citep{raymond2003art}.
\end{itemize}

The result of these design goals is the CUDF specification, presented in \citep{treinen2009common}, and described in the following sections.

\subsection{CUDF Document}
%%%Here the CUDF document is defined using text and trying to stay away from too many formalisms, just describing concepts to be used later
In this section a brief description of the CUDF format is presented.
This description is not a complete specification, but an overview of CUDF.
Some aspects of CUDF are ignored (e.g. the formal type system) as a complete redefinition of the original specification is not the goal of this section.

A CUDF document is a single plain text file, that represents all information necessary to define an evolutionary problem.
A document also contains the description of the set of components that make a component system.

A CUDF document is separated into three sections, the preamble, the package descriptions, and the request.

\begin{itemize}
  \item \textbf{preamble} stanza: Defines the additional types used in the CUDF document
  \item \textbf{package description} stanzas: typically the bulk of a CUDF document, this defines the set of components (using the FOSS term package)
  \item \textbf{request} stanza: this defines the requested evolutionary change that should be made to the components 
\end{itemize}

This structure is presented in figure \ref{formal:cudfstruct}.

\begin{figure}[htp]
\centering
\begin{tabular}{|c|}
\hline preamble \\ \hline
\hline package description$_{1}$ \\ \hline
\hline package description$_{2}$ \\ \hline
 \multicolumn{1}{c}{\ldots}  \\ 
\hline package description$_{i}$\\ \hline
\hline request\\ \hline
\end{tabular}
\caption{Structure of the CUDF stanzas}
\label{formal:cudfstruct}
\end{figure}

Every stanza begins with a key of their type (\verb+preamble+, \verb+package+, \verb+request+), followed by several lines ending in a empty line.
Each stanza line defines a set of properties using key/value pairs separated by the delimiter ``:``, these are in no defined order.
This structure is presented in figure \ref{formal.cudfstanza}

\begin{figure}[htp] 
\begin{center}
\begin{alltt}
\textit{stanza}: \textit{value}
\textit{key_1}: \textit{value_1}
\ldots
\textit{key_n}: \textit{value_n}
\end{alltt}
  \caption{Structure of  CUDF stanza}
  \label{formal.cudfstanza}
\end{center}
\end{figure}

\subsubsection{Package Description}
The package description stanza starts with the \verb+package+ key followed by the value of package name, a non-empty string.
The only mandatory property of this stanza is defined with the key \verb+version:+ who's value is the version of the package, a positive integer.
The pair $\langle name, version \rangle$ of a package is unique, there can exist at most one package description for a given name and version.

Some relevant properties for a package are defined by the keys:
\begin{itemize}
  \item \verb+installed+: this Boolean property states whether the package is included in the described component system. 
  As the CUDF document describes all packages, installed and not, the set of packages with the property \verb+installed: true+ are included in the component system $\alpha_{t-1}$.
  \item \verb+keep+: this property describes a keep relationship, as defined in section \ref{formal.constraints}.
  Some possible values\footnote{The keep property can also be assigned feature or none} are:
	  	\begin{itemize}
	  		\item \verb+version+: keep this particular version of the package installed
	  		\item \verb+package+: keep at least one version of this package installed
		\end{itemize}
  \item \verb+provides+: this is a list of names of features or services that this package provides separated by the delimiter ``,''.
  e.g. \verb+provides: n, m, v+ means this package provides the features with name \verb+n+, \verb+m+ and \verb+v+.
  Each feature name can be accompanied by a version, to state what particular version is provided, e.g. \verb+n=10+ means feature \verb+n+ version \verb+10+ is provided.
  When no version is specified for a feature, it is defined as all versions are provided.
  \item \verb+depends+: The value of this property is mapped to a set of dependency relationships, as defined in section \ref{formal.constraints}.
  The value is a list of lists of \textbf{package formulae}, first separated by the delimiter ``,'' then delimiter ``|''.
  It is a conjunction of disjunctions (conjunctive normal form), with each formulae defining a set of packages.
  A package is defined using a name of either a package or feature $n$ and optionally an operator and version of the form  $n = v$, $n$ != $v$, $n > v$, $n < v$, $n >= v$, or $n <= v$.
  For example, \verb+depends: n , m | o < 10+ means the package depends on a packages (or features) ``name \verb+=n+ AND (name \verb+m+ OR name \verb+o+ with version less than \verb+10+)''.  
  \item \verb+conflicts+: is a list of \textbf{package formulae} as defined above separated by the delimiter ``,''.
  For example, \verb+conflicts: n , m > 2+ means this package conflicts with all packages (or features) with the ``name \verb+n+ AND name \verb+m+ with version greater than \verb+2+''.
\end{itemize}

An example of a package description stanza is given in figure \ref{formal.cudfpdstanza}.
\begin{figure}[htp] 
\begin{center}
\begin{alltt}
package: textEditor
version: 1
installed: true
depends: spellCheckerService
\end{alltt}
  \caption{Example of Package Description Stanza}
  \label{formal.cudfpdstanza}
\end{center}
\end{figure}

\subsubsection{Preamble}
\label{cudf.preambledes}
The preamble stanza starts with the key \verb+preamble:+, no value is necessary for this key.
The main function of the preamble is to provide the description of additional properties and their types, that can be used by package descriptions.
This is the mechanism which allows the extension of a CUDF document, as described in design principles of CUDF presented in section \ref{formal.cudfDesign}.

Extension properties are described in the value to key \verb+property+.
This value is a list of properties that describe a name of the property, the type of the property and optionally the properties default value.
Each property is separated by the delimiter ``,'', the name is separated from the version by ``:``, and the default value is wrapped in ``['' and ``]'' and separated from the version by ``=``.

For example, \verb+property: size: int, bugs: int = [0]+ defines the integer property of \verb+size+ and the integer property of \verb+bugs+ with the default value \verb+0+.
An example where these extended properties are used in a package description stanza is shown in figure \ref{formal.cudfextensionexample}.

\begin{figure}[htp] 
\begin{center}
\begin{alltt}
preamble:
property: size: int, bugs: int = [0]

package: textEditor
version: 1
bugs: 10
size: 2
depends: spellCheckerService

\end{alltt}
  \caption{Example of preamble stanza with extendable CUDF syntax}
  \label{formal.cudfextensionexample}
\end{center}
\end{figure}

\subsubsection{Request}
\label{formal.cudfdes.request}
The request stanza starts with the \verb+request:+ key, no value is required for this key.
This stanza contains three properties that define the user request to change the system.
Each value is a list of \textbf{package formulae} separated by the delimiter ``,''.
The keys and values are:
\begin{itemize}
  \item \verb+install+ key, whose value is mapped to a set of installation requests, as described in section \ref{formal.constraints}.
  For example, \verb+install: n, m >= 2+ means install component \verb+n+ and component \verb+m+ of version two or greater.
  \item \verb+remove+ key, whose value is mapped to a set of remove requests, as described in section \ref{formal.constraints}.
  For example, \verb+remove: n , m = 2+ means remove all components with name \verb+n+ and component \verb+m+ of version two.
  \item \verb+upgrade+ key, whose value is mapped to a set of upgrade and remove requests, as described in section \ref{formal.constraints}.
  For example, \verb+upgrade: n+ means to remove all packages of name \verb+n+ and install one package of equal or greater versions to that of the maximum version of \verb+m+ currently installed. 
\end{itemize}

\begin{figure}[htp] 
\begin{center}
\begin{alltt}
request:
install: n
remove: m
upgrade: o
\end{alltt}
  \caption{Example of CUDF request stanza}
  \label{formal.cudfrequeststanza}
\end{center}
\end{figure}

In figure \ref{formal.cudfrequeststanza}, an example of the request stanza is given.
In this example, a component of name \verb+n+ is requested to be installed, all components of name \verb+m+ are requested to be removed,
components of name \verb+o+ are requested to be upgraded.

%%%Upgrading with multiple packages
The CUDF request to upgrade a component is the most complex request.
This complexity is because CUDF defines two requirements on the upgrade request,
\begin{enumerate}
  \item only one component with the selected name can be installed.
  \item the installed component's version must be greater than, or equal to, the currently installed greatest version of a component with that name.
\end{enumerate}
For example, if a system has components $a_1 = \langle n,1 \rangle$ and $a_2 = \langle n,2 \rangle$ installed and it is requested to upgrade components with name $n$.
Component $a_1$ must be removed, and either $a_2$ can remain, or $a_2$ can be removed and a higher version of a component with name $n$ can be installed.

\subsection{CUDF Specification}
In this section, the model presented in section \ref{formal.step} is mapped to this CUDF specification.
The package stanzas are used to define to the set of components, $\mathbb{C}_t$, the component system, $\alpha_{t-1}$, and the component relationship constraints $\omega_t$. 
The request stanza is used to define the user request $\delta_t$. 

\subsubsection{CUDF BNF Grammar}
A simplified version of the CUDF EBNF grammar\footnote{http://www.mancoosi.org/cudf/ebnf/ visited 26/3/2012} is given in figure \ref{formal.cudfBNFgrammar}. 

\begin{figure}[htp] 
\begin{center}
\begin{alltt}
(* Top Level Elements *)
<cudf> ::= <preamble> <packagedescription>* <request>
<preamble> ::= "preamble:" "\textbackslash{}n" <stanza>
<packagedescription> ::= "package:" <name> "\textbackslash{}n" "version:" <nat> "\textbackslash{}n" <stanza>
<request> ::= "request:" "\textbackslash{}n" <stanza>
(* Structure *)
<stanza> ::= [<property> "\textbackslash{}n"]* "\textbackslash{}n"
<property> ::= <key> ":" <value>
<key> ::= <ident>
<value> ::= <bool> | <int> | <nat> | <string> \\| <name> | <ident> | <vpkgformula> | <vpkglist> | <veqpkglist> | <typedecls>
<vpkgformula> ::= <orformula> ("," <orformula>)*
<orformula> ::= <vpkg> ("|" <vpkg>)*
<vpkglist> ::= <vpkg> ("," <vpkg>)*
<vpkg> ::= <name> (<relop> <version>)?
<relop> ::= "=" | "!=" | ">=" | ">" | "<=" | "<"

<veqpkglist> ::= <veqpkg> ("," <veqpkg>)*
<veqpkg> ::= <name> ("=" <version>)?

<typedecls> ::= <typedecl> ("," <typedecl>)*
<typedecl> ::= ident ":" type ("=" "["<nat>"]")?
<type> ::= "int"

(* Bottom Level Types *)
<name> ::= ["A"-"Z" | "a"-"z" | "0"-"9" | "-" | "+" | "." | "/" | "@" | "(" ")" | "\%"]+
<ident> ::= ["a"-"z"][""a"-"z" | "0"-"9"]+		
<nat> ::= ["0"-"9"]+
<bool> ::= "true" | "false"
<int> ::= ("+"|"-")? ["0"-"9"]+
<string> ::= [^"\textbackslash{}n"| ^"\textbackslash{}n"]* (*Unicode string with no CR or LF*)
\end{alltt}
  \caption{CUDF BNF Grammar}
  \label{formal.cudfBNFgrammar}
\end{center}
\end{figure}

\subsubsection{Additional Constraints}
In figure \ref{formal.cudfBNFgrammar}, a CUDF document is described as a preamble, a list of package descriptions, and a request.
The preamble is a stanza started with the text \verb+preamble:+.
A package description is a stanza started with a package name, and a package version.
The request is a stanza started with the text \verb+request:+.

This grammar does not list all the constraints for each stanza, and each property.
For example, the property with key \verb+installed+ can only be in a package description, and can only have a \verb+<bool>+ value.
Each stanza type (preamble, package description or request) can consist of different properties, where each properties value can be of a different type.
In tables \ref{formal.cudfpremableprops}, \ref{formal.cudfpdprops} and \ref{formal.cudfrequestprops}, 
the allowed properties for the preamble, a package description, and the request are described respectively.

\begin{table}
\begin{tabular}{|c|c|c|}
Property Name & Value Type & Default Value \\ \hline
property & \verb+<typedecl>+ & \verb+""+
\end{tabular}
\caption{Preamble properties}
\label{formal.cudfpremableprops}
\end{table}

\begin{table}
\begin{tabular}{|c|c|c|}
Property Name & Value Type & Default Value \\ \hline
\texttt{depends} & \texttt{<vpkgformula>} & \verb+""+ \\
\texttt{conflicts} & \texttt{<vpkglist>} & \verb+""+ \\ 
\texttt{provides} & \texttt{<veqpkglist>} & \verb+""+ \\ 
\texttt{installed} & \texttt{<bool>} & \verb+false+ \\ 
\texttt{keep} & \texttt{<ident>} either \texttt{"version"}, \texttt{"package"}, or \texttt{"none"} & \texttt{"none"} \\ 
\end{tabular}
\caption{Package Description properties}
\label{formal.cudfpdprops}
\end{table}

\begin{table}
\begin{tabular}{|c|c|c|}
Property Name & Value Type & Default Value \\ \hline
\texttt{install} & \verb+<vpkglist>+ & \verb+""+ \\ 
\texttt{remove} & \verb+<vpkglist>+ & \verb+""+ \\ 
\texttt{upgrade} & \verb+<vpkglist>+ & \verb+""+ \\ 
\end{tabular}
\caption{Request properties}
\label{formal.cudfrequestprops}
\end{table}

In addition to the properties allowed in the package description, as presented in table \ref{formal.cudfpdprops}, extra properties can be defined in the preamble's \texttt{property} property.
This is described in section \ref{cudf.preambledes}, and restricted to only defining new \texttt{<int>} typed properties.

\subsubsection{Mapping}

\begin{defs}
A \textbf{CUDF document} is a preamble stanza ($preamble$), a set of package description stanzas ($PD$) , and a request stanza ($request$), $\langle premable, PD, request \rangle$.
\end{defs}

Each stanza can be seen as a function:
\begin{defs}
A stanza $s$ is a function that takes a key \texttt{key}, and returns a value \texttt{value}, $s($\texttt{key}$) = $\texttt{value}. 
\end{defs}

This function is abbreviated to use the infix notation \texttt{.}:
\begin{defs}
Given a stanza $s$, a key \texttt{key}, and value \texttt{value}, $s$.\texttt{key}$ = $\texttt{value} iff $s($\texttt{key}$) = $\texttt{value}.
\end{defs}
For a package description stanza $pd$, $pd$.\texttt{name} returns the \texttt{<name>} value,
and $pd$.\texttt{version} returns the \texttt{<nat>} value.

In the following sections, this CUDF document is mapped to the set of components $\mathbb{C}_t$, the component system $\alpha_{t-1}$,
the component relationship constraints $\omega_t$, and the user request constraints $\delta_t$.

\subsubsection{Components}
The set of components, $\mathbb{C}_t$, and component system $\alpha_{t-1}$ are defined given a CUDF document.

\begin{defs}
The function $pd2c$ is defined to take a package description stanza $pd$, and return a component, $pd2c(pd) = \langle pd.$\texttt{name}, $pd.$\texttt{version} $\rangle$.
\end{defs}

The infix notation \texttt{.} can also be used to abbreviate component properties: 
\begin{defs}
Given a package description stanza $pd$,  the component $c = pd2c(pd)$, a key \texttt{key}, and value \texttt{value}, 
$c$.\texttt{key}$ = $\texttt{value} iff $pd$.\texttt{key} $ = $ \texttt{value}.
\end{defs}

\begin{defs}
Given a CUDF document $\langle premable, PD, request \rangle$, the set of components $\mathbb{C}_t$ equals the set of package descriptions mapped using the function $pd2c$,
$\mathbb{C}_t = \{pd2c(pd) \mid pd \in PD\}$
\end{defs}

\begin{defs}
Given a CUDF document $\langle premable, PD, request \rangle$, the component system $\alpha_{t-1}$ equals the set of package descriptions, mapped using the function $pd2c$,
whose property \texttt{installed} equals \texttt{true},
$\alpha_{t-1} = \{pd2c(pd) \mid pd \in PD $ and $ pd.$\texttt{installed} $=$ \texttt{true} $\}$
\end{defs}

\subsubsection{Features}
%%%Features or services
CUDF specifies an additional aspect to component relationships, that of a feature (this can also be described as a service, or a virtual package).
Each component can provide a set of features, where each feature is represented by a name, and a set of versions.
Unlike a component, which has exactly one version, a component can provide multiple versions of a feature.

\begin{defs}
A \textbf{feature} $f$ is a pair consisting of a name $n \in \mathcal{N}$ and a set of versions $V \subseteq \mathcal{V}$ , 
$f = \langle n,V \rangle$
\end{defs}

The features provided by a component are defined as the property with the key \verb+provides+, which is of the type \texttt{<veqpkglist>}.
This type is a list of \texttt{<veqpkg>}, either of the form ``\verb+<name>+'' or  ``\verb+<name>+ = \verb+<version>+''.
\begin{itemize}
  \item \verb+<name>+ $:=$ $($\verb+<name>+$,\mathbb{V})$
  \item \verb+<name>+ = \verb+<version>+ $:=$ $($\verb+<fname>+$,\{$\verb+<version>+$\})$
\end{itemize}
That is, a \texttt{<veqpkg>} which does not define a version, is defined as a feature that provides all versions.
A  \texttt{<veqpkg>} the defines a version, is defined as a feature that provides a singleton set of that version.

\begin{defs}
The function $providedFeatures$ is defined to take a component $c$, and return the set of features that component provides,
$providedFeatures(c) =$ the set of features mapped from the $c$.\texttt{provides} value.
\end{defs}

\subsubsection{Package formula}
A package formula, of type \texttt{<vpkg>}, is a query to retrieve a set of components from a CUDF document.
This formula is the mechanism that defines all relationships and requests in the CUDF specification.

Each \texttt{<vpkg>} is of the form ``\texttt{<name>}'' or  ``\texttt{<name> <relop> <version>}''.
\begin{defs}
A \textbf{package formula} $pf$ is a triple, name $n$, version $v$, and relation $r$, $pf = \langle n, v , r \rangle$.
\end{defs}

The syntax of \verb+<relop>+ is parsed to a mathematical relation with the function $relop$:  
$relop = \{$ \verb+"="+ $\rightarrow$ $=$, \verb+"!="+ $\rightarrow \not =$, 
\verb+">="+ $\rightarrow$ $\geq$, \verb+">"+ $\rightarrow$ $>$, \verb+"<="+ $\rightarrow$ $\leq$, \verb+"<"+ $\rightarrow$ $<$$\}$.

\begin{itemize}
  \item \texttt{<name>} $:=$ $\langle $\texttt{<name>}$, 0 , > \rangle$
  \item \texttt{<name> <relop> <version>} $:=$ $\langle $\texttt{<name>}$,$ \texttt{<version>}$, relop($\texttt{<relop>}$) \rangle$
\end{itemize}
That is, a \texttt{<vpkg>} that does not define a relation or version, is defined as a package formula that is greater than zero.

%%%Find all packages which satisfy the package formula
A function to find packages that satisfy the package formula is defined:
\begin{defs}
The function $packages$ is defined to take a package formula $\langle n,v,op\rangle$ and return the set of components that satisfy the formula,
$packages(\langle n,v,op\rangle) = \{\langle n,v_c \rangle \mid \langle n,v_c \rangle \in \mathbb{C}_t \mbox{ and } v_c \mbox{ op } v\}$
\end{defs}

%%%Find all packages who provides a feature which satisfies the package formula
A package formula may not distinguish between components and features, so a package formula is also used to search for components providing a feature.
A function is then defined to find packages that provide a feature that satisfies a package formula:
\begin{defs}
The function $features$ is defined to take a package formula $\langle n,v,op\rangle$ and return the set of components that provide a feature that satisfy the formula,
$features(\langle n,v,op\rangle) = \{c \mid c \in \mathbb{C}_t \mbox{ and } (n,V) \in providedFeatures(c) \mbox{ and } \exists v_f \in V \mbox { where } v_f \mbox{ op } v \}$.
\end{defs}

Give the functions $packages$ and $features$ the set of all components that can satisfy a formula:
\begin{defs}
The function $packagesThatSatisfy$ returns the set of all components that can satisfy the package formula $pf$, $packagesThatSatisfy(pf) = packages(pf) \cup features(pf)$.
\end{defs}

\paragraph{Sets of Package Formula}
The elements \texttt{<orformula>} and \texttt{<vpkglist>} are both lists of \texttt{<vpkg>}'s.
The element \texttt{<vpkgformula>} is a list of \texttt{<orformula>}'s, so is a list of lists of \texttt{<vpkg>}'s.

The mapping of these elements is trivial:
\begin{itemize}
  \item \texttt{<orformula>} $ := $ a set of package formula.
  \item \texttt{<vpkglist>} $ := $ a set of package formula.
  \item \texttt{<vpkgformula>} $ := $ a set of sets of package formula.
\end{itemize}

The satisfaction of a 
\begin{defs}
The function $allPackagesThatSatisfy$ takes a set of package formula $pkgflist$, and returns all packages that satify a package formula in the list,
$allPackagesThatSatisfy(pkgflist) = \bigcup \limits_{pkgf \in pkgflist} packagesThatSatisfy(pkgf)$ 
\end{defs}

\subsubsection{Relationships}
Given a CUDF document, there are three sets of constraints that make up $\omega_t$, each containing a different relationship constraint type:
\begin{itemize}
  \item keep relationship constraints $\omega_t^{keep}$ are extracted from the \verb+keep+ key of package descriptions in $\alpha_{t-1}$.
  \item dependency relationship constraints $\omega_t^{dep}$ are extracted from the \verb+depends+ key of package descriptions in $\mathbb{C}_t$.
  \item conflict relationship constraints $\omega_t^{con}$ are extracted from the \verb+conflicts+ key of package descriptions in $\mathbb{C}_t$.
\end{itemize}
The set of relationship constraints $\omega_t$, as described in section \ref{formal.step}, is the union of these,
$\omega_t =  \omega_t^{keep} \cup \omega_t^{dep} \cup \omega_t^{con}$.


\paragraph{Keep Relationship}
Given a CUDF document, the set of keep relationship constraints is $\omega_t^{keep}$.
These constraints are extracted from the property with the key \texttt{keep} in the components in $\alpha_{t-1}$.
 
The values of the property with key \texttt{keep} can be either \texttt{none}, \texttt{version}, or \texttt{package}.
If the value is \texttt{none}, then no constraints are generated.
\begin{defs}
The function $keep$ takes a component $c = \langle n ,v \rangle$, and returns a set of keep relationship constraints, such that
\begin{itemize}
	\item if $c$.\verb+keep+ equals \verb+none+: $keep(c) = \emptyset$
	\item if $c$.\verb+keep+ equals \verb+version+: $keep(c) = \{c\}$
	\item if $c$.\verb+keep+ equals \verb+package+: $keep(c) = \{\bigvee packages(\langle n, >, 0 \rangle)\}$
\end{itemize}
\end{defs}
The function $keep$ is defined to take a component $c$ and to return a set of keep relationship constraints where
if the value of $c$.\verb+keep+ equals \verb+none+ then the empty set is returned.
If the value of $c$.\verb+keep+ equals \verb+version+, the returned set contains one keep relationship constraint that states that component should be kept;
If the value of $c$.\verb+keep+ equals \verb+package+, 
the returned set contains one keep relationship constraint that states that a component with the same name should be kept. 

\begin{defs}
Given a CUDF document with component system $\alpha_{t-1}$, the set of all keep relationship constraints, $\omega_t^{keep}$, 
equals $\bigcup \limits_{c \in \alpha_{t-1}} keep(c)$.
\end{defs}

\paragraph{Dependency Constraint}
Given a CUDF document, the set of dependency relationship constraints is $\omega_t^{dep}$.
These constraints are extracted from the property \texttt{depends} in the components in the set $\mathbb{C}_t$.
The value of the property with key \texttt{depends} is a \texttt{<vpkgformula>} which is mapped to a set of sets of package formula.

\begin{defs}
Given a component $a$, the function $dependsOn$ takes a set of package formula and returns a dependency relationship constraint,
$dependsOn(a,pkgflist)$ returns $a \rightarrow \bigvee allPackagesThatSatisfy(pkgflist)$.
\end{defs}
That is, $dependsOn(a,pkgflist)$ creates the dependency relationship constraint where $a$ depends on the disjunction of the union of all components that satisfy a package formula in a set. 

\begin{defs}
The function $depends$ takes a component $a$, and returns a set of dependency relationship constraints,
$depends(a)$ returns $\bigcup \limits_{pkgflst \in listpkgflist} dependsOn(a,pkgflst)$, where $listpkgflist$ is mapped from the value $a$.\texttt{depends}.
\end{defs}
That is, $depends$ returns the set of dependency relationship constraints for a component is the union of all constraints created from individual \verb+depends+ properties.

\begin{defs}
Given a CUDF document, and the set of components $\mathbb{C}_t$,
the set of all dependency relationship constraints $\omega_t^{dep}$ equals $\bigcup \limits_{a \in \mathbb{C}_t} depends(a)$.
\end{defs}

\paragraph{Conflict Constraint}
Given a CUDF document, the set of dependency relationship constraints is $\omega_t^{con}$.
These constraints are extracted from the property \texttt{conflicts} in the components in the set $\mathbb{C}_t$.
The value of the property with key \texttt{conflicts} is a \texttt{<vpkglist>} which is mapped to a set of package formula.

\begin{defs}
The function $conflicts$ takes a component $a$, and returns a set of conflict relationship constraints,
$conflicts(a)$ returns $\{a \rightarrow \neg c \mid c \in allPackagesThatSatisfy(pkgflist) \mbox { and } c \not = a]$, where $pkgflist$ is mapped from the value $a$.\texttt{conflicts}.
\end{defs}
That is, the component $a$ conflicts with any package that satisfies a package formula its conflict property,
with the exception that it cannot conflict with itself.
This final caveat of a CUDF conflict is directly taken from the Debian package specification \citep{Barth2005}, 
as it allows a package to declare a conflict with itself and this forces similar packages to be removed if it is installed.  

\begin{defs}
Given a CUDF document, and the set of components $\mathbb{C}_t$,
the set of all conflict relationship constraints $\omega_t^{con}$ equals $\bigcup \limits_{a\in \mathbb{C}_t} conflicts(a)$.
\end{defs} 

\subsubsection{Request}
\label{formal.cudf.request}
Given a CUDF document with the \texttt{request} stanza, there are three sets of constraints that make up $\delta_t$, each containing a different user request type:
\begin{itemize}
  \item installation request constraints $\delta_t^{ins}$ are extracted from the value \texttt{request}.\texttt{install}.
  \item remove request constraints  $\delta_t^{rem}$ are extracted from the value \texttt{request}.\texttt{remove}.
  \item conflict relationship constraints $\delta_t^{upg}$ are extracted from the value \texttt{request}.\texttt{upgrade}.
\end{itemize}
The set of user request constraints $\delta_t$, as described in section \ref{formal.step}, is the union of these,
$\delta_t =  \delta_t^{ins} \cup \delta_t^{rem} \cup \delta_t^{upg}$.

\paragraph{Install}
Given a CUDF document with the \texttt{request} stanza, the set of install requests $\delta_t^{ins}$ is extracted from the \texttt{request}.\texttt{install} value.
This value is of type \texttt{<vpkglist>} which can be mapped to a set of package formula.
\begin{defs}
The function  $install$ take a package formula $pf$ and returns an install request constraint, $install(pf) = \bigvee packagesThatSatisfy(pf)$, 
\end{defs}

\begin{defs}
Given a CUDF document, the set of install request constraints $\delta_t^{ins}$  equals
$\bigcup \limits_{pf \in pkgflist} install(pf)$, 
where $pkgflist$ is the set of package formula mapped from the value \texttt{request}.\texttt{install}.
\end{defs}

\paragraph{Remove}
Given a CUDF document with the \texttt{request} stanza, the set of remove requests $\delta_t^{rem}$ is extracted from the value \texttt{request}.\texttt{remove}.
This property's value is of type \texttt{<vpkglist>} which can be mapped to a set of package formula.
\begin{defs}
Given a CUDF document, the set of remove request constraints $\delta_t^{ins}$ equals $\{ \neg a \mid a \in allPackagesThatSatisfy(pkgflist)\}$, 
where $pkgflist$ is the set of package formula mapped from the value \texttt{request}.\texttt{remove}.
\end{defs}


\paragraph{Upgrade}
Given a CUDF document with the \texttt{request} stanza, the set of upgrade requests $\delta_t^{upg}$ is extracted from the value \texttt{request}.\texttt{upgrade}.
This property's value is of type \texttt{<vpkglist>} which can be mapped to a set of package formula.

For each package formula, $\langle n, v, op \rangle$, in the set mapped from \texttt{request}.\texttt{upgrade}, the upgrade request is made of two types of constraint 
(as described in section \ref{formal.cudfdes.request}):
\begin{enumerate}
  \item only one component with the name $n$ can be in the evolved system, this is constraint type \ref{formal.upgradeconstraint}.
  \item the component with name $n$ should be have a greater than, or equal to, version than the component with name $n$ with the greatest version in $\alpha_{t-1}$.
\end{enumerate}
These constraints, ignore two aspects of the upgrade request, the $v$ and $op$ values, and features.
They are defined in the full CUDF specification \citep{treinen2009common}, though are not used in this thesis, so are not described here.

The first upgrade constraint:
\begin{defs}
The function  $upgrade_1$ takes a component name $n$ and returns an upgrade request constraint, 
$upgrade_1(n) = a_1 + \ldots + a_i = 1$ where $\{a_1,\ldots,a_i\} = packagesThatSatisfy(\langle n,0,>\rangle)$. 
\end{defs}
That is, $upgrade_1$ returns the constraint that states only one version of a component with name $n$ can be in the evolved system.

The utility function $maxversion$ is required:
\begin{defs}
Given a CUDF document with component system $\alpha_{t-1}$, the function $maxversion$ takes a name $n$ and returns the highest version of a component in $\alpha_{t-1}$ with name $n$,
$maxversion(n) = v  \mid \langle n,v \rangle \in \alpha_{t-1}$ and there is no other component $\langle n,v' \rangle \in \alpha_{t-1}$ where $v < v'$.
\end{defs}

The second upgrade constraint:
\begin{defs}
Given a CUDF document, the function $upgrade_2$ takes a package formula and returns an upgrade constraint,
$upgrade_2(n) = a_1 + \ldots + a_i = 1$ where $\{a_1,\ldots,a_i\} = packagesThatSatisfy(\langle n,maxversion(n),\geq\rangle)$. 
\end{defs}
That is, $upgrade_2$ returns the constraint that the version of the component with name $n$ in the evolved system, must be greater than the $maxversion$ can be in the evolved system.

\begin{defs}
Given a CUDF document, the set of upgrade request constraints $\delta_t^{upg}$ equals $\bigcup \limits_{\langle n,v,op \rangle \in pkgflist} \{upgrade_1(n),upgrade_2(n)\}$, 
where $pkgflist$ is the set of package formula mapped from the value \texttt{request}.\texttt{upgrade}.
\end{defs}


\subsection{CUDF Example}
\label{formal.example}
An example of a CUDF document is presented in figure \ref{formal.CUDFEXAMPLE}.
To briefly illuminate the mapping of a CUDF document to a set of constraints, 
this example is mapped to a set of components $\mathbb{C}_t$, a system $\alpha_{t-1}$, 
a set of component relationship constraints $\omega_t$, 
and a set change request constraints $\delta_t$.

\begin{figure}[htp] 
\begin{center}
\begin{alltt}
preamble:
property: size: int = [0]

package: syslib
version: 1
installed: true
conflicts: syslib

package: syslib
version: 2
conflicts: syslib

package: textEditor
version: 1
depends: spellChecker | spellCheckerService, syslib > 1

package spellChecker
version: 1
size: 1

package: tpspeller
version: 1
provides: spellCheckerService
size: 2

request:
install:textEditor

\end{alltt}
  \caption[CUDF Example]{Example of a CUDF request}
  \label{formal.CUDFEXAMPLE}
\end{center}
\end{figure} 


\subsubsection{Preamble}
%%%Describe the preamble
The preamble from the CUDF document presented in figure \ref{formal.CUDFEXAMPLE}, 
defines the addition of one property \verb+size+ of type \verb+int+ whose default value is \verb+0+.
This extension allows the component \verb+tpspeller+ version 1, to define its \verb+size+ as $2$.

\subsubsection{Components}
The set of components in the CUDF document are mapped from the package stanzas,
such that $\mathbb{C}_t = \{\langle syslib,1 \rangle, \langle syslib,2\rangle,  \langle textEditor,1 \rangle,  \langle spellChecker,1 \rangle,  \langle tpspeller,1 \rangle\}$.
These components are defined as
$\langle syslib,1 \rangle = syslib_1$, $\langle syslib,2\rangle = syslib_2 $,  $\langle textEditor,1 \rangle =  textEditor_1 $,  
$\langle spellChecker,1 \rangle =  spellChecker_1 $,  $\langle tpspeller,1 \rangle =  tpspeller_1 $.

The component system $\alpha_{t-1}$ includes all components whose \verb+installed+ property equals \verb+true+.
The default value for \verb+installed+ value \verb+false+, so components in $\alpha_{t-1}$ must explicitly declare this property.
Therefore, $\alpha_{t-1} = \{ syslib_1 \}$.

\subsubsection{Relationships}
%%%Describe the depends constraints (including features and inequalities)
The set of constraints $\omega_t = \omega_t^{keep} \cup \omega_t^{dep} \cup \omega_t^{con}$.
No package has a \texttt{keep} property, therefore $\omega_t^{keep} = \emptyset$.


The set of dependency relationship constraints $\omega_t^{dep}$, is extracted from the only component with a depends relationship, $textEditor_1$.
The value $textEditor_1$.\texttt{depends} is mapped to the set of sets of package formula $\{\{\langle $\verb+spellChecker+$,0,>\rangle,\langle $\verb+spellCheckerService+$,0,>\rangle\},\{\langle $\verb+syslib+$,1,>\rangle\}\}$ .
The function $dependsOn(textEditor_1 , \{\langle $\verb+spellChecker+$,0,>\rangle,\langle $\verb+spellCheckerService+$,0,>\rangle\} )$
returns the set of constraints $\{textEditor_1 \rightarrow spellChecker_1 \vee tpspeller_1\}$.
The function $dependsOn(textEditor_1 , \{\langle $\verb+syslib+$,1,>\rangle\} )$
returns the set of constraints  $\{textEditor_1 \rightarrow syslib_2\}$.
Therefore, $\omega_t^{dep}$ equals $\{textEditor_1 \rightarrow spellChecker_1 \vee tpspeller_1 , textEditor_1 \rightarrow syslib_2\}$.

The set of conflict relationship constraints $\omega_t^{con}$, is extracted from the components $syslib_1$ and $syslib_2$.
The function $conflicts(syslib_1)$ returns the set of constraints $\{syslib_1 \rightarrow \neg syslib_2\}$,
and  $conflicts(syslib_2)$ returns the set of constraints $\{syslib_2 \rightarrow \neg syslib_1\}$.
Therefore, $\omega_t^{con}$ equals $\{syslib_1 \rightarrow \neg syslib_2, syslib_2 \rightarrow \neg syslib_1\}$.

The set of component relationship constraints $\omega_t$ equals
$\{ textEditor_1 \rightarrow spellChecker_1 \vee tpspeller_1,$ 
$textEditor_1 \rightarrow syslib_2,$ 
$syslib_2 \rightarrow \neg syslib_1,$   
$syslib_2 \rightarrow \neg syslib_1\}$.

\subsubsection{Request}
%%%Describe the request constraint
The user's request $\delta_t =  \delta_t^{ins} \cup \delta_t^{rem} \cup \delta_t^{upg}$.
As the only request in this example is to install, both $\delta_t^{rem}$ and $\delta_t^{upg}$ equal the empty set.

The set of install request constraints $ \delta_t^{ins}$ is extracted from the request stanza $request$.
The value $request$.\texttt{install} is maped to the set of package formula $\{\langle $\verb+textEditor+$,0,>\rangle\}$.
the function $install(\{\langle $\verb+textEditor+$,0,>\rangle\})$ returns the set of constraints $\{textEditor_1\}$
Therefore, $\delta_t^{ins}$ equals $\{textEditor_1\}$, and $\delta_t$ equals $\{textEditor_1\}$.

\subsubsection{Possible Solutions}
%%%Describe the possible models that can satisfy all constraints 
The set solutions to the evolution problem $\delta_t \cup \omega_t$ is the intersection of all constraints.

By going through the constraints the solutions can be found.
Firstly, the request constraint ensures that the text editor component is included, the component $textEditor_1$ will be installed.
If $textEditor_1$ is installed then the system library component $syslib_2$ must be installed.
As the system library components conflict, $syslib_1$ must not be installed.
Of the two components that are left, $spellChecker_1$ and $tpspeller_1$, at least one must be installed due to the dependencies of the text editor.

This gives three possible solutions to this problem;
\begin{itemize}
  \item $\alpha_t^1 = \{syslib_2, textEditor_1, spellChecker_1\}$,
  \item $\alpha_t^2 = \{syslib_2, textEditor_1, tpspeller_1\}$,
  \item $\alpha_t^3 = \{syslib_2, textEditor_1, spellChecker_1, tpspeller_1\}$
\end{itemize}

\subsection{Mancoosi Optimisation Format}
\label{formal.mancoosioptimisationformat}
%%%Describe the format by which mancoosi has required optimisation criteria formatted
The CUDF specification does not specify the criteria used to select a solution.
For the purpose of the MISC competition, the Mancoosi organisation gave a specification to represent optimisation criteria.
This representation is called in this thesis the Mancoosi Optimisation Format (MOF).

MOF was designed to be passed to the CUDF solver on the command line, this meant that it must be expressible in a single line of human readable text.
This results in the relatively simple BNF grammar (as opposed to other possible specifications, such as the framework presented in \citep{Treinen2009}). 
This grammar is described in figure \ref{formal.optbnf}.
\begin{figure}[h!]
\begin{center}
\begin{alltt}
<criteria> ::= <criterion> (, <criterion>)*
\end{alltt}
  \caption{Syntax of the optimisation criteria}
  \label{formal.optbnf}
\end{center}
\end{figure}
This defines a list of \verb+criterion+ with the delimiter \verb+,+ in the form $\langle criterion_1, \ldots, criterion_n \rangle$.
Each criterion is a unique string which expresses a criteria, e.g. $criterion_1 = \langle rank_1, \leq_1 \rangle$.
The criteria are then composed lexicographically into a single criterion $\langle rank_L, \leq_L \rangle$, 
where $criterion_1 \oplus \ldots \oplus criterion_n = \langle rank_L, \leq_L \rangle$. 
This can then be used to create the optimality order $\prec_{\alpha}$ as described in definition \ref{formal.defcrittooptimal}.

\subsubsection{Example}
An example of how to use this mapping for a practical problem can be extracted from the above CUDF document example presented in figure \ref{formal.CUDFEXAMPLE}.
In this example, the component system $\alpha_{t-1}$ was  $\{syslib_1\}$, and there were three possible solutions:
\begin{itemize}
  \item $\alpha_t^1 = \{syslib_2, textEditor_1, spellChecker_1\}$,
  \item $\alpha_t^2 = \{syslib_2, textEditor_1, tpspeller_1\}$,
  \item $\alpha_t^3 = \{syslib_2, textEditor_1, spellChecker_1, tpspeller_1\}$
\end{itemize}

The criteria to select a solution could be defined by minimising the change to the solution, then minimising the total size of the components.
For this, first two criteria are defined as $crit_{change} = \langle rank_{change}, \leq_{change} \rangle$ and $crit_{size} = \langle rank_{size}, \leq_{size} \rangle$.

The criterion $crit_{change}$ is represented by the string \verb+-change+ in MOF.
$rank_{change}$ is defined as the cardinality of the symmetric difference between systems, i.e. $rank_{change}(\alpha,\beta) = |\alpha \Delta_t \beta|$.
The order $\leq_{change}$ is defined as $>$ over natural numbers, as less change is better. 

The criterion $crit_{size}$ is represented by the string \verb+-size+ in MOF.
$rank_{size}$ is defined as the sum of the property \verb+size+ of all components in the  proposed system, i.e. $rank_{size}(\alpha,\beta) = \sum_{c \in \beta} c$.\verb+size+.
The order $\leq_{size}$ is defined as $>$ over natural numbers, as a smaller system is better. 

For the MOF string \verb+-change,-size+, the resulting criteria would be $crit_{change} \oplus crit_{size} = \langle rank_L, \leq_L \rangle$, as shown in definition \ref{formal.defcritlex}.
This rank function applied to the possible solutions return in:
\begin{itemize}
  \item $rank_L(\alpha_{t-1},\alpha_t^1 ) = (4, 1)$
  \item $rank(\alpha_{t-1},\alpha_t^2 ) = (4, 2)$
  \item $rank(\alpha_{t-1},\alpha_t^3 ) = (5, 3)$
\end{itemize}
The order of these ranks over $\leq_L$ is then $rank(\alpha_{t-1},\alpha_t^3) \leq_L rank(\alpha_{t-1},\alpha_t^2) \leq_L rank_L(\alpha_{t-1},\alpha_t^1)$.
Therefore, the order of optimality ($\prec_{\alpha_{t-1}}$) over the possible solutions is $s_3 \prec_{\alpha_{t-1}} s_2$, $s_3 \prec_{\alpha_{t-1}} s_1$, and $s_2 \prec_{\alpha_{t-1}} s_1$,
which makes $s_1$ the optimal solution, as no other solution is greater. 

\section{Summary}
In this chapter the formal model of component system evolution was presented.
This evolution process was formally defined as the iterative application of an evolution step function,
which is defined to return an optimal solution to an evolution problem.
CUDF was used to represent an evolution problem, and MOF used to represent the criteria to select an optimal solution.
With these tools component system evolution can be studied, and automated.

In the following chapters, the implementation and strategies used to evolve a component system will be further discussed.
This will bring the ideas and concepts presented in this chapter to a concrete level, and show the practical challenges and benefits of automated component dependency resolution. 