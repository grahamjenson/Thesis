\chapter{Conceptual Model}
\label{simulation}
\epigraph{A model is a physical, mathematical, or logical representation of a system entity, phenomenon, or process. 
A simulation is the implementation of a model over time. 
A simulation brings a model to life and shows how a particular object or phenomenon will behave.}
{\textit{Systems Engineering Fundamentals. Defense Acquisition University Press, 2001}}

In the previous chapter the \modelname model was defined to represent CSE.
A \modelname instance can be used to describe improbable CSE situations, 
e.g. a user requesting to install the same component, every second for a century.
As goal of this research is to \textit{realistically} simulate the evolution of component systems, 
a model must be developed that links \modelname to the reality of CSE.
This chapter presents the \textbf{conceptual model} of CSE.
This model was developed using the results of a survey that was conducted on a set of users to determine how they change their component systems.
An instance of this model (called a \textbf{configuration}) contains all the necessary variables to simulate CSE.
These variables are used to create a CUDF* document that realistically describes the evolution of a component system.
These relationships are described in figure \ref{sim.modeldiagram}.

\begin{figure}[htp]
\begin{center}
\digraph[scale=.5]{simmodeldiagram}{
rankdir=BT;
CMS[label=<<TABLE BORDER="0" CELLBORDER="1" CELLSPACING="5"><TR><TD WIDTH="150">CUDF*</TD></TR></TABLE>> shape=none];
subgraph {
	rank=same;
	CMI[label=<<TABLE BORDER="0" CELLBORDER="1" CELLSPACING="5"><TR><TD WIDTH="150">:CUDF*</TD></TR></TABLE>> shape=none];
	ConMI[label=<<TABLE BORDER="0" CELLBORDER="1" CELLSPACING="5"><TR><TD WIDTH="150">:Configuration</TD></TR></TABLE>> shape=none];
}
ConM[label=<<TABLE BORDER="0" CELLBORDER="1" CELLSPACING="5"><TR><TD WIDTH="150">Conceptual Model</TD></TR></TABLE>> shape=none];
CMI -> CMS [ label="instantiates"];
ConMI -> ConM [ label="instantiates"];
ConMI -> CMI [ label="creates"];
}
  \caption{Diagram of the Conceptual models relationships}
  \label{sim.modeldiagram}
\end{center}
\end{figure}

This chapter first describes the user survey that explores how component systems are changed by their users.
The conceptual model is then presented, by describing the different variables and how a configuration is used to create a CUDF* document.
The resources where data was collected from, and the processes to convert it to a format usable by the conceptual model are then described.
Finally, a discussion about the validation of the conceptual model is presented.

\section{User Survey}
\label{strat.usersurvey}
To explore the users' role in CSE and to construct a conceptual model, a survey was given to users.
This survey targeted users of GNU/Linux distributions (specifically Ubuntu), and server administrators through the online forum reddit\footnote{http://reddit.com accessed 6/3/2012}.
It was completed by 59 users, who answered questions about themselves, their systems, also how and why they change their component systems.
In this context the way in which component systems are changed is through interaction with package manager applications, 
so the questions primarily about this interaction.

In this section a brief description of the survey and an analysis of responses are given.
The results from this survey are used to describe and categorise the motivations and behaviours of users when changing their component systems.
The full set of questions in the survey is presented in appendix \ref{apx.survey}. 

\subsection{Questions}
%%%The goals of the survey:
There are two types of questions in the survey; questions to identify the type of user, and questions to describe their interactions with package managers.
The set of questions used to identify the user are:
\begin{itemize}
  \item How experienced with package managers are you? 
  \item What system are you using?
  \item What package manager are you using?
\end{itemize}
These can be used to categorise the type of user and put into context the answers that they give.
They can also be used to weigh their answers for credibility and potentially exclude results from novice or inexperienced users. 

The set of questions asked about their use of package mangers are:
\begin{itemize}
  \item After you install a new system, what are your first interactions with the package manager?
  \item Describe your day to day interactions with the package manager?
  \item At what frequency are your typical interactions with the package manager?
  \item Describe an unusual scenario in which the package manager was used?
\end{itemize}
The main focus of these questions is to identify the life-cycle of interactions that the user has with the package manager.
The responses will provide reasons for these actions to occur, and illuminates the users motivations to change the system.

The survey finished with the question:
\begin{itemize}
  \item What other questions should have been asked?
\end{itemize}
This question tried to illicit comments and possible information that could have been gathered.
It also provided a validation that the survey was complete, i.e. it could be used to see if any other questions should have been asked.

\subsection{Results}
%%%The results are summarised as:
The type of user to complete the survey will put in context the remaining results.
Most users (29/59) used Debian based operating systems, e.g. Ubuntu.
The majority of these users used apt-get as their package manager.
13/59  users used ArchLinux\footnote{http://www.archlinux.org/ accessed 6/3/2012},
and all these used pacman\footnote{http://www.archlinux.org/pacman/ accessed 6/3/2012} as their package manager.
Other systems and package managers represented in this survey include Fedora with the yum package manger,
Slackware with the pkgtools package manager, and Gentoo with the portage package manager.
The submitted users' mean experience was 3.9/5.
This is a subjective measure, but it shows that he users answered these questions with a high confidence. 

The life-cycle questions have been summarised into the frequency of each action in table \ref{strat.tblaction}.
\begin{table}[htp]
\begin{tabular}{l | c | c | c | c |}
Request & First & Daily & Weekly & Monthly \\
Upgrade  & 45 & 27 & 16 & 0 \\
Install & 49 & 6 & 17 & 3 \\
Remove & 6 & 4 & 1 & 0\\
\end{tabular}
\caption{Summary of the frequency of user actions with package managers}
\label{strat.tblaction}
\end{table}

This table is a summary of the amount of users who perform the actions of upgrading their system, installing or removing a package 
when the system is first created, daily, weekly or monthly.
The vast majority of users when they create a system upgrade the system and install required packages.
This also shows that most users upgrade their system daily, and many install packages weekly.
An important result shows that users do not often remove packages, and if they do it is likely only when they install a new system.

The unusual scenarios which the users describe using the package manager included
3 of the users describing the process of fixing a broken system through using the package manager. 
The most common task answered was 11 of the 59 users stating that they had installed packages to accomplish a specific task, only to remove them soon after.
This situation is summarised by a user: 
\begin{quote}
``I sometimes install lots of packages very quickly as I need to accomplish a task, then remove them once that task has finished.''
\end{quote}

In the final question asked if there is any more questions the general themes of responses include:
\begin{itemize}
  \item the mitigation of failed actions
  \item installing multiple versions of packages (not allowed in Debian based systems)
  \item using a graphical user interface v.s. console based package manager
\end{itemize} 
The majority (37/59) users did not fill out this option in the survey, a potential indicator that the survey was complete.
One user even remarked to this question:
\begin{quote}
``Quite an all encompassing survey!''
\end{quote}

\subsection{Progressive vs. Conservative Users}
The main outcome of this survey was the identification that a users behaviour when changing their system is in motivation to one of two types of risk:
\begin{itemize}
  \item the potential risk of changing the system and introducing new problems.
  \item the potential risk of becoming out-of-date and having old problems persist.
\end{itemize}
The behaviours of these users can be described with two user stereotypes, \textbf{conservative} and \textbf{progressive}.
These terms come from the domain of politics where conservatism is the philosophy that emphasises minimal and gradual change in society,
where progressivism promotes change and reform.

Most users in the survey are partially motivated by both risks, e.g. a users response that express a slight conservative attitude:
\begin{quotation}
In production I rarely remove packages (easier to leave software as-is than risk breaking stuff).
\end{quotation}
That is they are more likely not to change the system, even though it may be beneficial as it may lead to a fault in their system. 

Another example of a users response expressing a slight progressive attitude:
\begin{quotation}
I update my packages whenever I log in each day
\end{quotation}
Upgrading the system each day will ensure that packages do not become out-of-date, though this may require significant change.

Both of these stereotypes have extremes though, where users try to eliminate all of a risk.
For example, a user responded in the survey with an extreme progressive attitude:
\begin{quotation}
I do run an unstable system all the time, I help mitigate this with some redundancy in my most frequently used components, 
using packages which perform the same function, but have different dependencies, since it's less likely to have multiple packages break at the same time. 
If something is rather buggy for me, I tend to update on a more frequent basis to check for the next stable point to jump into.
\end{quotation}
This user has new components in their system that are not fully tested, which are described as unstable packages.
To lower the risk that such packages have on the function of the system, this user has redundant functionality installed in their system to ensure that problems will not be too severe.
This users system will never be out-of-date, but will be changed frequently.

An example of user's extremely conservative response when asked about the frequency with which they interact with the package manager:
\begin{quotation}
As little as possible. I like build my box into whatever I'll need in the first couple of weeks after an install. 
Following the configuration and construction, only the occasional upgrade is necessary. 
Unless, of course, I receive a security notice about something.
\end{quotation}
So after the setting up of a system, this user will not change their system, unless there is a direct security risk.
This lack of change will result in this user's system quickly becoming out of date, though it will almost never be changed.

The progressive behaviours of users will minimise the out-of-dateness of the system, but increase the necessary change.
Where the conservative behaviours will let the system go out-of-date, to reduce the change to the system.
The behaviour of a user will be with respect to the goals of their system.
For example, a server administrator that is running a mission critical system will likely change the system begrudgingly as any fault could cause damage.
However, a user running a desktop personal computer system may be more interested in new functionality, so would change more readily.

\section{Conceptual Model}
In this section the conceptual model of CSE is presented.
The conceptual model consists of a set of variables that describe the user's behaviour, 
and a CUDF* document used as a template to create realistic evolution scenarios.
This section describes the variables of the conceptual model, as extracted from the user survey.
Additionally, it describes how an instance of this model is used to create CUDF* documents.

\subsection{Variables and Template}
In the previous chapter CUDF* allowed the user to request different changes, such as 
installing a component, removing a component, and upgrading all installed components.
The results of user survey have shown that the request to remove a component is not often used, and is therefore not to be included in the conceptual model.

In the survey the typical time scale employed by the users to describe the changes they made to their systems was daily.
Therefore, the variables used to describe user actions will be ``per day''. 

The variables that make up the conceptual user are: 
\begin{itemize}
  \item $u$ is the probability a user requests to update the system per day.
  \item $i$ is the probability a user requests to install per day.
  \item $IP$ is a set of component names with the probability that a component will be requested to be installed, i.e. $IP \subseteq \mathcal{N} \times \mathbb{R}$.
  \item $U$ is the MOF criteria used to select an optimal system for an update request.
  \item $I$ is the MOF criteria used to select an optimal system for an install request.
  \item $d$ is the number of days the simulation runs for.
\end{itemize}

The remaining element required to create CUDF* documents, is the initial system $\alpha_{t_0}$ for evolution, 
and the sets of components that exist at the times between $t_0$ and $t_0$ plus $d$ days.
Both these can be described in a single CUDF* document.
This document is complete, except for that it contains no user requests.

\begin{figure}[h]
\begin{center}
\begin{alltt}
for day in 1 to \(d\):
   if randomprob() \(< u\):
       template.addline("request: " + (day + \(t\sb{0}\) + ", " + \(U\))
       template.addline("update: *")  system request to CUDF* template at time day \(+ t_0\)
   if randomprob() \(< i\)   

\end{alltt}
  \caption{Create CUDF* document to describe the evolution of a component system}
  \label{sim.CUDF*}
\end{center}
\end{figure}


\subsection{CUDF* Document Creation}
Given an instance of the conceptual model, CUDF* documents can be created that describe the evolution of a component system.
These documents 


\subsection{Conceptual Model Discussion}
This section presents a brief discussion about the conceptual user compared to the users from the survey.

The conceptual user does not model the initial requests made when the system is new, 
or the discussed pattern of installing then removing packages.
The reason for not including these elements in the model is to maintain the simplicity of this model.
Including these actions into the user model would dramatically increase the complexity of the model, 
which might overshadow the core element being modeled. 

One request made by the user in reality may impact the occurrence of another action, so that they are correlated to happen together.
For example, a user may select to always update before they install, or to select a component to be installed because of another installed component.
The complexity that can be introduced by these correlations could make this simulation impractical.
For the practicality of the simulation, and the simplicity of the presented models, the corrolation between requests is ignored.

\subsection{Conceptual Components Model}
The only item that is necessary in the conceptual component model is 
a partial CUDF* document that includes the preamble, and package stanzas that can be parsed to create the time $t_0$, the initial system .
This document is complete with the exception of the user requests that will be generated using the conceptual user model.


\subsection{Example}
To illustrate the use of the conceptual model, consider the example where:
\begin{itemize}
  \item $u = 0.2$
  \item $i = 0.2$
  \item $IP = \{$(\texttt{n}$, 0.25),($\texttt{m}$,0.75)\}$
  \item $U = $ \texttt{-removed,-new}
  \item $I = $ \texttt{-removed,-changed}
  \item $d = 20$
\end{itemize}
The variables $u$ and $i$ equal $.2$, this means that on any day the user has a 20\% probability of requesting to upgrade and/or install a component.
If a user requests to install a component, the component name $n$ has a 25\% probability of being selected, and the component name $m$ is 75\% likely. 
When the system is selected to be upgraded, the most criteria used is $U$, whose most important criterion is to minimise the amount of removed components.
The install criteria $I$ is similar to the update criteria, except that is minimises all change to the system.
Finally $d$ describes how many days this user will potentially request for, which is $20$.

Using this model it can be expected that there will be $4$ requests to upgrade the system and $4$ requests to install a component.
Component names  are selected to be installed without replacement, i.e. the same component name cannot be selected twice to be installed.
Therefore, only $2$ requests to install can be made, and it is expected that name $m$ will be selected first.

\section{Conceptual Model Validation}
%%%Validation of this simulation, what needs to be validated/why it should be validated
The conceptual model presented is a simplified abstraction of the reality in which users evolve component systems.
It describes the variables that effect component system evolution as a configuration,
and the processors used to execute the simulation given a configuration.

%%%What if it is wrong
If some significant aspect of the system was missed, or if some aspect was incorrectly defined, the simulation may produce results that are incomprehensible,
or worse, misunderstood.
Therefore, the validation of these artifacts is essential to move forward. 
This validation was accomplished though regular stakeholder meetings, and an online survey with subject matter experts (as described in chapter \ref{strategies}).

\subsection{Stakeholder Meetings}
%%%Weekly meetings with stakeholders (i.e. supervisors)
As described in the methodology; one effort to validate these artifacts is done through meetings and a structured walk-through with the core stakeholders.
In this simulation the core stakeholders are the project researcher and supervisors.
These are the people who are asking the questions and are also impacted by the outcome, therefore they are directly effected by the validity of the results.
Meetings where held at regular intervals to ensure the projects progress and direction where correct.

\subsection{Subject Matter Expert Survey}
%%%Results from what else should be asked, install stuff not from repository, installs break
The survey described in chapter \ref{strategies}, 
was conducted at a point in the project when the conceptual model was just being developed, so had considerable impact on these artifacts.
The questions asked in this survey helped gauge the necessity and frequency of user actions,
so that only the most important aspects of the problem can be selected to be simulated.
It also filled in gaps of what was missing from the survey and model, giving direction for exploration.

\subsubsection{Frequency of User Actions}
%%%How often do users do these actions
The more frequently a user selects an action to evolve their system, the more important it is to the evolution of their system.
The information gained from the survey provides confidence that not including the action to remove a component and abstract the requirement multiple repositories, 
would not damage the validity of the results.
It also helped us define and represent the update and install actions in the configuration.

The remove action can be ignored as it seemed many of the users do not use this frequently.
When they do select to remove a component it is usually directly after installing it, if the selection to install a component was seen as a mistake.
Although it is clearly an important function to be included when evolving a system, the assumption is made that it is unnecessary for this simulation.

This survey also clearly shows that the main actions of a user is to update their system,
with the installation of a component the second most used action.
This survey also showed that the update occurs at more regular intervals than the install components.
Therefore, only the update and install user actions were included in this simulation and it also defined their representation. 


\subsection{Further Validation}
The assignment of the configuration variables is a different stage in the validation of this simulation.
Clearly if you create a configuration that is completely unrealistic, the saying ``garbage in, garbage out'' applies to the results.
However, this is not a concern when validating the conceptual model, or the abstract processes.
Further discussion of the validation of the assignment of the configuration variables is in chapter \ref{ubunutsimulation}.


\section{Configuration Data Collection and Conversion}
In order to assign variables to a conceptual model configuration, data from the Ubuntu domain must be collected and converted.
The 
These variables are broken into two groups; the context variables, which do not change over simulation executions; 
and variables which are changed to answer specific questions.
The implementation of the simulation processes are then described, with the necessary practical alterations made. 

\subsection{Context Variables in the Configuration}
%%%Context variables are common attributes
Some variables form the context of the simulation, these are static points that stay at a default assignment across simulation runs.
They are static because they are assumed to be universal for Ubuntu users, like the repository function and the probability a package will be installed by a user;
or they are assumed to be independent of component evolution, like the time frame and the initial system.

%%%Time frame between the two releases 10.2009-10.2010, specifically from 2009,10,31 for 365 days
The time frame was selected to be over the year between the Ubuntu releases of system in 9.10 and 10.10 occurring between October 2009 to 2010.
Specifically the simulation is run from October 21st 2009 for 365 days.
The date was selected as it is recent and just after the major release of an Ubuntu version.
The length of a year was selected as the overwhelming majority of users in our user survey (from section \ref{strat.usersurvey}) responded that their system was a year or less old.
Ubuntu has 6 monthly releases one, in April and one in October, the syntax of the version of each release is first the year,
then the month in which it was released, e.g. 10.04 is the release in April 2010.
Therefore, this time frame occurs over an intimidate release of version 10.04 in April 2010, which allows for experimentation involving the release date.

%%%This time frame implies the initial system which is Ubuntu 10.09
The time frame start was selected to coincide with the release of the Ubuntu version 9.10.
This version was then selected to be used as the initial system, as if the user just installed a new Operating System onto their system.
Specifically the desktop i386 distribution was selected as it is the most popular among the users of Ubuntu.

\subsection{Repository function}
%%%Repository function created through downloading the Ubuntu repository
For any day in the time frame, the repository function must return the components in the repository as a CUDF file.
This involves two distinct steps; collecting the Ubuntu packages with information at a resolution necessary for this simulation;
mapping these packages to the CUDF specification used by this simulation.

\subsubsection{Collecting the Packages}
The information gathering must be accomplished with great care, as the resolution and detail must be precise.
The Ubuntu repository located at http://archive.ubuntu.com/ has accessible data of the necessary detail to be used.
It contains all packages that have ever been in the repository, and the information to the minute of when the package was added.

%%%These are the steps that are taken to create the repository function
To collect these packages and information from the repository, this process was followed:
\begin{enumerate}
  \item the repositories web site was recursively scrapped to create a set of pairs $P$ 
  such that each pair contains a download link to a package and the date that package was uploaded to the repository
  \item Each package in the set $P$ was then downloaded and the file tagged with its upload date
  \item A dpkg package is a compressed set of files, 
  which include the meta-data control file of the package; all packages are extracted and the control file is tagged with the upload date of its package 
\end{enumerate}

This process creates a set of control files $C$ each tagged with the date it was uploaded to the repository.

\subsubsection{dpkg to CUDF mapping}
\label{ubuntusimulation.debtocudf}
The mapping of the Debian dpkg component meta-data to CUDF is mostly a direct process as the meta-data is very similar.
This similarity is due to the Mancoosi organisation goals basing CUDF on FOSS systems like Debian.  
There are a few differences however, these differences require some explaining when converting dpkg format to CUDF.
In this section, firstly these problems will be described and their solutions explained, 
then the process by which the set of control files is taken and the function $Rep(d)$ is created to return a CUDF file for a given date $d$.

%%%Versioning problem
\paragraph{Version Models}
The first complication when mapping dpkg to CUDF is that the versioning models are incompatible.
Debian uses a version mode \verb+[epoch:]upstream_version[-debian_revision]+,
where \verb+epoch+ is an unsigned integer and \verb+upstream_version+ and \verb+debian_revision+ are strings.
A Debian version is greater than another if its \verb+epoch+ is greater; 
if their \verb+epoch+'s are equal then its \verb+upstream_version+ is lexically greater; 
if their \verb+epoch+'s and \verb+upstream_version+'s are equal then its \verb+debian_revision+ is lexically greater.
This lexical comparison (further explained in \citep{Barth2005}) differs greatly and is far more complicated than the CUDF integer based version model.

To map a dpkg version to an integer then cannot be done without knowledge of all component versions refereed to in the repository.
Therefore, the most straight forward solution is to extract all refereed versions (not only package versions but those in package formulae as well),
and then sort them into a list such that their CUDF version is their index in the list.

\paragraph{Virtual Packages}
%%%Virtual Packages must be handeled, there are some specific debian semantics that are particularly important
Debian has a package type called a virtual package, this is an abstracted package, one that can be provided and depended upon but does not exist.
These packages provide an interface to some common functionality that can be provided by multiple packages.
For example any package providing the virtual package \verb+dhcp-client+ must include dhcp client functionality. 
Unlike other component models where this interface is defined in a verifiable manner like code or an ADL,
Debian defines virtual packages in documentation, a list of which is provided on the Debian site\footnote{http://www.debian.org/doc/packaging-manuals/virtual-package-names-list.txt/ accessed 6/3/2012}.

The main aspect that requires consideration when mapping from dpkg to CUDF is that only dependencies where no version is specified can be fulfilled by a virtual package.
For example, a dependency on \verb+foo+ can be satisfied by a package providing a \verb+foo+ virtual package, 
however a dependency on \verb+foo >= 1+ cannot be satisfied by the same virtual package. 
The solution to this difference is to change the name of all virtual packages to include the prefix \verb+virtual--+ and 
alter dependencies that do not include version information to include an addition disjunction of the virtual package.
For example, the line \verb+provides: foo+ is altered to be \verb+provides: virtual--foo+, 
and the dependency \verb+depends: foo+ is altered to \verb+depends: virtual--foo | foo+.

\paragraph{Priority}
In the meta-data of the dpkg format there is a mechanism in which to state how important a package is to the system, this is called the package priority.
This tag can be set to \verb+extra+, \verb+optional+, \verb+standard+, \verb+important+, and \verb+required+, where the last value expresses the necessity to have this package in a Debian system.
The priority of a package is an optimisation problem, where selecting between components can take this into account, 
except for the final value which expressly states that the package must be installed.
Therefore, the mapping from the dpkg priority value to CUDF, is only done when the value is \verb+required+ and it sets the mapped CUDF packages \verb+keep+ value to \verb+package+.

\paragraph{Date}
As CUDF has an extensible syntax, the date the package was uploaded to the repository can be described as a key/value pair in the packages CUDF description.
As described above the control file which describes gives the dpkg description of the package has been tagged with the date of upload.
This date is extracted and converted to seconds since the Unix epoch (midnight, Jan. 1st 1970) and mapped to the integer property \verb+date+ in the pacakges CUDF file.
For example, if a Debian package was uploaded on the date of 13 Feb 2009, at exactly 23:31:30, 
the mapped CUDF component $c$ would have the property \verb+date+ would equal $1234567890$, i.e $c$.\verb+date+ $= 1234567890$.

\paragraph{Architecture}
Another important property in the dpkg format is the architecture of the package.
This describes the necessary CPU/hardware for the package to be functional.
The architecture of a dpkg package is directly mapped to the architecture of the CUDF property \verb+architecture+, through using CUDF's extensible syntax.
For example, is the archicteure expressed in the dpkg control file is \verb+i386+ then the mapped CUDF package $c$ has property $c$.\verb+architecture+ $=$ \verb+i386+.

\paragraph{Mapping}
The function $Rep(d)$ takes a date $d$ and returns a CUDF file that contains all packages that exist in the repository on that date.
After mapping all the individual dpkg control files to individual CUDF files, where one package exists per CUDF file,
all the CUDF files are merged into one large file such, where $\mathbb{C}$ equals all CUDF components.
The process to create the function $Rep$ is described below:
\begin{enumerate}
  \item Given the assumption the system that is evolved in the simulation is of the architecture i386, 
  any component $c$ in $\mathbb{C}$ where $c$.\verb+architecture+ does not equal \verb+i386+ or \verb+all+ is removed.
  \item The function $Rep(d)$ then simply returns the set of components whose upload date is less than $d$, i.e. $C_d = [c \mid c$.\verb+date+ $ \leq d]$
\end{enumerate}

\paragraph{Differences}
%%%The main different is is that the entire repository is used here, where typically only a sub set is used
The one significant difference between a real repository and this simulated repository function,
is that a real Ubuntu user would likely use only a subset of the repository where this function uses all packages. 
Also, the conversion from the dpkg format to CUDF allows multiple package versions installed in the same system where this is expressly forbidden in the Debian semantics. 

Through the use of meta-data files which list subsets of packages inside the Ubuntu repository, a user can select portions of the repository to use.
These meta-data files are used for different life cycle reasons (e.g. separating unstable from stable) and separating core packages from third party software.
Creating a single repository out of all files was necessary as the states of the individual repositories are not stored,
so finding what is included on a given date is impossible.
To map a real user to this simulated user, the real user would select all meta-data files to use the entire repository of packages. 

%%%We allow multiple versions of the same package to be installed, this is different from the debian
Debian for the most part, does not allow multiple versions of the same package to be installed in a system simultaneously.
However, in some instances Debian allows multiple packages to be installed on the system, as long as two such packages are not ``configured'' at the same time.
If a package is not configured, then it's dependencies do not require to be satisfied and therefore differs from the CUDF model.
In this simulation, this specific semantic of Debian is ignore, and multiple versions of a package are allowed to be installed into a system.
Many of the criteria described in chapter \ref{strategies} discourage the inclusion of multiple version,
therefore it is expected to have little impact on the results of the simulation.
As this difference may effect the validity of the simulation however, during the simulation the effects will be measures and noted, and if the effects are significant discussed.


\subsubsection{Probability a component will be selected}
%%%The probability a component will be selected
Different users will be more likely to select different packages to install.
However, as discussed to simulate this probability is impractical, and is likely impossible.
Therefore, one simulated user probability will be created, this assumes that all users have the same likely hood of selecting packages.

To define the probability a user will select a package to install, the problem can be broken into two questions:
\begin{enumerate}
  \item What packages would a user select to install?
  \item How many systems have a package installed?
\end{enumerate}
These questions are answered using the set of packages listed in the package app-install-package with the Ubuntu popularity contest.

%%%What packages may a user select to install? We can determine this by looking at applications that are listed in the app-install-data package
Most packages in the repository a user would not likely directly select to install.
These packages provide libraries, background daemons, interfaces between services; they are usually installed because other packages depend on them.
Finding a set of packages that a typical user may select to install is difficult.

The package app-install-data contains a list of 2399 packages\footnote{as of May 24th 2011} with meta-data like icons and descriptions.
This data is used by other applications, like the Ubuntu Software Center, to provide a mechanism for a user to find a package they may wish to install.
Some of these a are already installed in the initial system, and some are not available in the core repository.
After filtering such packages out, the list has 2087 packages that the user can select to install from. 

%%%PopCon
The probability a package from app-install-data may be selected by the user for installation, must still be weighted.
For this task the data set available from the Ubuntu popularity contest\footnote{http://popcon.ubuntu.com/ accessed 6/3/2012} is used.
The Ubuntu popularity contest is an excellent, accurate and broad data-set of information of the popularity of Ubuntu packages.
Each week this automated survey is submitted by nearly two million users, that contains information on what packages a user has installed and uses.
The packages that are most popular are not the ones users most install, but packages that are most depended upon.

Through weighting the list from the app-install-data package with the number of systems that package is installed on,
the probability a package is selected to be installed can be measured.

%%%The core problem with this list is that not all packages that can be installed are listed, i.e. experienced users may install packages that are not applications, build-essential
Although a user will more likely install packages from the app-install-data list, it is not a complete list of packages that a user may install. 
For example, more experienced users may select to install packages that are libraries or development tools, that are not listed.
The package ``build-essential'' which contains tools to build Debian packages, is not included in the list, though is regularly installed.
This is a problem that was briefly described in chapter \ref{simulation}, where different types of user are likely to install different things.
It is an extremely difficult problem to solve, and any solution will also dramatically increase the complexity of the simulation.



\section{Summary}
{}In this chapter possible options were discussed for studying various strategies employed when evolving component systems.
{}Simulation, through the methodology \citep{Law2005} describes, was selected, and the steps involved were described.
{}The central artifact of this methodology, the conceptual model, was broken down into models of the user, repository and solver, and the processes of simulation.
{}These models were validated through regular meetings with the core stakeholders, and a survey conducted on subject matter experts.
{}In the next chapter the configuration of the simulation is further defined, and the questions about component system evolution are attempted to be answered.
