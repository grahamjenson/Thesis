\chapter{User Model}
\label{simulation}
\epigraph{A model is a physical, mathematical, or logical representation of a system entity, phenomenon, or process. 
A simulation is the implementation of a model over time. 
A simulation brings a model to life and shows how a particular object or phenomenon will behave.}
{\textit{Systems Engineering Fundamentals. Defense Acquisition University Press, 2001}}

In the previous chapter, CUDF* documents were used to describe the evolution of component systems through a user's repeated requests to change.
However, such a document can be used to describe unlikely situations,
e.g. a user requesting to install the same component every second for a century.
Given that a goal of this research is study the evolution of \textit{realistic} systems,
it is necessary to model realistic users. 
For this purpose the \usermodel (\textbf{Sim}ulated \textbf{User}) model was developed.
This model describes how a user would realistically change their component system,
and it can be used to create CUDF* documents.
These relationships are described in figure \ref{sim.modeldiagram}.

\begin{figure}[htp]
\begin{center}
\digraph[scale=.5]{simmodeldiagram}{
rankdir=BT;
CMS[label=<<TABLE BORDER="0" CELLBORDER="1" CELLSPACING="5"><TR><TD WIDTH="150">CUDF*</TD></TR></TABLE>> shape=none];
subgraph {
	rank=same;
	CMI[label=<<TABLE BORDER="0" CELLBORDER="1" CELLSPACING="5"><TR><TD WIDTH="150">:CUDF* Document</TD></TR></TABLE>> shape=none];
	ConMI[label=<<TABLE BORDER="0" CELLBORDER="1" CELLSPACING="5"><TR><TD WIDTH="150">:\usermodelwx</TD></TR></TABLE>> shape=none];
}
ConM[label=<<TABLE BORDER="0" CELLBORDER="1" CELLSPACING="5"><TR><TD WIDTH="150">\usermodelwx</TD></TR></TABLE>> shape=none];
CMI -> CMS [ label="instantiates"];
ConMI -> ConM [ label="instantiates"];
ConMI -> CMI [ label="creates"];
}
  \caption{Diagram of the \usermodel models relationships}
  \label{sim.modeldiagram}
\end{center}
\end{figure}

The \usermodel model was developed in part using the results of a survey conducted to determine how users change their component systems.
This survey is described in section \ref{strat.usersurvey}.

\usermodel contains variables to create a realistic scenario of CSE, e.g. a variable that describes the probability a user will upgrade their system on a given day.
In addition it contains information (e.g. the dates the simulation takes place) and assumptions (e.g. the probability a package will be selected to be installed) about the simulation.
\usermodel is presented in section \ref{sim.usermodel} and teh variables, information, and assumptions for the simulation are discussed.

To use \usermodel, data was collected and converted into usable formats.
The sources this data was collected from and the methods used to convert it are described in section \ref{sim.collection}.

This chapter concludes in section \ref{sim.modelvalidation} with a (or ) discussion over the validity of this \usermodel.
This section describes the differences between the reality of CSE and \usermodel.
These differences are important to explore, as they may reduce the validity of the results from the simulation.

\section{User Survey}
\label{strat.usersurvey}
To explore the user's role in CSE and to construct \usermodel model, a survey was conducted on users of component systems.
This survey targeted users of GNU/Linux distributions (specifically Ubuntu) and server administrators through the online forum reddit\footnote{http://reddit.com accessed 6/3/2012}.
It was completed by 59 users, who answered questions about their background, systems they use, and the ways they change their component systems.
In this context, the way in which component systems are changed is through interaction with package manager applications. 
Therefore, the questions were primarily about this interaction.

In this section, a description of the survey and an analysis of responses are given.
The results from this survey are used to describe and categorise the motivations and behaviours of users when changing their component systems.

\subsection{Questions}
%%%The goals of the survey:
The survey consisted of two groups of questions: questions that identified the type of user and questions that described their interactions with package managers.
The set of questions used to identify the user were:
\begin{itemize}
  \item How experienced with package managers are you (based on scale of 1 to 5 where 1 is no experience and 5 is highly experienced)? 
  \item What system are you using?
  \item What package manager are you using?
\end{itemize}
These can be used to categorise the type of user and weigh their answers for credibility based on their self rated experience.

The set of questions that asked about the use of package mangers were:
\begin{itemize}
  \item After you install a new system, what are your first interactions with the package manager?
  \item Describe your day to day interactions with the package manager?
  \item At what frequency are your typical interactions with the package manager?
\end{itemize}
These questions were focused on identifying the life-cycle of interactions that users have.

\subsection{Results}
%%%The results are summarised as:
As was already mentioned earlier, the survey was completed by 59 respondents.
The majority of these (29) were Debian based operating systems users.
Among these users apt-get was the most popular package manager.
Thirteen respondents used ArchLinux\footnote{http://www.archlinux.org/ accessed 6/3/2012} with pacman\footnote{http://www.archlinux.org/pacman/ accessed 6/3/2012} as the package manager.
Other systems and package managers represented in this survey include Fedora with the yum package manger,
Slackware with the pkgtools package manager, and Gentoo with the portage package manager.

The mean of the respondents self ranked experience was 3.9/5.
While this can be considered a subjective measure, it is expected that the respondents were confident in their answers. 

The life-cycle questions have been summarised into the frequency of each request in table \ref{strat.tblaction}.
\begin{table}[htp]
\centering
\begin{tabular}{l | c | c | c | c |}
Request & Set-up & Daily & Weekly & Monthly \\
Upgrade  & 45 & 27 & 16 & 0 \\
Install & 49 & 6 & 17 & 3 \\
Remove & 6 & 4 & 1 & 0\\
\end{tabular}
\caption{Summary of the frequency of user actions with package managers}
\label{strat.tblaction}
\end{table}

Based on this table, the vast majority of respondents upgrade and install new components when they first set-up their system.
This also shows that most users upgrade their system daily, and many install packages weekly.
Additionally, this shows that users do not often remove packages. 

\subsection{Progressive vs. Conservative Users}
One goal of this survey was to identify user behaviours.
Based on responses, it can be concluded that users attitudes towards changing their systems are affected by the following risks:
\begin{itemize}
  \item the potential risk of changing the system and introducing new problems.
  \item the potential risk of becoming out-of-date and having less functionality and old problems persist.
\end{itemize}
The behaviours of these users can be described with two user stereotypes, \textbf{conservative} and \textbf{progressive}.
These terms come from the domain of politics where conservatism philosophy that emphasises minimal and gradual change in society,
which is is contrasted by progressivism philosophy that promotes change and reform \citep{oed2010}.

Most users in the survey are partially motivated by both risks, e.g. a users response that express a slight conservative attitude:
\begin{quotation}
``In production I rarely remove packages (easier to leave software as-is than risk breaking stuff).''
\end{quotation}
The previous quote shows that this respondent less likely to change their system, even though it may be beneficial. 

Another example of a user's response that expresses a progressive attitude:
\begin{quotation}
``I update my packages whenever I log in each day''
\end{quotation}
The reason this user upgrades their system every day is likely to ensure that packages do not become out-of-date.
This behaviour may increase the functionality of their system and tries to fix packages with bugs, at the cost that it may also require significant change.

Both of these stereotypes have extremes.
One such extreme is when a user tries to eliminate all of the risks associated with being out-of-date.
For example, a user responded in the survey with an extreme progressive attitude:
\begin{quotation}
``I do run an unstable system all the time, I help mitigate this with some redundancy in my most frequently used components, 
using packages which perform the same function, but have different dependencies, since it's less likely to have multiple packages break at the same time. 
If something is rather buggy for me, I tend to update on a more frequent basis to check for the next stable point to jump into.''
\end{quotation}
This user has not fully tested components in their system (described as unstable packages).
To lower the risk that such packages have on the function of the system, this user has redundant functionality installed in their system.
This way the user tries to ensure that potential problems will not be too severe.
The system of this user will never be out-of-date, but will be changed frequently.

An example of user's extremely conservative response on the frequency with which they interact with the package manager:
\begin{quotation}
``As little as possible. I like build my box into whatever I'll need in the first couple of weeks after an install. 
Following the configuration and construction, only the occasional upgrade is necessary. 
Unless, of course, I receive a security notice about something.''
\end{quotation}
After the setting up of a system, this user will not change it unless there is a direct security risk.
This lack of change will result in the system quickly becoming out of date, though lowers the risks associated with change.

The risks associated with change and being out-of-date drive the users behaviours towards changing the system. 

\section{\usermodel model}
\label{sim.usermodel}
The \usermodel model consists of: 
\begin{itemize}
  \item a set of variables that describe the user's behaviour when changing their component system.
  \item a set of assumptions used by the simulation.
\end{itemize}
This section presents the variables and assumptions of \usermodel, and how an instance of this model can be used to create a CUDF* document.

\subsection{Variables and Assumptions}
The variables that make up the \usermodel are: 
\begin{itemize}
  \item $u$ is the probability a user requests to upgrade the system per day.
  \item $i$ is the probability a user requests to install per day.
  \item $U$ is the MOF criteria used to select an optimal system for an upgrade request.
  \item $I$ is the MOF criteria used to select an optimal system for an install request.
\end{itemize}

The variable $u$ is the probability per day that a user will upgrade their system, and the variable $i$ is the probability a user will request to install a component.
The reason for selecting the ``per day'' resolution came from the user survey responses, where the most frequent these requests typically occurred was daily.
The $I$ and $U$ criteria to install and upgrade a component represented in MOF can be altered to represent current systems criteria like apt-get,
or experiment with novel criteria.

The assumptions made in the \usermodel are:
\begin{itemize}
  \item The starting time of the evolution $t_0$ is October 30th 2009.
  \item The initial component system $\alpha_{t_0}$ is Ubuntu 9.10 (i386) released October 29th 2009.
  \item The simulation runs for 365 days.
  \item The available components to the evolving system are located at the central Ubuntu repository.
  \item Each package name has a probability that a user will select to install it. 
\end{itemize}

The time frame was selected to be over the year between the Ubuntu releases of system in 9.10 and 10.10 occurring between October 2009 to 2010.
The length of a year was selected to be simulated as 30/59 of users in our user survey responded that their systems are less than or about one year old.
The Ubuntu system has 6 monthly releases one, one in October and then one in April.
This means that in the middle of this simulation, April 2010, the effects of this release will impact the simulation.

The Ubuntu central repository is the core location for where packages are distributed to Ubuntu systems.
Using this as the set of packages because it is the default choice on Ubuntu systems.

A user would not realistically select to install any package into their system.
They would select packages for a purpose, to fulfil some requirement of their system.
Therefore, it is assumed that a user would more likely select some packages over others to be installed into their systems.
Further implied assumptions of this are:
\begin{enumerate}
  \item A user will select a package name, not a specific version to be installed.
  \item All users have the same probability to select a package name to be installed. 
\end{enumerate}
These assumptions are not realistic as each user is likely to prefer different packages and could select to install a specific version of a package. 
These differences to reality are further discussed in section \ref{sim.modelvalidation}.

\subsection{CUDF* Document Creation}
The process to create a CUDF* document from a configuration and the static properties is described here.
The first part of this process is to represent the initial system Ubuntu 9.10 and the Ubuntu repository as a CUDF* document template.
This document is a complete CUDF* document with the exception that it contains no user requests.
By adding requests to this template the evolution of a component system can be described.
How an Ubuntu 9.10 system and the Ubuntu repository are used to create the CUDF* template document is described in section \ref{sim.collection}.

Given this template and \usermodel variables the process to create a CUDF* document is described in figure \ref{sim.CUDF*}.
\begin{figure}[h]
\begin{center}
\begin{alltt}
createCUDF*(template, \(< u\), \(< i\), \(< U\), \(< I\)):
  for \(day\) in 1 to 365:
    if random-probability() \(< u\):
      add upgrade request to template at time \(t\sb{0}+day\) with criteria \(U\)
    if random-probability() \(< i\):  
      component = weighted selection from packages without replacement 
      add request to install component at time \(t\sb{0}+day+10 minutes\) 
                                                      with criteria \(I\)
\end{alltt}
  \caption{Process to create a CUDF* document that realistically describes the evolution of a component system}
  \label{sim.CUDF*}
\end{center}
\end{figure}

This process takes the CUDF* template and the variables from a user model instance and adds requests to the template to  create a complete CUDF* document.
Such a document describes the realistic evolution of an Ubuntu system.

The main loop iterates over the 365 days in which the simulation occurs.
Each day the ``user'' randomly selects to upgrade their system and/or install a component.

The function \texttt{random-probability()} is defined to return a random value between 0 and 1.
This function is used to decide what requests the user will make on a given day.

If a user requests to upgrade their system, the upgrade request is added to the template CUDF at time initial time $t_0$ plus the number of elapsed days, using the criteria $U$.
If the user requests to install a component, first the component to be installed is selected.
This selection is: 
\begin{itemize}
  \item \textit{Weighted}: components that are more likely to be installed are more likely selected
  \item \textit{Without replacement}: a user cannot select to install the same component more than once
\end{itemize} 
The request to install the selected component is then added to the template ten minutes after the initial time $t_0$ plus the number of elapsed days.
By adding ten minutes it ensures if the user requests to upgrade as well, this will always be prior to the install request.
The install request will use the criteria $I$ from the user model.

The discussion over how realistic the resulting CUDF* documents are is presented in section \ref{sim.modelvalidation}.
\section{Configuration Data Collection and Conversion}
\label{sim.collection}
In order to use the above presented process, data from the Ubuntu domain must be collected and converted into useful formats.
The collected data and their sources are:
\begin{enumerate}
  \item the set of Ubuntu packages and the times they became available, collected from the Ubuntu repository.
  \item the initial component system Ubuntu 9.10 collected from a virtual install.
  \item the probabilities different components will be selected to be installed, from the \texttt{app-install-data} package and weighted using the Ubuntu popularity contest.
\end{enumerate}

This section describes the data and how it was converted into a usable format.

\subsection{Collecting the Components}
The Ubuntu repository located at http://archive.ubuntu.com/ is the default location that Ubuntu packages are distributed from.
This repository contains a history of all packages that have ever been included with the minute that the package was uploaded.

To collect these packages and information from the repository first the repositories web site was parsed and all the packages were downloaded.
These Debian/Ubuntu packages are compressed with meta-information, code and binary files.

Second, each package was decompressed and the main meta-data file, the \textit{control} file, was extracted.
This control file was tagged with the upload time of the package to the Ubuntu Repository.

Third, all control files that did not have the key \verb+architecture+  include the value \verb+i386+ or \verb+all+ where removed.
This removes any package that would not work on the simulated Ubuntu system die to architecture incompatibility.

Fourth, the control files are converted into a single CUDF* template.
The control files are a very similar format to the CUDF format, as CUDF was largely based on this format.
An example of both these formats is presented in section \ref{background.models}.
The conversion from Debian control files to a CUDF document is described by \cite{abatetrenen2010}.
This report describes the handling of virtual packages and the conversion of versions. 
This process is mostly followed to create the CUDF* template.
The exceptions between the described process and the one used are:
\begin{itemize}
  \item The apt-pinning priorities are ignored
  \item If a package has the value \texttt{require} for key \texttt{priority}, the CUDF package is given the property \texttt{keep: package}, to ensure the package remains between requests.
  \item In the \texttt{preamble} the time $t_0$ is added.
  \item Each CUDF package has the key \texttt{time} added with the tagged time of the control file.
  \item A self conflict is not added to each package to simulate the restraint that only one version of each package is allowed to be installed.
\end{itemize} 
The final difference is significant as it differs from how real Ubuntu systems evolve and could invalidate the simulations results.
However, the restriction for these systems to only allow one version to be installed is an interesting point of study.
By allowing multiple packages to be installed means that this specific constraint can be studied.
For example, questions like ``how often does an install request require the installation of multiple packages?'' 
or ``how much does does this restriction effect the evolution of Ubuntu systems?'' can be answered by not enforcing this restriction.
It is still preferable for a user to not have multiple versions of a pacakage.
Therefore, this restriction can be ``softly'' enforced through using a criterion to minimise the number of packages with multiple versions.
Such a criterion is discussed in section \ref{impl.ipp}.

\subsection{Probability a component will be selected}
%%%The probability a component will be selected
Different users will likely select different packages to install.
For example, a user who is a graphic designer will more likely select graphics editor tools to be installed, and less likely select programming tools.
However, simulating the type of each user and their individual preferences of what they would install is impractical.
For this simulation each package's probability to be installed will be the same for all simulated users.

To define the probability a user will select a package to install, the problem is broken into two questions:
\begin{enumerate}
  \item What packages would a user select to install?
  \item How often are these packages selected to be installed?
\end{enumerate}
Most packages in the repository a user would not likely directly select to install.
Packages that provide libraries, background daemons, interfaces between services are usually installed because other packages depend on them, not because the user selected to install them.
By answering the first question a set of packages can be found that a user may install.
Further, by looking at current systems and what packages they have installed, the probability that these packages are selected to be installed can be calculated.
These questions are answered using data from the package \texttt{app-install-package} and the Ubuntu popularity contest.

The package \texttt{app-install-package} contains a list of 2399 packages\footnote{as of May 24th 2011} with meta-data like icons and descriptions.
This data is used by other applications, like the Ubuntu Software Center, to provide a list of packages the user may wish to install.
Some of these packages are installed by default in Ubuntu systems, and some are not available in the Ubuntu repository.
After filtering such packages from the provided list there remain 2087 packages that the user may select to install in their system. 

%%%PopCon
The probability a package from the \texttt{app-install-package} list is actually selected to be installed can be calculated using the Ubuntu popularity contest\footnote{http://popcon.ubuntu.com/ accessed 6/3/2012}.
The Ubuntu popularity contest is a broad data-set of information of the popularity of Ubuntu packages.
Each week an automated survey is submitted by nearly two million users, that contains information on what packages a user has installed and uses.
The results from this survey are processed and the number of systems that have a package installed is presented in the Ubuntu popularity contest.
Through finding the number of systems each package from the \texttt{app-install-data} packages is installed in then dividing by the total survey respondents, 
the probability a package is selected to be installed is estimated.

\subsection{\usermodel model Validation}
\label{sim.modelvalidation}
The \usermodel validation has been accomplished through:
\begin{itemize}
  \item discussions with project supervisors and other stakeholders.
  \item comparing \usermodel to the responses from the user survey.
  \item compare generated CUDF* documents with \texttt{apt-get} logs collected from 19 respondents of the survey.
  \item creating a virtual Ubuntu 11.10 system to study its perspective of the Ubuntu repository changing over the month of November 2011.
\end{itemize}

Using these methods differences between the simulation and the reality of CSE can be identified and discussed.
These differences largely come from the randomness in \usermodel, e.g. randomly selecting packages to install,
and from the limitations of the model, e.g. the limited amount of types of request.
Additional differences exist in the way in which \usermodel uses the Ubuntu repository.
This section discusses these differences and their impacts on the validity of \usermodel.

\subsection{Randomness of \usermodel}
When generating a CUDF* document, each simulated day there are three points of randomness in \usermodel:
\begin{enumerate}
  \item the probability a user requests upgrade their system, the $u$ variable
  \item the probability a user requests to install a component, the $i$ variable
  \item if the user requests to install, what package is selected to be installed
\end{enumerate}
In reality, a user's request to upgrade the system or install a component are not random.
These requests are reasoned about using gathered information, preferences and external constraints.
Even the most insignificant aspect of a user may impact requests, e.g. the favourite colour of a user may impact the choice of which component to install.
To model a user completely would be difficult, if not impossible, and would require significant effort.
\usermodel instead simulates the user with random behaviour.
The impact on validity of the randomness of these behaviours is discussed here.

The variables $u$ and $i$ introduce randomness into the simulation that does not exist in real CSE.
For example, a user who upgrades their system each work day (Monday to Friday) would have a probability to upgrade their system as $5/7$.
Describing such a user with \usermodel and then generating a CUDF* document may create a situation where they will upgrade their system on a Saturday.
This is because users will not randomly select days to request changes, they have constraints (like the work week) and preferences that are not expressed in this model.

The most randomness in \usermodel comes from the selection of a random components to be installed.
This randomness causes many differences to the reality of CSE:
\begin{itemize}
  \item A real user would typically not randomly select a component to be installed, e.g. a user may read reviews of a component before deciding to install.
  \item Each user would have different preferences of which components to install, e.g. a software developer will install different components than a graphics designer.
  \item Installing one package may change the preference of installing another, e.g. installing of browser \texttt{firefox} would decrease the probability to install another browser such as \texttt{chromium}.
\end{itemize}
To address these issues would require a more data to be collected (or created) and the modifications would make \usermodel significantly more complex.
The reduced effort and cost during data collection and the simplicity of the model was decided to take priority in this matter.

To mitigate the randomness in \usermodel many CUDF* documents will be created from a single \usermodel instance, then simulated.
The results from these simulations can then be aggregated and analysed.
Additionally, any conclusions derived from the results will be tempered by being aware of the randomness in the instance of \usermodel being simulated.

There exist two assignments to the variables $u$ and $i$ that result in users that are not random:
\begin{enumerate}
  \item \textbf{Control} user: $u = 0$ and $i = 0$
  \item \textbf{Always Update} user: $u = 1$ and $i = 0$
\end{enumerate}
The ``Control'' user never requests to change their system, therefore will have minimal change and maximum out-of-dateness. 
The ``Always Upgrade" user will update every day, therefore have significant change and a minimum out-of-dateness (w.r.t. $U$).
These two users are further discussed in chapter \ref{experiments}.

\subsection{Limitations of \usermodel}
The limitations that \usermodel has are:
\begin{itemize}
  \item The initial set-up of the system (as described in the user survey) is not included
  \item Some types of requests are not included, e.g. remove requests
  \item Cannot request to install many components on the same day, or at the same time.
  \item The list of packages that can be installed (from \texttt{app-install-data}) does not include many commonly installed packages.
\end{itemize}
Each of these points will be addressed in order.

The initial set-up of a system, which is performed by many respondents of the user survey, is not included in \usermodel.
This set-up includes upgrading their system and installing new components.
The initial upgrade is ignored because the initial system is already uptodate and an upgrade would be superfluous.
The initial installation of components is ignored as it introduces to much randomness into the system, making comparison between users more difficult.

In a real Ubuntu system, a user may request many different types of action.
Such actions include \texttt{remove}, which respondents stated they used in the survey and was also shown to be used in the user logs with such requests as \texttt{apt-get remove tig}.
Although a request to remove a component is possible, both the survey and the logs show that it is rarely used.
This is the justification for the exclusion from the \usermodel.
 
A user may want to install many components with a single request, or many components with multiple requests in a single day.
Both these situations that commonly occur in the submitted logs.
For example, \texttt{apt-get install ia32-libs ia32-libs-gtk libqt4-core libqt4-gui} is a single request to install multiple components,
and  \texttt{apt-get install autoconf} and \texttt{apt-get install checkinstall} are two requests performed within ten minutes of each other on the same day.
Given the significant randomness in selecting a component to be installed, introducing either of these situations into \usermodel would only make results less valid.
For this reason, these situations are not able to be simulated with \usermodel.

In reality, a users often request to install packages that are not included in the list from the \texttt{app-install-data} package. 
For example, the package \texttt{build-essential}\footnote{\texttt{build-essential} contains tools to build Debian packages}
cannot be requests to be installed with \usermodel even though it is regularly requested to be installed in the submitted logs.
Much effort in creating \usermodel was directed at finding a list of the most commonly installed packages.
However, the core problem was that there exists very little information on what packages users commonly request to be installed.
This problem is seen as a possible future research, and potential solutions are described in chapter \ref{conclusion}. 

\subsection{Ubuntu Repository of \usermodel}
In a real Ubuntu system, the only a subset of the packages in the Ubuntu repository is visible.
This ``view'' of the repository is the set of packages considered when resolving a request.
This is different to \modelname and \usermodel, 
where every request can consider all components that exist at the time of the request. 

To study this effect a virtual Ubuntu 11.10 system was created, 
and each day in the month of November 2011 the subset of components that it could view in the Ubuntu repository was saved.
This system used only the default ``view'' of the Ubuntu repository.
This ``view'' is compared to the changes in the repository of components over the month November 2009 in the \usermodel repository.

The \usermodel repository contains about 90,000 different package names, where the virtual ``view'' contained only about 40,000.
This difference is made up mostly of deprecated packages, i.e. packages that are no longer actively maintained.
It is also made up of packages that are have not yet been validated and put into the main ``view'', i.e. like experimental packages. 
This means that the amount of packages that have a new version added to the repository is much higher in the \usermodel repository,
126 packages per day compared to the virtual systems view of 37 packages per day.
The most dramatic difference though is the amount of removed packages from the ``view'' which is 8, because the \usermodel repository never removes a package. 

Another difference was noticed in the virtual Ubuntu system, different components can have the same name and the same version.
This is a incompatibility with the \modelname model, which states that components are defined by a unique name and version pair.
Two components could have the same name and version in the virtual system 
if they were compiled for different hardware architectures or if they are the source code of the package.
This is not a problem in \usermodel, as all source packages and packages that are not \texttt{i386} architecture were filtered out.

The reason a ``view'' of the repository was not used in the simulation is due to the fact that no data-source could be found 
that saved the set of packages that could be viewed in the Ubuntu repository at a particular time.
This lack of data lead to the decision that all components should be used.

\section{Summary}
In this chapter possible options were discussed for studying various strategies employed when evolving component systems.
Simulation, through the methodology \citep{Law2005} describes, was selected, and the steps involved were described.
The central artifact of this methodology, the \usermodel model, was broken down into models of the user, repository and solver, and the processes of simulation.
These models were validated through regular meetings with the core stakeholders, and a survey conducted on subject matter experts.
In the next chapter the configuration of the simulation is further defined, and the questions about component system evolution are attempted to be answered.
