\chapter{Simulation Model}
\label{simulation}
\epigraph{A model is a physical, mathematical, or logical representation of a system entity, phenomenon, or process. 
A simulation is the implementation of a model over time. 
A simulation brings a model to life and shows how a particular object or phenomenon will behave.}
{\textit{Systems Engineering Fundamentals. Defense Acquisition University Press, 2001}}

In the previous chapter, the \modelname model was defined to represent CSE.
While a \modelname instance can be used to describe improbable CSE situations, 
e.g. a user requesting to install the same component every second for a century,
a goal of this research is study the evolution of \textit{real} systems. 
Therefore, it is necessary to create \textit{realistic} instances of \modelname. 
For this purpose the simulation \textbf{simulation model} of CSE was developed.
This model can be used to create realistic descriptions of the evolution of component systems that can be later simulated.

This model was developed using the results of a survey conducted to determine how users change their component systems.
An instance of this model (called a \textbf{configuration}) contains variables to create a realistic scenario of CSE.
An example of such a variable is the probability a user will update their system per day.
These variables are used to create a CUDF* document that can then be simulated.
These relationships are described in figure \ref{sim.modeldiagram}.

\begin{figure}[htp]
\begin{center}
\digraph[scale=.5]{simmodeldiagram}{
rankdir=BT;
CMS[label=<<TABLE BORDER="0" CELLBORDER="1" CELLSPACING="5"><TR><TD WIDTH="150">CUDF*</TD></TR></TABLE>> shape=none];
subgraph {
	rank=same;
	CMI[label=<<TABLE BORDER="0" CELLBORDER="1" CELLSPACING="5"><TR><TD WIDTH="150">:CUDF*</TD></TR></TABLE>> shape=none];
	ConMI[label=<<TABLE BORDER="0" CELLBORDER="1" CELLSPACING="5"><TR><TD WIDTH="150">:Configuration</TD></TR></TABLE>> shape=none];
}
ConM[label=<<TABLE BORDER="0" CELLBORDER="1" CELLSPACING="5"><TR><TD WIDTH="150">Simulation Model</TD></TR></TABLE>> shape=none];
CMI -> CMS [ label="instantiates"];
ConMI -> ConM [ label="instantiates"];
ConMI -> CMI [ label="creates"];
}
  \caption{Diagram of the Simulation models relationships}
  \label{sim.modeldiagram}
\end{center}
\end{figure}

This chapter first describes the user survey that explores how component systems are changed by their users.
The simulation model is then presented by describing the different variables and how a configuration is used to create a CUDF* document.
The data that was collected and the processes to convert the data into a useful format usable by the simulation model are then described.

\section{User Survey}
\label{strat.usersurvey}
To explore the user role in CSE and to construct a simulation model, a survey was conducted on users of component systems.
This survey targeted users of GNU/Linux distributions (specifically Ubuntu) and server administrators through the online forum reddit\footnote{http://reddit.com accessed 6/3/2012}.
It was completed by 59 users, who answered questions about their background, systems they use, and the ways they change their component systems.
In this context, the way in which component systems are changed is through interaction with package manager applications. 
Therefore, the questions were primarily about this interaction.

In this section, a brief description of the survey and an analysis of responses are given.
The results from this survey are used to describe and categorise the motivations and behaviours of users when changing their component systems.
A detailed descriptions of questions in the survey can be found in appendix \ref{apx.survey}. 

\subsection{Questions}
%%%The goals of the survey:
The survey consisted of two groups of questions: questions that identified the type of user and questions that described their interactions with package managers.
The set of questions used to identify the user were:
\begin{itemize}
  \item How experienced with package managers are you (based on scale of 1 to 5 where 1 is no experience and 5 is highly experienced)? 
  \item What system are you using?
  \item What package manager are you using?
\end{itemize}
These can be used to categorise the type of user and weigh their answers for credibility based on their self rated experience.

The set of questions that asked about the use of package mangers were:
\begin{itemize}
  \item After you install a new system, what are your first interactions with the package manager?
  \item Describe your day to day interactions with the package manager?
  \item At what frequency are your typical interactions with the package manager?
\end{itemize}
These questions were focused on identifying the life-cycle of interactions that users have.

\subsection{Results}
%%%The results are summarised as:
As was already mentioned earlier, the survey was completed by 59 respondents.
The majority of these (29) were Debian based operating systems users.
Among these users apt-get was the most popular package manager.
Thirteen respondents used ArchLinux\footnote{http://www.archlinux.org/ accessed 6/3/2012} with pacman\footnote{http://www.archlinux.org/pacman/ accessed 6/3/2012} as the package manager.
Other systems and package managers represented in this survey include Fedora with the yum package manger,
Slackware with the pkgtools package manager, and Gentoo with the portage package manager.

The mean of the respondents self ranked experience was 3.9/5.
While this can be considered a subjective measure, it is expected that the respondents were confident in their answers. 

The life-cycle questions have been summarised into the frequency of each request in table \ref{strat.tblaction}.
\begin{table}[htp]
\centering
\begin{tabular}{l | c | c | c | c |}
Request & Set-up & Daily & Weekly & Monthly \\
Upgrade  & 45 & 27 & 16 & 0 \\
Install & 49 & 6 & 17 & 3 \\
Remove & 6 & 4 & 1 & 0\\
\end{tabular}
\caption{Summary of the frequency of user actions with package managers}
\label{strat.tblaction}
\end{table}

Based on this table, the vast majority of respondents upgrade and install new components when they first set-up their system.
This also shows that most users upgrade their system daily, and many install packages weekly.
Additionally, this shows that users do not often remove packages. 

\subsection{Progressive vs. Conservative Users}
One goal of this survey was to identify user behaviours.
Based on responses, it can be concluded that users attitudes towards changing their systems are affected by the following risks:
\begin{itemize}
  \item the potential risk of changing the system and introducing new problems.
  \item the potential risk of becoming out-of-date and having old problems persist.
\end{itemize}
The behaviours of these users can be described with two user stereotypes, \textbf{conservative} and \textbf{progressive}.
These terms come from the domain of politics where conservatism is the philosophy that emphasises minimal and gradual change in society. %TODO ref
This philosophy is contrasted by progressivism that promotes change and reform. %TODO ref

Most users in the survey are partially motivated by both risks, e.g. a users response that express a slight conservative attitude:
\begin{quotation}
``In production I rarely remove packages (easier to leave software as-is than risk breaking stuff).''
\end{quotation}
The previous quote shows that this respondent less likely to change their system, even though it may be beneficial, as it may lead to a fault. 

Another example of a user response expresses a progressive attitude:
\begin{quotation}
``I update my packages whenever I log in each day''
\end{quotation}
The reason this user upgrades their system every day is likely to ensure that packages do not become out-of-date.
This behaviour may require significant change.

Both of these stereotypes have extremes.
One such extreme is when a user tries to eliminate all of the risks associated with being out-of-date.
For example, a user responded in the survey with an extreme progressive attitude:
\begin{quotation}
``I do run an unstable system all the time, I help mitigate this with some redundancy in my most frequently used components, 
using packages which perform the same function, but have different dependencies, since it's less likely to have multiple packages break at the same time. 
If something is rather buggy for me, I tend to update on a more frequent basis to check for the next stable point to jump into.''
\end{quotation}
This user has not fully tested components in their system (described as unstable packages).
To lower the risk that such packages have on the function of the system, this user has redundant functionality installed in their system.
This way the user tries to ensure that potential problems will not be too severe.
The system of this user will never be out-of-date, but will be changed frequently.

An example of user's extremely conservative response on the frequency with which they interact with the package manager:
\begin{quotation}
``As little as possible. I like build my box into whatever I'll need in the first couple of weeks after an install. 
Following the configuration and construction, only the occasional upgrade is necessary. 
Unless, of course, I receive a security notice about something.''
\end{quotation}
After the setting up of a system, this user will not change it unless there is a direct security risk.
This lack of change will result in the system quickly becoming out of date, though lowers the risks associated with change.

The risks associated with change and being out-of-date drive the users behaviours towards changing the system. 

\section{Simulation Model}
The simulation model consists of a set of variables that describe the user's behaviour when changing their component system.
An assignment to these variables is an instance of the simulation model, also called a configuration, is used to create a CUDF* document that describes a component system's evolution.
The variables that make up the simulation user are: 
\begin{itemize}
  \item $u$ is the probability a user requests to update the system per day.
  \item $i$ is the probability a user requests to install per day.
  \item $U$ is the MOF criteria used to select an optimal system for an update request.
  \item $I$ is the MOF criteria used to select an optimal system for an install request.
\end{itemize}

The variable $u$ is the probability per day that a user will update their system, and the variable $i$ is the probability a user will request to install a component.
The reason for selecting the ``per day'' resolution came from the user survey responses, where the most frequent these requests typically occurred was daily.

The $I$ and $U$ criteria to install and update a component represented in MOF can be altered to represent current systems criteria like apt-get,
or experiment with novel criteria.

\subsection{Static Properties}
The simulation created to study CSE for this research has some static properties:
\begin{itemize}
  \item The starting time of the evolution $t_0$, which is October 30th 2009.
  \item The initial component system $\alpha_{t_0}$, which is Ubuntu version 9.10 released October 29th 2009.
  \item The number of days the simulation runs, 365 days.
  \item The available components to the evolving system, which are located at the central Ubuntu repository.
  \item The probability a package name is selected to be installed is $IP$, it a set of names paired with probabilities i.e. $IP \subseteq \mathcal{N} \times \mathbb{R}$.
\end{itemize}

The time frame was selected to be over the year between the Ubuntu releases of system in 9.10 and 10.10 occurring between October 2009 to 2010.
The length of a year was selected to be simulated as 30/59 of users in our user survey responded that their systems are less than or about one year old.
The Ubuntu system has 6 monthly releases one, one in October and then one in April.
This means that in the middle of this simulation, April 2010, the effects of this release will impact the simulation.

The Ubuntu central repository is the core location for where packages are distributed to Ubuntu systems.
Using this as the set of packages because it is the default choice on Ubuntu systems.

A user will not select to install any package into their system, e.g. they will probably not request to install any library packages.
Additionally, a user will more likely select to install some packages over others, e.g. they are more likely to install a popular Internet browser over another.
The value $IP$ is a weighted pool of package names that are used to express these facts about the users.
How this value is defined is described in section \ref{sim.collection}.

\subsection{CUDF* Document Creation}
The process to create a CUDF* document from a configuration and the static properties is described here.
The first part of this process is to represent the initial system Ubuntu 9.10, and the Ubuntu repository as a CUDF* document template.
This document is complete, except for that it contains no user requests.
By adding requests to this template the evolution of a component system can be described.
How an Ubuntu 9.10 system and the Ubuntu repository are used to create the CUDF* template document is described in section \ref{sim.collection}.

Given this template and a configuration the process in described in figure \ref{sim.CUDF*}.
\begin{figure}[h]
\begin{center}
\begin{alltt}
createCUDF*(template, \(< u\), \(< i\), \(< U\), \(< I\)):
  for \(day\) in 1 to 365:
    if random-probability() \(< u\):
      add request to upgrade the system at time \(day + t\sb{0}\) with criteria \(U\)
    if random-probability() \(< i\):  
      component = weighted selection from \(IP\) without replacement 
      add request to install component at time \(day + t\sb{0} + 10 minutes\), with criteria \(I\)
\end{alltt}
  \caption{Create CUDF* document to describe the evolution of a component system}
  \label{sim.CUDF*}
\end{center}
\end{figure}

This process takes the CUDF* template and adds requests to it, to describe how a user changes their component systems over time.
The inputs to this method are the template and the configuration variables.
The main loop, loops over the 365 days in which the simulation occurs.
Each day the ``user'' randomly selects to upgrade their system, or install a component.
The function \texttt{random-probability()}, which returns a random value between 0 and 1, is used to decide what requests the user will make on a day.

If a user requests to upgrade their system on a day, the request is added to the template CUDF.
If the user requests to install a component, first the component to be installed is selected from the set $IP$.
This selection is: 
\begin{itemize}
  \item \textit{After the upgrade request}: the preference of users in the survey has shown that typically they will upgrrade before installing.  
  \item \textit{weighted}: so components that are more likely to be installed are more likely selected
  \item \textit{without replacement}: so that the user cannot select to install the same component more than once
\end{itemize} 


\subsection{Simulation Model Discussion}
The simulation model and its use to create CUDF* documents ignores two key points mentioned in the user's survey,
the removal of packages, and the initial set-up by the user of their system.

In the \modelname model, and in CUDF*, a user may select to remove a component from their system.
The simulation model presented does not allow the user to make such a request.
This exclusion is due to:
\begin{itemize}
  \item The users in the survey requested to remove components infrequently.
  \item Selecting a package to remove during evolution can easily create unsatisfiable evolution problems.
  \item It would make the simulation model overly complex. 
\end{itemize}
For these reasons, this simulation does not include the possibility the user may request to remove a package.

As described in the results from the survey, almost all users upgraded the system and installed new packages when first setting up their system.
This initial change is not included in the simulation model as it creates a different initial system for each user,
making the their comparison difficult.
Additionally, as the initial system, Ubuntu 9.10, is only one day old when the simulation starts, an initial upgrade is unnecessary.

Two additional points that should be discussed is the lack of correlation between the user's requests,
and the randomness in this model.

In the presented simulation model a user's request will not impact any future request.
This type correlation between requests could be in the form of user behaviours.
For example, a user that always upgrades before installing. 
Another type of correlation is where installing one package impacts the probability another package is installed.
For example, if a user selects to install a image manipulation package, another package that can view images may be installed as well.
The only exception to this, is that a user cannot request to install the same component multiple times.
Defining such correlations would dramatically increase the complexity of the simulation model.
It would also require significant data-collection and analysis to ensure to model.
Therefore, for the practicality of the simulation and the simplicity of the presented models, the correlation between requests is ignored.

The randomness between users that are created from the same configuration occurs in three places;
when they upgrade, when they install, and what they install.
A configuration that defines a user that always updates (where $u = 1$) and never installs ($i = 0$) will not have any randomness.
However, a configuration that defines a user that never updates ($u = 0$) and always installs ($i = 1$) will still be selecting to install random components.


\subsection{Simulation Model Validation}
The two main methods of validation of this model is discussions with project supervisors, and referencing the user survey. 

As described in the methodology; one effort to validate these artifacts is done through meetings and a structured walk-through with the core stakeholders.
In this simulation the core stakeholders are the project researcher and supervisors.
These are the people who are asking the questions and are also impacted by the outcome, therefore they are directly effected by the validity of the results.
Meetings where held at regular intervals to ensure the projects progress and direction where correct.

%%%Results from what else should be asked, install stuff not from repository, installs break
The survey described in chapter \ref{strategies}, 
was conducted at a point in the project when the simulation model was just being developed, so had considerable impact on these artifacts.
The questions asked in this survey helped gauge the necessity and frequency of user actions,
so that only the most important aspects of the problem can be selected to be simulated.
It also filled in gaps of what was missing from the survey and model, giving direction for exploration.



\section{Configuration Data Collection and Conversion}
\label{sim.collection}
In order to assign variables to a simulation model configuration, data from the Ubuntu domain must be collected and converted.
The 
These variables are broken into two groups; the context variables, which do not change over simulation executions; 
and variables which are changed to answer specific questions.
The implementation of the simulation processes are then described, with the necessary practical alterations made. 

\subsection{Context Variables in the Configuration}
%%%Context variables are common attributes
Some variables form the context of the simulation, these are static points that stay at a default assignment across simulation runs.
They are static because they are assumed to be universal for Ubuntu users, like the repository function and the probability a package will be installed by a user;
or they are assumed to be independent of component evolution, like the time frame and the initial system.

%%%Time frame between the two releases 10.2009-10.2010, specifically from 2009,10,31 for 365 days


%%%This time frame implies the initial system which is Ubuntu 10.09
The time frame start was selected to coincide with the release of the Ubuntu version 9.10.
This version was then selected to be used as the initial system, as if the user just installed a new Operating System onto their system.
Specifically the desktop i386 distribution was selected as it is the most popular among the users of Ubuntu.


\subsubsection{Collecting the Packages}
The information gathering must be accomplished with great care, as the resolution and detail must be precise.
The Ubuntu repository located at http://archive.ubuntu.com/ has accessible data of the necessary detail to be used.
It contains all packages that have ever been in the repository, and the information to the minute of when the package was added.

%%%These are the steps that are taken to create the repository function
To collect these packages and information from the repository, this process was followed:
\begin{enumerate}
  \item the repositories web site was recursively scrapped to create a set of pairs $P$ 
  such that each pair contains a download link to a package and the date that package was uploaded to the repository
  \item Each package in the set $P$ was then downloaded and the file tagged with its upload date
  \item A dpkg package is a compressed set of files, 
  which include the meta-data control file of the package; all packages are extracted and the control file is tagged with the upload date of its package 
\end{enumerate}

This process creates a set of control files $C$ each tagged with the date it was uploaded to the repository.

\subsubsection{dpkg to CUDF* mapping}
\label{ubuntusimulation.debtocudf}
The mapping of the Debian dpkg component meta-data to CUDF is mostly a direct process as the meta-data is very similar.
This similarity is due to the Mancoosi organisation goals basing CUDF on FOSS systems like Debian.  
There are a few differences however, these differences require some explaining when converting dpkg format to CUDF.
In this section, firstly these problems will be described and their solutions explained, 
then the process by which the set of control files is taken and the function $Rep(d)$ is created to return a CUDF file for a given date $d$.

%%%Versioning problem
\paragraph{Version Models}
The first complication when mapping dpkg to CUDF is that the versioning models are incompatible.
Debian uses a version mode \verb+[epoch:]upstream_version[-debian_revision]+,
where \verb+epoch+ is an unsigned integer and \verb+upstream_version+ and \verb+debian_revision+ are strings.
A Debian version is greater than another if its \verb+epoch+ is greater; 
if their \verb+epoch+'s are equal then its \verb+upstream_version+ is lexically greater; 
if their \verb+epoch+'s and \verb+upstream_version+'s are equal then its \verb+debian_revision+ is lexically greater.
This lexical comparison (further explained in \citep{Barth2005}) differs greatly and is far more complicated than the CUDF integer based version model.

To map a dpkg version to an integer then cannot be done without knowledge of all component versions refereed to in the repository.
Therefore, the most straight forward solution is to extract all refereed versions (not only package versions but those in package formulae as well),
and then sort them into a list such that their CUDF version is their index in the list.

\paragraph{Virtual Packages}
%%%Virtual Packages must be handeled, there are some specific debian semantics that are particularly important
Debian has a package type called a virtual package, this is an abstracted package, one that can be provided and depended upon but does not exist.
These packages provide an interface to some common functionality that can be provided by multiple packages.
For example any package providing the virtual package \verb+dhcp-client+ must include dhcp client functionality. 
Unlike other component models where this interface is defined in a verifiable manner like code or an ADL,
Debian defines virtual packages in documentation, a list of which is provided on the Debian site\footnote{http://www.debian.org/doc/packaging-manuals/virtual-package-names-list.txt/ accessed 6/3/2012}.

The main aspect that requires consideration when mapping from dpkg to CUDF is that only dependencies where no version is specified can be fulfilled by a virtual package.
For example, a dependency on \verb+foo+ can be satisfied by a package providing a \verb+foo+ virtual package, 
however a dependency on \verb+foo >= 1+ cannot be satisfied by the same virtual package. 
The solution to this difference is to change the name of all virtual packages to include the prefix \verb+virtual--+ and 
alter dependencies that do not include version information to include an addition disjunction of the virtual package.
For example, the line \verb+provides: foo+ is altered to be \verb+provides: virtual--foo+, 
and the dependency \verb+depends: foo+ is altered to \verb+depends: virtual--foo | foo+.

\paragraph{Priority}
In the meta-data of the dpkg format there is a mechanism in which to state how important a package is to the system, this is called the package priority.
This tag can be set to \verb+extra+, \verb+optional+, \verb+standard+, \verb+important+, and \verb+required+, where the last value expresses the necessity to have this package in a Debian system.
The priority of a package is an optimisation problem, where selecting between components can take this into account, 
except for the final value which expressly states that the package must be installed.
Therefore, the mapping from the dpkg priority value to CUDF, is only done when the value is \verb+required+ and it sets the mapped CUDF packages \verb+keep+ value to \verb+package+.

\paragraph{Date}
As CUDF has an extensible syntax, the date the package was uploaded to the repository can be described as a key/value pair in the packages CUDF description.
As described above the control file which describes gives the dpkg description of the package has been tagged with the date of upload.
This date is extracted and converted to seconds since the Unix epoch (midnight, Jan. 1st 1970) and mapped to the integer property \verb+date+ in the pacakges CUDF file.
For example, if a Debian package was uploaded on the date of 13 Feb 2009, at exactly 23:31:30, 
the mapped CUDF component $c$ would have the property \verb+date+ would equal $1234567890$, i.e $c$.\verb+date+ $= 1234567890$.

\paragraph{Architecture}
Another important property in the dpkg format is the architecture of the package.
This describes the necessary CPU/hardware for the package to be functional.
The architecture of a dpkg package is directly mapped to the architecture of the CUDF property \verb+architecture+, through using CUDF's extensible syntax.
For example, is the archicteure expressed in the dpkg control file is \verb+i386+ or \verb+all+ then the mapped CUDF package $c$ has property $c$.\verb+architecture+ $=$ \verb+i386+.

\paragraph{Mapping}
The function $Rep(d)$ takes a date $d$ and returns a CUDF file that contains all packages that exist in the repository on that date.
After mapping all the individual dpkg control files to individual CUDF files, where one package exists per CUDF file,
all the CUDF files are merged into one large file such, where $\mathbb{C}$ equals all CUDF components.
The process to create the function $Rep$ is described below:
\begin{enumerate}
  \item Given the assumption the system that is evolved in the simulation is of the architecture i386, 
  any component $c$ in $\mathbb{C}$ where $c$.\verb+architecture+ does not equal \verb+i386+ or \verb+all+ is removed.
  \item The function $Rep(d)$ then simply returns the set of components whose upload date is less than $d$, i.e. $C_d = [c \mid c$.\verb+date+ $ \leq d]$
\end{enumerate}

\paragraph{Differences}
%%%The main different is is that the entire repository is used here, where typically only a sub set is used
The one significant difference between a real repository and this simulated repository function,
is that a real Ubuntu user would likely use only a subset of the repository where this function uses all packages. 
Also, the conversion from the dpkg format to CUDF allows multiple package versions installed in the same system where this is expressly forbidden in the Debian semantics. 

Through the use of meta-data files which list subsets of packages inside the Ubuntu repository, a user can select portions of the repository to use.
These meta-data files are used for different life cycle reasons (e.g. separating unstable from stable) and separating core packages from third party software.
Creating a single repository out of all files was necessary as the states of the individual repositories are not stored,
so finding what is included on a given date is impossible.
To map a real user to this simulated user, the real user would select all meta-data files to use the entire repository of packages. 

%%%We allow multiple versions of the same package to be installed, this is different from the debian
Debian for the most part, does not allow multiple versions of the same package to be installed in a system simultaneously.
However, in some instances Debian allows multiple packages to be installed on the system, as long as two such packages are not ``configured'' at the same time.
If a package is not configured, then it's dependencies do not require to be satisfied and therefore differs from the CUDF model.
In this simulation, this specific semantic of Debian is ignore, and multiple versions of a package are allowed to be installed into a system.
Many of the criteria described in chapter \ref{strategies} discourage the inclusion of multiple version,
therefore it is expected to have little impact on the results of the simulation.
As this difference may effect the validity of the simulation however, during the simulation the effects will be measures and noted, and if the effects are significant discussed.


\subsection{Probability a component will be selected}
%%%The probability a component will be selected
Different users will be more likely to select different packages to install.
However, as discussed to simulate this probability is impractical, and is likely impossible.
Therefore, one simulated user probability will be created, this assumes that all users have the same likely hood of selecting packages.

To define the probability a user will select a package to install, the problem can be broken into two questions:
\begin{enumerate}
  \item What packages would a user select to install?
  \item How many systems have a package installed?
\end{enumerate}
These questions are answered using the set of packages listed in the package app-install-package with the Ubuntu popularity contest.

%%%What packages may a user select to install? We can determine this by looking at applications that are listed in the app-install-data package
Most packages in the repository a user would not likely directly select to install.
These packages provide libraries, background daemons, interfaces between services; they are usually installed because other packages depend on them.
Finding a set of packages that a typical user may select to install is difficult.

The package app-install-data contains a list of 2399 packages\footnote{as of May 24th 2011} with meta-data like icons and descriptions.
This data is used by other applications, like the Ubuntu Software Center, to provide a mechanism for a user to find a package they may wish to install.
Some of these a are already installed in the initial system, and some are not available in the core repository.
After filtering such packages out, the list has 2087 packages that the user can select to install from. 

%%%PopCon
The probability a package from app-install-data may be selected by the user for installation, must still be weighted.
For this task the data set available from the Ubuntu popularity contest\footnote{http://popcon.ubuntu.com/ accessed 6/3/2012} is used.
The Ubuntu popularity contest is an excellent, accurate and broad data-set of information of the popularity of Ubuntu packages.
Each week this automated survey is submitted by nearly two million users, that contains information on what packages a user has installed and uses.
The packages that are most popular are not the ones users most install, but packages that are most depended upon.

Through weighting the list from the app-install-data package with the number of systems that package is installed on,
the probability a package is selected to be installed can be measured.

%%%The core problem with this list is that not all packages that can be installed are listed, i.e. experienced users may install packages that are not applications, build-essential
Although a user will more likely install packages from the app-install-data list, it is not a complete list of packages that a user may install. 
For example, more experienced users may select to install packages that are libraries or development tools, that are not listed.
The package ``build-essential'' which contains tools to build Debian packages, is not included in the list, though is regularly installed.
This is a problem that was briefly described in chapter \ref{simulation}, where different types of user are likely to install different things.
It is an extremely difficult problem to solve, and any solution will also dramatically increase the complexity of the simulation.



\section{Summary}
{}In this chapter possible options were discussed for studying various strategies employed when evolving component systems.
{}Simulation, through the methodology \citep{Law2005} describes, was selected, and the steps involved were described.
{}The central artifact of this methodology, the simulation model, was broken down into models of the user, repository and solver, and the processes of simulation.
{}These models were validated through regular meetings with the core stakeholders, and a survey conducted on subject matter experts.
{}In the next chapter the configuration of the simulation is further defined, and the questions about component system evolution are attempted to be answered.
