\chapter{User Model}
\label{simulation}
\epigraph{A model is a physical, mathematical, or logical representation of a system entity, phenomenon, or process. 
A simulation is the implementation of a model over time. 
A simulation brings a model to life and shows how a particular object or phenomenon will behave.}
{\textit{Systems Engineering Fundamentals. Defense Acquisition University Press, 2001}}

In the previous chapter, CUDF* documents were used to describe the evolution of component systems through repeated user requests to change.
However, such a document can be used to describe unlikely user's,
e.g. a user requesting to install the same component every second for a century.
Given that a goal of this research is study the evolution of \textit{realistic} systems,
it is necessary to model realistic users. 
For this purpose the \usermodel (Simulated User) model was developed.
This model describes how a user would realistically change their component system,
and it can be used to create realistic CUDF* documents.
These relationships are described in figure \ref{sim.modeldiagram}.

\begin{figure}[htp]
\begin{center}
\digraph[scale=.5]{simmodeldiagram}{
rankdir=BT;
CMS[label=<<TABLE BORDER="0" CELLBORDER="1" CELLSPACING="5"><TR><TD WIDTH="150">CUDF*</TD></TR></TABLE>> shape=none];
subgraph {
	rank=same;
	CMI[label=<<TABLE BORDER="0" CELLBORDER="1" CELLSPACING="5"><TR><TD WIDTH="150">:CUDF* Document</TD></TR></TABLE>> shape=none];
	ConMI[label=<<TABLE BORDER="0" CELLBORDER="1" CELLSPACING="5"><TR><TD WIDTH="150">:\usermodelwx</TD></TR></TABLE>> shape=none];
}
ConM[label=<<TABLE BORDER="0" CELLBORDER="1" CELLSPACING="5"><TR><TD WIDTH="150">\usermodelwx</TD></TR></TABLE>> shape=none];
CMI -> CMS [ label="instantiates"];
ConMI -> ConM [ label="instantiates"];
ConMI -> CMI [ label="creates"];
}
  \caption{Diagram of the \usermodel models relationships}
  \label{sim.modeldiagram}
\end{center}
\end{figure}

The \usermodel model was developed in part using the results of a survey conducted to determine how users change their component systems.
This survey is described in section \ref{strat.usersurvey}.

\usermodel contains variables to create a realistic scenario of CSE, e.g. a variable that describes the probability a user will update their system on a given day.
In addition it contains information (e.g. the dates the simulation takes place) and assumptions (e.g. the probability a package will be selected to be installed) about the simulation.
\usermodel is presented in section \ref{sim.usermodel} and teh variables, information, and assumptions for the simulation are discussed.

To use \usermodel, data was collected and converted into usable formats.
The sources this data was collected from and the methods used to convert it are described in section \ref{sim.collection}.

This chapter concludes in section \ref{sim.modelvalidation} with a (or ) discussion over the validity of this \usermodel.
This section describes the differences between the reality of CSE and \usermodel.
These differences are important to explore, as they may reduce the validity of the results from the simulation.

\section{User Survey}
\label{strat.usersurvey}
To explore the user's role in CSE and to construct \usermodel model, a survey was conducted on users of component systems.
This survey targeted users of GNU/Linux distributions (specifically Ubuntu) and server administrators through the online forum reddit\footnote{http://reddit.com accessed 6/3/2012}.
It was completed by 59 users, who answered questions about their background, systems they use, and the ways they change their component systems.
In this context, the way in which component systems are changed is through interaction with package manager applications. 
Therefore, the questions were primarily about this interaction.

In this section, a description of the survey and an analysis of responses are given.
The results from this survey are used to describe and categorise the motivations and behaviours of users when changing their component systems.

\subsection{Questions}
%%%The goals of the survey:
The survey consisted of two groups of questions: questions that identified the type of user and questions that described their interactions with package managers.
The set of questions used to identify the user were:
\begin{itemize}
  \item How experienced with package managers are you (based on scale of 1 to 5 where 1 is no experience and 5 is highly experienced)? 
  \item What system are you using?
  \item What package manager are you using?
\end{itemize}
These can be used to categorise the type of user and weigh their answers for credibility based on their self rated experience.

The set of questions that asked about the use of package mangers were:
\begin{itemize}
  \item After you install a new system, what are your first interactions with the package manager?
  \item Describe your day to day interactions with the package manager?
  \item At what frequency are your typical interactions with the package manager?
\end{itemize}
These questions were focused on identifying the life-cycle of interactions that users have.

\subsection{Results}
%%%The results are summarised as:
As was already mentioned earlier, the survey was completed by 59 respondents.
The majority of these (29) were Debian based operating systems users.
Among these users apt-get was the most popular package manager.
Thirteen respondents used ArchLinux\footnote{http://www.archlinux.org/ accessed 6/3/2012} with pacman\footnote{http://www.archlinux.org/pacman/ accessed 6/3/2012} as the package manager.
Other systems and package managers represented in this survey include Fedora with the yum package manger,
Slackware with the pkgtools package manager, and Gentoo with the portage package manager.

The mean of the respondents self ranked experience was 3.9/5.
While this can be considered a subjective measure, it is expected that the respondents were confident in their answers. 

The life-cycle questions have been summarised into the frequency of each request in table \ref{strat.tblaction}.
\begin{table}[htp]
\centering
\begin{tabular}{l | c | c | c | c |}
Request & Set-up & Daily & Weekly & Monthly \\
Upgrade  & 45 & 27 & 16 & 0 \\
Install & 49 & 6 & 17 & 3 \\
Remove & 6 & 4 & 1 & 0\\
\end{tabular}
\caption{Summary of the frequency of user actions with package managers}
\label{strat.tblaction}
\end{table}

Based on this table, the vast majority of respondents upgrade and install new components when they first set-up their system.
This also shows that most users upgrade their system daily, and many install packages weekly.
Additionally, this shows that users do not often remove packages. 

\subsection{Progressive vs. Conservative Users}
One goal of this survey was to identify user behaviours.
Based on responses, it can be concluded that users attitudes towards changing their systems are affected by the following risks:
\begin{itemize}
  \item the potential risk of changing the system and introducing new problems.
  \item the potential risk of becoming out-of-date and having less functionality and old problems persist.
\end{itemize}
The behaviours of these users can be described with two user stereotypes, \textbf{conservative} and \textbf{progressive}.
These terms come from the domain of politics where conservatism philosophy that emphasises minimal and gradual change in society,
which is is contrasted by progressivism philosophy that promotes change and reform \citep{oed2010}.

Most users in the survey are partially motivated by both risks, e.g. a users response that express a slight conservative attitude:
\begin{quotation}
``In production I rarely remove packages (easier to leave software as-is than risk breaking stuff).''
\end{quotation}
The previous quote shows that this respondent less likely to change their system, even though it may be beneficial. 

Another example of a user's response that expresses a progressive attitude:
\begin{quotation}
``I update my packages whenever I log in each day''
\end{quotation}
The reason this user upgrades their system every day is likely to ensure that packages do not become out-of-date.
This behaviour may increase the functionality of their system and tries to fix packages with bugs, at the cost that it may also require significant change.

Both of these stereotypes have extremes.
One such extreme is when a user tries to eliminate all of the risks associated with being out-of-date.
For example, a user responded in the survey with an extreme progressive attitude:
\begin{quotation}
``I do run an unstable system all the time, I help mitigate this with some redundancy in my most frequently used components, 
using packages which perform the same function, but have different dependencies, since it's less likely to have multiple packages break at the same time. 
If something is rather buggy for me, I tend to update on a more frequent basis to check for the next stable point to jump into.''
\end{quotation}
This user has not fully tested components in their system (described as unstable packages).
To lower the risk that such packages have on the function of the system, this user has redundant functionality installed in their system.
This way the user tries to ensure that potential problems will not be too severe.
The system of this user will never be out-of-date, but will be changed frequently.

An example of user's extremely conservative response on the frequency with which they interact with the package manager:
\begin{quotation}
``As little as possible. I like build my box into whatever I'll need in the first couple of weeks after an install. 
Following the configuration and construction, only the occasional upgrade is necessary. 
Unless, of course, I receive a security notice about something.''
\end{quotation}
After the setting up of a system, this user will not change it unless there is a direct security risk.
This lack of change will result in the system quickly becoming out of date, though lowers the risks associated with change.

The risks associated with change and being out-of-date drive the users behaviours towards changing the system. 

\section{\usermodel model}
\label{sim.usermodel}
The \usermodel model consists of: 
\begin{itemize}
  \item a set of variables that describe the user's behaviour when changing their component system.
  \item a set of assumptions used by the simulation.
\end{itemize}
This section presents the variables and assumptions of \usermodel, and how an instance of this model can be used to create a CUDF* document.

\subsection{Variables and Assumptions}
The variables that make up the \usermodel are: 
\begin{itemize}
  \item $u$ is the probability a user requests to update the system per day.
  \item $i$ is the probability a user requests to install per day.
  \item $U$ is the MOF criteria used to select an optimal system for an update request.
  \item $I$ is the MOF criteria used to select an optimal system for an install request.
\end{itemize}

The variable $u$ is the probability per day that a user will update their system, and the variable $i$ is the probability a user will request to install a component.
The reason for selecting the ``per day'' resolution came from the user survey responses, where the most frequent these requests typically occurred was daily.
The $I$ and $U$ criteria to install and update a component represented in MOF can be altered to represent current systems criteria like apt-get,
or experiment with novel criteria.

The assumptions made in the \usermodel are:
\begin{itemize}
  \item The starting time of the evolution $t_0$ is October 30th 2009.
  \item The initial component system $\alpha_{t_0}$ is Ubuntu 9.10 (i386) released October 29th 2009.
  \item The simulation runs for 365 days.
  \item The available components to the evolving system are located at the central Ubuntu repository.
  \item Each package name has a probability that a user will select to install it. 
\end{itemize}

The time frame was selected to be over the year between the Ubuntu releases of system in 9.10 and 10.10 occurring between October 2009 to 2010.
The length of a year was selected to be simulated as 30/59 of users in our user survey responded that their systems are less than or about one year old.
The Ubuntu system has 6 monthly releases one, one in October and then one in April.
This means that in the middle of this simulation, April 2010, the effects of this release will impact the simulation.

The Ubuntu central repository is the core location for where packages are distributed to Ubuntu systems.
Using this as the set of packages because it is the default choice on Ubuntu systems.

A user would not realistically select to install any package into their system.
They would select packages for a purpose, to fulfil some requirement of their system.
Therefore, it is assumed that a user would more likely select some packages over others to be installed into their systems.
Further implied assumptions of this are:
\begin{enumerate}
  \item A user will select a package name, not a specific version to be installed.
  \item All users have the same probability to select a package name to be installed. 
\end{enumerate}
These assumptions are not realistic as each user is likely to prefer different packages and could select to install a specific version of a package. 
These differences to reality are further discussed in section \ref{sim.modelvalidation}.

\subsection{CUDF* Document Creation}
The process to create a CUDF* document from a configuration and the static properties is described here.
The first part of this process is to represent the initial system Ubuntu 9.10 and the Ubuntu repository as a CUDF* document template.
This document is a complete CUDF* document with the exception that it contains no user requests.
By adding requests to this template the evolution of a component system can be described.
How an Ubuntu 9.10 system and the Ubuntu repository are used to create the CUDF* template document is described in section \ref{sim.collection}.

Given this template and \usermodel variables the process to create a CUDF* document is described in figure \ref{sim.CUDF*}.
\begin{figure}[h]
\begin{center}
\begin{alltt}
createCUDF*(template, \(< u\), \(< i\), \(< U\), \(< I\)):
  for \(day\) in 1 to 365:
    if random-probability() \(< u\):
      add upgrade request to template at time \(t\sb{0}+day\) with criteria \(U\)
    if random-probability() \(< i\):  
      component = weighted selection from packages without replacement 
      add request to install component at time \(t\sb{0}+day+10 minutes\) 
                                                      with criteria \(I\)
\end{alltt}
  \caption{Process to create a CUDF* document that realistically describes the evolution of a component system}
  \label{sim.CUDF*}
\end{center}
\end{figure}

This process takes the CUDF* template and the variables from a user model instance and adds requests to the template to  create a complete CUDF* document.
Such a document describes the realistic evolution of an Ubuntu system.

The main loop iterates over the 365 days in which the simulation occurs.
Each day the ``user'' randomly selects to upgrade their system and/or install a component.

The function \texttt{random-probability()} is defined to return a random value between 0 and 1.
This function is used to decide what requests the user will make on a given day.

If a user requests to upgrade their system, the upgrade request is added to the template CUDF at time initial time $t_0$ plus the number of elapsed days, using the criteria $U$.
If the user requests to install a component, first the component to be installed is selected.
This selection is: 
\begin{itemize}
  \item \textit{Weighted}: components that are more likely to be installed are more likely selected
  \item \textit{Without replacement}: a user cannot select to install the same component more than once
\end{itemize} 
The request to install the selected component is then added to the template ten minutes after the initial time $t_0$ plus the number of elapsed days.
By adding ten minutes it ensures if the user requests to upgrade as well, this will always be prior to the install request.
The install request will use the criteria $I$ from the user model.

The discussion over how realistic the resulting CUDF* documents are is presented in section \ref{sim.modelvalidation}.
\section{Configuration Data Collection and Conversion}
\label{sim.collection}
In order to use the above presented process, data from the Ubuntu domain must be collected and converted into useful formats.
The collected data and their sources are:
\begin{enumerate}
  \item the set of Ubuntu packages and the times they became available, collected from the Ubuntu repository.
  \item the initial component system Ubuntu 9.10 collected from a virtual install.
  \item the probabilities different components will be selected to be installed, from the \texttt{app-install-data} package and weighted using the Ubuntu popularity contest.
\end{enumerate}

This section describes the data and how it was converted into a usable format.

\subsection{Collecting the Components}
The Ubuntu repository located at http://archive.ubuntu.com/ is the default location that Ubuntu packages are distributed from.
This repository contains a history of all packages that have ever been included with the minute that the package was uploaded.

To collect these packages and information from the repository first the repositories web site was parsed and all the packages were downloaded.
These Debian/Ubuntu packages are compressed with meta-information, code and binary files.

Second, each package was decompressed and the main meta-data file, the \textit{control} file, was extracted.
This control file was tagged with the upload time of the package to the Ubuntu Repository.

Third, all control files that did not have the key \verb+architecture+  include the value \verb+i386+ or \verb+all+ where removed.
This removes any package that would not work on the simulated Ubuntu system die to architecture incompatibility.

Fourth, the control files are converted into a single CUDF* template.
The control files are a very similar format to the CUDF format, as CUDF was largely based on this format.
An example of both these formats is presented in section \ref{background.models}.
The conversion from Debian control files to a CUDF document is described by \cite{abatetrenen2010}.
This report describes the handling of virtual packages and the conversion of versions. 
This process is mostly followed to create the CUDF* template.
The exceptions between the described process and the one used are:
\begin{itemize}
  \item The apt-pinning priorities are ignored
  \item If a package has the value \texttt{require} for key \texttt{priority}, the CUDF package is given the property \texttt{keep: package}, to ensure the package remains between requests.
  \item In the \texttt{preamble} the time $t_0$ is added.
  \item Each CUDF package has the key \texttt{time} added with the tagged time of the control file.
  \item A self conflict is not added to each package to simulate the restraint that only one version of each package is allowed to be installed.
\end{itemize} 
The final difference is significant as it differs from how real Ubuntu systems evolve and could invalidate the simulations results.
However, the restriction for these systems to only allow one version to be installed is an interesting point of study.
By allowing multiple packages to be installed means that this specific constraint can be studied.
For example, questions like ``how often does an install request require the installation of multiple packages?'' 
or ``how much does does this restriction effect the evolution of Ubuntu systems?'' can be answered by not enforcing this restriction.
It is still preferable for a user to not have multiple versions of a pacakage.
Therefore, this restriction can be ``softly'' enforced through using a criterion to minimise the number of packages with multiple versions.
Such a criterion is discussed in section \ref{impl.ipp}.

\subsection{Probability a component will be selected}
%%%The probability a component will be selected
Different users will likely select different packages to install.
For example, a user who is a graphic designer will more likely select graphics editor tools to be installed, and less likely select programming tools.
However, simulating the type of each user and their individual preferences of what they would install is impractical.
For this simulation each package's probability to be installed will be the same for all simulated users.

To define the probability a user will select a package to install, the problem is broken into two questions:
\begin{enumerate}
  \item What packages would a user select to install?
  \item How often are these packages selected to be installed?
\end{enumerate}
Most packages in the repository a user would not likely directly select to install.
Packages that provide libraries, background daemons, interfaces between services are usually installed because other packages depend on them, not because the user selected to install them.
By answering the first question a set of packages can be found that a user may install.
Further, by looking at current systems and what packages they have installed, the probability that these packages are selected to be installed can be calculated.
These questions are answered using data from the package \texttt{app-install-package} and the Ubuntu popularity contest.

The package \texttt{app-install-package} contains a list of 2399 packages\footnote{as of May 24th 2011} with meta-data like icons and descriptions.
This data is used by other applications, like the Ubuntu Software Center, to provide a list of packages the user may wish to install.
Some of these packages are installed by default in Ubuntu systems, and some are not available in the Ubuntu repository.
After filtering such packages from the provided list there remain 2087 packages that the user may select to install in their system. 

%%%PopCon
The probability a package from the \texttt{app-install-package} list is actually selected to be installed can be calculated using the Ubuntu popularity contest\footnote{http://popcon.ubuntu.com/ accessed 6/3/2012}.
The Ubuntu popularity contest is a broad data-set of information of the popularity of Ubuntu packages.
Each week an automated survey is submitted by nearly two million users, that contains information on what packages a user has installed and uses.
The results from this survey are processed and the number of systems that have a package installed is presented in the Ubuntu popularity contest.
Through finding the number of systems each package from the \texttt{app-install-data} packages is installed in then dividing by the total survey respondents, 
the probability a package is selected to be installed is estimated.

\subsection{\usermodel model Validation}
\label{sim.modelvalidation}
The \usermodel validation has been accomplished by:
\begin{itemize}
  \item discussions with project supervisors and other stakeholders.
  \item comparing \usermodel to the responses from the user survey.
  \item compare generated CUDF* documents with \texttt{apt-get} logs collected from 19 respondents of the survey.
  \item creating a virtual Ubuntu 11.10 system to study its perspective of the Ubuntu repository changing over the month of November,2011.
\end{itemize}

Using these methods differences between the simulation and the reality of CSE can be identified and discussed.
These differences largely come from the randomness in \usermodel, e.g. randomly selecting packages to install.
Other significant differences come from the limitations of the model, e.g. the limited amount of types of request.


\subsection{Randomness of \usermodel}
When generating a CUDF* document, each simulated day there are three points of randomness in \usermodel:
\begin{enumerate}
  \item the probability a user requests upgrade their system, the $u$ variable
  \item the probability a user requests to install a component, the $i$ variable
  \item  if the user requests to install, what package is selected to be installed
\end{enumerate}
Each of these creates a difference from reality.

The variables $u$ and $i$ may introduce randomness that does not exist in reality.
For example, a user who upgrades their system each work day (Monday to Friday) would have a probability to upgrade their system as $5/7$.
Describing such a user with \usermodel and then generating a CUDF* document may create a situation where they will upgrade their system on a Saturday.
This is because users will not randomly select days to request changes, they have constraints (like the work week) and preferences that are not expressed in this model.
To represent these aspects of a user was deemed to make \usermodel too complicated and difficult to understand. 

The most randomness in \usermodel comes from the selection of a random components to be installed.
This randomness causes many differences to the reality of CSE:
\begin{itemize}
  \item A real user would typically not randomly select a component to be installed, e.g. a user may read reviews of a component before deciding to install.
  \item Each user would have different preferences of which components to install, e.g. a software developer will install different components than a graphics designer.
  \item Installing one package may change the preference of installing another, e.g. installing of browser \texttt{firefox} would decrease the probability to install another browser such as \texttt{chromium}.
\end{itemize}
To address these issues would require a more data to be collected (or created) and the modifications would make \usermodel significantly more complex.
The reduced effort and cost during data collection and the simplicity of the model was decided to take priority in this matter.

There exist two assignments to the variables $u$ and $i$ that result in users that are not random:
\begin{enumerate}
  \item \textbf{Control User}: $u = 0$ and $i = 0$
  \item \textbf{Always Update User}: $u = 1$ and $i = 0$
\end{enumerate}
The control user requests nothing will have minimal change and maximum out-of-dateness, 
where the user that always updates will have significant change and minimum out-of-dateness (w.r.t. $U$).
These two users are discussed in chapter \ref{experiments}.

\subsection{Limitations of \usermodel}
%%%TODO up to here
%other requests including remove ignored -- not often done
%setting up the system initially -- introduces to much initial diversity making it difficult to compare 
%Randomness of requests -- not corrolated -- package installs\ldots

\subsection{Differences To Survey}
The \usermodel model and its use to create CUDF* documents ignores two key points mentioned in the user's survey,
the removal of packages, and the initial set-up by the user of their system.

In the \modelname model, and in CUDF*, a user may select to remove a component from their system.
The \usermodel model presented does not allow the user to make such a request.
This exclusion is due to:
\begin{itemize}
  \item The users in the survey requested to remove components infrequently.
  \item Selecting a package to remove during evolution can easily create unsatisfiable evolution problems.
  \item It would make the \usermodel model overly complex. 
\end{itemize}
For these reasons, this simulation does not include the possibility the user may request to remove a package.

As described in the results from the survey, almost all users upgraded the system and installed new packages when first setting up their system.
This initial change is not included in the \usermodel model as it creates a different initial system for each user,
making the their comparison difficult.
Additionally, as the initial system, Ubuntu 9.10, is only one day old when the simulation starts, an initial upgrade is unnecessary.

Two additional points that should be discussed is the lack of correlation between the user's requests,
and the randomness in this model.

%%%TODO validate the input,


%%%The core problem with this list is that not all packages that can be installed are listed, i.e. experienced users may install packages that are not applications, build-essential
Although a user will more likely install packages from the app-install-data list, it is not a complete list of packages that a user may install. 
For example, more experienced users may select to install packages that are libraries or development tools, that are not listed.
The package ``build-essential'' which contains tools to build Debian packages, is not included in the list, though is regularly installed.
This is a problem that was briefly described in chapter \ref{simulation}, where different types of user are likely to install different things.
It is an extremely difficult problem to solve, and any solution will also dramatically increase the complexity of the simulation.

\section{Summary}
{}In this chapter possible options were discussed for studying various strategies employed when evolving component systems.
{}Simulation, through the methodology \citep{Law2005} describes, was selected, and the steps involved were described.
{}The central artifact of this methodology, the \usermodel model, was broken down into models of the user, repository and solver, and the processes of simulation.
{}These models were validated through regular meetings with the core stakeholders, and a survey conducted on subject matter experts.
{}In the next chapter the configuration of the simulation is further defined, and the questions about component system evolution are attempted to be answered.
