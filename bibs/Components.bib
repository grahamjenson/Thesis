Automatically generated by Mendeley 1.6
Any changes to this file will be lost if it is regenerated by Mendeley.

@inproceedings{Szyperski2003,
address = {Washington, DC, USA},
author = {Szyperski, Clemens},
isbn = {0-7695-1877-X},
pages = {684--693},
publisher = {IEEE Computer Society},
title = {{Component {T}echnology: {W}hat, {W}here, and {H}ow?}},
year = {2003}
}
@article{Szyperski2000a,
author = {Szyperski, Clemens},
journal = {Dr. Dobb's},
month = may,
title = {{Components and Contracts}},
year = {2000}
}
@techreport{Bachmann2000,
annote = {Behavioral Contracts

        

        
Eiffel[Meyer 92b] and Spark[Barnes 97] languages allow pre and post conditions to be written into code. Some examples of extensions to more commonly used languages trying to be extended are iContract [Kramer 98], JML (Java Modeling Lan-guage) [Leavens 99], Jass (Java with assertions) [Fischer 99], Biscotti [Della 99], and JINSLA (Java INterface Specification LAnguage) [Mikhajlova 99]

        
Formal Methods may also be able to define the behaviour of components, OOZE [Alencar 92], VDM++ [D\"{u}rr 94], and Object-Z [Duke 95].

        
----------

        
"A Component is:

        
• an opaque implementation of functionality [Assume components are blackbox to protect code from consumers, and components should not rely on implementation]

        
• subject to third-party composition [This criterion implies that a component-based system can comprise components from multiple, independent sources, and that a system can be assembled by a third party system integrator who is not also a component supplier]

        
• conformant with a component model" [Component models prescribe how components interact with each other, and therefore express global, or architectural de-sign constraints, Conformance to component models transforms software implementations into architectural implementations]

        
----------

        
"Indeed, it is difficult to find categorical distinctions between compo-nent frameworks and operating systems, as both provide coordination mechanisms that en-force a particular model of component interactions. Nevertheless, we assert there are qualita-tive distinctions; for example, component frameworks will support a more restricted range of coordination schemes than a general-purpose operating system."

        
----------

        
Component Models

        

        
What is achieved from a Component Model
1. Uniform Composition
2. Appropriate Quality attributes, and Quality of Service attributes
3. Deployment of components and applications -- the Killer App

        
What standards and conventions will the Component Model enforce
1.Component Types: enforce types of components
2. Interaction schemes: How components interact with each other and the component framework, so contraints on types, multiplicities, and so forth. As well as
3. Resource binding: Which resources, like services, that a component can bind to.
----------

        
"An interaction contract specifies a pattern of interaction among different roles, and the reciprocal obligations of components that fill these roles."

        
----------

        
Early ---> Late binding

        
Early is when components are binded at development, late is when they are binded at runtime, aim towards runtime
"Thus, the price for late binding is additional complexity in the component model, and added constraints on the way components are developed and on how they expose their services to potential clients"
"In ex-change, component models that allow late binding offer greater flexibility for component substitution, for third-party integration, and for component markets."

        
----------

        
"Conventional APIs—that is, interface specifications written in programming languages such as those cited above—can conveniently express what we will refer to as functional properties.

        
...
Conventional APIs are not so well equipped to express what we
4 We will use the term module to refer to software implementations that have interfaces; we reserve the use of the term component to things that satisfy the SEI definition of that term.
CMU/SEI-2000-TR-008 11
refer to as extra-functional properties. These properties include things like performance, ac-curacy, availability, latency, security, and so forth. These are often referred to as quality at-tributes, or, when associated with a particular service, quality of service."
----------

        
Reciprocal Obligations of contracts specify what is needed to use the component and its services as well as what is needed by the component to provide those services.

        
----------

        
Property bleed is where components can become dependant on certain properties of another component through the interface, like performance and other extra functional requiremenets not explicitly described.

        
----------

        
"A software component merges two distinct perspectives: component as an implementation and component as an architectural abstraction; components are therefore architectural imple-mentations. Viewed as implementations, components can be deployed, and assembled into larger (sub)systems. Viewed as architectural abstractions, components express design rules that impose a standard coordination model on all components. These design rules take the form of a component model, or a set of standards and conventions to which components must conform."

        
----------

        
Synchronization

        
behavioural does not deal with distribution and concurrency
not very well understood
Object Calculus [Lano 97], Hoare’s Communicating Sequential Processes (CSP) [Allen 97], Milner’s pi-calculus [Canal 97, Henderson 97, Lumpe 97] with composition language Piccola [Acher 99]. a Combination has been proposed in Rice and Seidman [Rice 99].
----------

        
"By and large, there is general agreement on the broad outlines of what constitutes software component technology, and, by extension, component-based sys-tems."

        
----------

        
Abstract Interfaces those that are described independant of any implementation, bound interface those that are associated with an implementaiton. So the Abstract interface is the description of the functions in Java the implemented interfaces, and the bound interface is the implementation properties, like QoS properties, that can be represented in meta-data.

        
----------

        
Compositional Reasoning

        
Reasoning about a comopments trust properties 
"Without compositional reasoning we can not know which proper-ties of components and frameworks to certify. With weak compositional reasoning the value of certification will be questionable and therefore the economic incentives for third-party certification will never be sufficient to spur industry investment."
----------

        
"the long-term success of software component technology will hinge upon the availability of high-quality software components, and trust on the part of consumers that the components that they purchase are of high quality"

        
----------

        
Quality of Service properties are not another source of Dependancy, unless the lient relies upon them, this should be a goal to not rely on these QoS attributes.

        
----------

        
"In many respects component frameworks are like special-purpose operating systems, although they operate at much higher levels of abstraction."

        
----------

        
"With increased scope and accuracy comes (it seems) increased formality, which in turn leads to greater complexity and the need for still more specialized skills.

        
"Note, however, that Shaw argued that such completeness was impractical if not impossible." I disagree, with user generated rating of these components and a tree like structure of XML, you could query for only relavant crediantials to be rated.
Crediantials are not complete but they are useful
1. Truth vs Knowledge distinction, Cost vs Confidence in certifiying properties,
2. Open ended nature of Crediantials, More flexable way than the formal specification of interface, "Parnas that a module's interface is, essentially, the set of assumptions that can be made about that module [Parnas 71]."
----------

        
Quality of Service

        
maximum responce delay, average responce, precision, portability, adaptability
----------

        
the idea of interface contract is most closely linked to the work of Bertrand Meyer and the developments inspired by that work [Meyer 92a, Meyer 97]."

        
----------

        
Authorative certification, where an authority poepl trust i.e. IBM, attests to the credibility of a component, and its stated goals.

        
----------

        
The Contract Metaphor works for Components

        
1. contracts are between 2 or more parties
2. Paties negotiate the details before signing
3. Contracts presribe normative and measureable behaviours on all signatories
4. Contracts cannot be changed unless the changes are agreed upon by all signatories
----------

        
"The phrase component-based system has about as much inherent meaning as “part-based whole.”"

        
----------

        
"Software component technology supports building a particular style that includes compo-nents, component models, and component frameworks. The component model imposes de-sign constraints on component developers, and the component framework enforces these con-straints in addition to providing useful services"

        
----------

        
"A component model specifies the standards and conventions imposed on developers of components. Compliance with a component model is one of the properties that distinguish components (as we use the term) from other forms of packaged software"

        
----------

        
Attempts to append existing API's with extra functional exist mostly to "ensure that interface speci-fications are sufficiently complete to ensure correct integration"

        
----------

        
Significant Motivations

        
*Independant Extensions -- independatnly developed and deployed
*Component Markets -- New Market to be created around the technology
*Reduced Time to market
*Improved predictability -- contracts on functional and non-functinal requirements
----------

        
"A component contract specifies a pattern of interaction rooted on that component. The contract specifies the services provided by a component and the obligations of clients and the environment needed by a component to provide these services."

        
----------

        
"A robust market in software components will require standard component models and frameworks. However, experience has shown that different application domains have differ-ent requirements for performance, security, availability and other quality attributes. This ar-gues the need for more than one, and possibly many component models and frameworks."

        

        
----------

        
"The key technical concepts of CBSE [Component Based Software Engineering] that are needed to support this vision are described: component, interface, contract, component model, component framework, composition, and certification."

        

        
----------

        
Vision

        
"Component-based software engineering is concerned with the rapid assembly of systems from components where
• components and frameworks have certified properties; and
• these certified properties provide the basis for predicting the properties of systems built from components"
----------

        
"Advocates of software reuse equate components to anything that can be reused; practitioners using COTS software equate components to COTS products; software method-ologists equate components with units of project and configuration management; and soft-ware architects equate components with design abstractions."

        
----------

        
Components can be tested in sandboxed environments built for specific interfaces.

        
----------

        
Different types of interaction

        
Component-Component -- application level
Framework-Comeponent -- system level
Framework-Framework -- interoperability level
----------

        
Beugnard et. al. define four kinds of property: syntactic, behavioral, synchronization, and quality of service [Beugnard 99]... not perfect but it will do for our purposes.

        
----------

        
If a component starts to become dependent on other implementations instead of interface it can be quite difficult to re assemble code with other implementations of the same component, thus defeating the exercise in modularity.},
author = {Bachmann, Felix and Bass, Len and Wallnau, Kurt and Long, Fred and Comella-Dorda, Santiago and Seacord, Robert and Robert, John and Buhman, Charles},
institution = {Carnegie Mellon Software Engineering Institute},
keywords = {CBSE,Component},
mendeley-tags = {CBSE,Component},
month = may,
title = {{Volume {II}: {T}echnical {C}oncepts of {C}omponent-{B}ased {S}oftware {E}ngineering}},
year = {2000}
}
@article{Szyperski2000,
author = {Szyperski, Clemens},
journal = {Dr. Dobb's},
month = feb,
title = {{Point, Counterpoint}},
year = {2000}
}
@book{Szyperski2002,
address = {Boston, MA, USA},
author = {Szyperski, Clemens},
edition = {2nd},
isbn = {0201745720},
publisher = {Addison-Wesley Longman Publishing Co.},
series = {The Component Software Series},
title = {{Component Software: Beyond Object-Oriented Programming}},
year = {2002}
}
