\chapter{Resolving \modelname}
\label{implementation}
\epigraph{What I cannot create, I do not understand.}
{\textit{Richard Feynman, 1988}}
The previous chapter presented the \modelname model that describes the evolution of a component system as a series of evolution steps.
Each step evolves the component system by satisfying a user request and system constraints with a new component system that is optimal with respect to some criteria.
Calculating the resulting systems of these evolution steps is described as \textbf{resolving} a \modelname instance.
Resolving a \modelname instance can require a significant effort due to the nature of the problem (as discussed in the previous chapter).

This chapter turns attention to the way of resolving of a \modelname instance by mapping each of its steps to, then solving, a \modelimpl problem.
\modelimpl uses lexicographically ordered pseudo-Boolean criteria 
to find an optimal solution to a Boolean satisfiability (SAT) problem extended with pseudo-Boolean (PB) constraints (SAT+PB) \citep{dixon2004automating}.
These relationships are presented in figure \ref{impl.modelsatdiagram}.

\begin{figure}[htp]
\begin{center}
\digraph[scale=0.5]{implsatgraph}{
rankdir=BT;
SAT [label=<<TABLE BORDER="0" CELLBORDER="1" CELLSPACING="5"><TR><TD WIDTH="150">SAT problem</TD></TR></TABLE>> shape=none];
PBCrit [label=<<TABLE BORDER="0" CELLBORDER="1" CELLSPACING="5"><TR><TD WIDTH="150">PB criteria</TD></TR></TABLE>> shape=none];
SATPB [label=<<TABLE BORDER="0" CELLBORDER="1" CELLSPACING="5"><TR><TD WIDTH="150">SAT+PB problem</TD></TR></TABLE>> shape=none];
SS [label=<<TABLE BORDER="0" CELLBORDER="1" CELLSPACING="5"><TR><TD WIDTH="150">\modelimplwx</TD></TR></TABLE>> shape=none];
SSI [label=<<TABLE BORDER="0" CELLBORDER="1" CELLSPACING="5"><TR><TD WIDTH="150">:\modelimplwx</TD></TR></TABLE>> shape=none];
\modelnamewx [label=<<TABLE  BORDER="0" CELLBORDER="1" CELLSPACING="5"><TR><TD WIDTH="150">\modelnamewx</TD></TR></TABLE>> shape=none];
FMI [label=<<TABLE BORDER="0" CELLBORDER="1" CELLSPACING="5"><TR><TD WIDTH="150">:\modelnamewx</TD></TR></TABLE>> shape=none ];
SS -> PBCrit [label=uses];
SS -> SATPB [label=uses];
SSI -> SS [label=instanciates];
subgraph {
rank=same
	FMI -> SSI [ label="maps to 1..*" ];
}
SATPB -> SAT [label=extends];
FMI -> \modelnamewx [ label = "instantiates"];
}
  \caption{A description of the relationships of \modelimpl and \modelname}
  \label{impl.modelsatdiagram}
\end{center}
\end{figure}

The algorithm employed to solve \modelimpl problems is the novel lexicographic-iterative-strengthening algorithm.
This algorithm uses the iterative strengthening \citep{calistri1994iterative, le2010sat4j} and Davis-Putnam-Logemann-Loveland (DPLL) \citep{Davis1960, davis1962machine} algorithms.

This chapter also describes the implementation GJSolver.
GJSolver takes a CUDF* document parses it into a \modelname instance (as described in appendix \ref{apx.cudf}),
and resolves it by following the process described further in this chapter.
It will also be shown how GJSolver was verified through MISC.

Firstly, this chapter, in section \ref{impl.mapping} describes the \modelimpl problem and its mapping to an evolution step from a \modelname instance.
In section \ref{impl.algorithms}, the algorithms used to solve a \modelimpl problem, and resolve a \modelname instance are described.
Finally, in section \ref{impl.gjsolver} GJSolver is discussed, followed by the description of its verification through MISC.

\section{\modelimpl}
\label{impl.mapping}
A \modelname instance may consist of many evolution steps.
Each of these steps involves satisfying an evolution problem with an optimal solution defined using an evolution preference order.
To resolve a \modelname instance each evolution step is mapped to a \modelimpl problem.
A \modelimpl problem involves satisfying a SAT+PB problem with an optimal solution defined using lexicographically ordered PB criteria.
By mapping each evolution problem to a SAT+PB problem, and each evolution preference order to lexicographically ordered PB criteria,
a \modelname instance can be resolved.

This section describes the SAT problem and its extension to the SAT+PB problem by including pseudo-Boolean constraints.
It also presents the \modelimpl problem as consisting of a SAT+PB problem with PB criteria. 
The mapping from an evolution step of a \modelname instance to a \modelimpl problem is then described.

\subsection{Boolean Satisfiability Problem (SAT)}
Boolean satisfiability (SAT)  is the problem of determining if the variables in a Boolean equation can be assigned in such a way that the equation returns true.
SAT was the first identified NP-Complete problem \cite{cook1971}, meaning there is no known algorithm that efficiently solves all instances of SAT problems.
The fundamental difficulty of SAT problems, 
combined with the ability to map many problems to SAT, has spawned a community\footnote{http://www.satcompetition.org/ accessed 6/3/2012} 
dedicated to creating, enhancing, and testing various SAT solver implementations. 
SAT solvers have been used in various domains to address problems such as electronic design automation \citep{Marques-Silva2000}, 
model verification \citep{dennis2006}, and component system evolution \citep{leBerre2010}.

A common representation of a SAT equation is in Conjunctive Normal Form (CNF) \cite{Moskewicz2001}.
CNF is defined as a conjunction of clauses, 
where each clause is a disjunction of literals, e.g. $(a \vee b) \wedge (\neg b \vee c)$.

A SAT problem in CNF is defined as:
\begin{defs}
\label{impl.defSAT}
{\ }
\begin{enumerate}
    \item Let $V$ be a set of variables
    \item A \textbf{literal} is a variable $v$ or its negation $\neg v$.
    \item A literal $\neg \neg v \equiv v$
    \item Given a set of literals $P$, $\neg P \equiv \{\neg v \mid v \in P\}$
    \item A \textbf{clause} is a set of literals 
    \item A \textbf{formula} is a set of clauses \label{impl.whatisaformula}
    \item A \textbf{SAT problem} is a set of variables $V$ and a formula $F$
    \item A set of literals is \textbf{consistent} if for any variable $v$, the set of literals does not contain both $v$ and its negation $\neg v$.
    \item A clause $\mathcal{C}$ is \textbf{satisfied} by a set of literals $P$ if there exists a literal in $\mathcal{C}$ that is also in $P$.
    \item A \textbf{solution} to a formula $F$ is a consistent set of literals $P$, such that for every clause $\mathcal{C}$ in $F$, $\mathcal{C}$ is satisfied by $P$.
    \item A \textbf{partial solution} to $F$ is a subset of any solution, i.e. given $P$ is a solution, $P'$ is a partial solution iff $P' \subseteq P$.
    \item A SAT problem is \textbf{satisfiable} if there exists a set of literals $P$ that is a solution to $F$, otherwise the instance of the SAT problem is \textbf{unsatisfiable}. 
\end{enumerate}
\end{defs}

For example, consider a SAT problem where $V = \{a,b,c\}$ and $F = \{\mathcal{C}_1,\mathcal{C}_2\}$, where clauses $\mathcal{C}_1 = \{a,b\}$ and $\mathcal{C}_2 = \{\neg b, c\}$.
A solution for this problem could be $\{a,\neg b,c\}$ as $a \in \mathcal{C}_1$ and $\neg b \in \mathcal{C}_2$.
However, $\{a, \neg b, b\}$ is not a solution because it is not consistent, and $\{a, b, \neg c\}$ is not a solution because it does not contain a literal in $\mathcal{C}_2$.  


\subsubsection{Pseudo-Boolean Extension of SAT to SAT+PB}
A typical extension of the SAT problem is the inclusion of pseudo-Boolean constraints \citep{dixon2004automating} into SAT formula.
This extends the SAT problem to a SAT+PB problem.
PB constraints are a linear relation over Boolean variables.

A pseudo-Boolean function takes a set of Boolean literals and returns an integer, e.g. given a set of literals $P$, $f(P) = 4$.
\begin{defs}
\label{impl.PBfunction}
Given a tuple of literals $\langle l_1,\ldots,l_n \rangle$ and a tuple of integers $\langle a_1,\ldots,a_n\rangle$,
a \textbf{pseudo-Boolean function} takes a set of literals $P$, and returns an integer such that:

$f(P) = \sum \limits_{i=0}^n f_i(P)$
where $f_i(P) = \begin{cases} a_i & l_i \in P \\ 0 & l_i \not \in P \end{cases}$
\end{defs}
For example, consider the pseudo-Boolean function $f$ defined with a tuple of literals $\langle x_1, \neg x_2\rangle$ and a tuple of integers $\langle 1,3\rangle$.
The value of $f(\{x_1\})$ will equal $1$, $f(\{\neg x_2\})$ will equal $3$, and $f(\{x_1,\neg x_2\})$ equals $4$.

A pseudo-Boolean constraint is a relation between a PB function and an integer, e.g. given a set of literals $P$, $f(P) \leq 3$.
\begin{defs}
\label{impl.PBConstraint}
A \textbf{pseudo-Boolean constraint} is a tuple of a pseudo-Boolean function $f$, a relationship  $R$ in $\{\geq,>,\leq,<,=\}$, and an integer $k$, i.e. $\langle f,R,k\rangle$.
\end{defs}

\begin{defs}
A pseudo-Boolean constraint $\langle f,R,k\rangle$ is \textbf{satisfied} by a set of literals $P$ iff $ f(P)$ $R$ $k$.
\end{defs}
For example, the pseudo-Boolean function $f$ described in the above example can be combined with a relation $>$ and number $2$ to create the constraint $\langle f, >, 2 \rangle$.  
This constraint will be satisfied by the set of literals $P_1 = \{ x_1, \neg x_2 \}$ as $f(P_1) = 4$ and $4 > 2$, 
but not with the set of literals $P_2 = \{ x_1,  x_2 \}$ as $f(P_2) = 1$  and $ 1 \not > 2$.

A SAT problem can be extended to include pseudo-Boolean constraints by modifying definition \ref{impl.defSAT}.
This extension is accomplished first by adding the definition of what a PB constraint is, and what satisfies a PB constraint:

\textit{
\begin{enumerate}
\setcounter{enumi}{12}
  \item A \textbf{pseudo-Boolean constraint} is a tuple of a pseudo-Boolean function $f$, a relation $R$ in $\{\geq,>,\leq,<,=\}$, and a number $k$, i.e. $\langle f,R,k\rangle$.
  \item A pseudo-Boolean constraint $\langle f,R,k\rangle$ is \textbf{satisfied} by a set of literals $P$ iff $ f(P)$ $R$ $k$.
\end{enumerate}
}

Secondly, by modifying the definition of what a formula can contain and what a solution to it is:
\textit{
\begin{enumerate}
\setcounter{enumi}{5}
    \item A \textbf{formula} is a set of clauses and pseudo-Boolean constraints
\end{enumerate}
\begin{enumerate}
\setcounter{enumi}{9}
    \item A \textbf{solution} to a formula $F$ is a consistent set of literals $P$, such that for every clause $\mathcal{C}$ in $F$, $\mathcal{C}$ is satisfied by $P$,
    and for every pseudo-Boolean constraint $pb$ in $F$, $pb$ is satisfied by $P$. 
\end{enumerate}
}

To illustrate how the modified definition from SAT to SAT+PB problem works, 
consider a SAT+PB problem where $V = \{a,b,c\}$ and $F = \{\mathcal{C}_1,\mathcal{C}_2, \langle f, <, 2 \rangle\}$. 
Clauses $\mathcal{C}_1 = \{a,b\}$ and $\mathcal{C}_2 = \{\neg b, c\}$, 
and the function $f$ is defined with the tuple of literals $\langle a, b\rangle$ and a tuple of integers $\langle 1,3\rangle$.
A solution for this problem could be $\{a,\neg b,\neg c\}$ as $a \in \mathcal{C}_1$, $\neg b \in \mathcal{C}_2$, and $f(\{a,\neg b,\neg c\}) < 2$.
However, $\{\neg a, b, c\}$ is not a solution because $f(\{\neg a, b, c\}) \not < 2$. 

Pseudo-Boolean constraints can be translated into CNF clauses.
However, with the extension to include pseudo-Boolean constraints problems can be exponentially more concise, 
and more quickly solved \citep{dixon2004automating}.
Additionally, only minor amendments may be required to allow SAT solving algorithms (e.g. DPLL) to also solve SAT+PB problems.
Some such amendments are described by \cite{Sheini2006}.

\subsection{\modelimpl Problem}
\label{impl.lexsatproblem}
In order to create a \modelimpl problem, some criteria used to define what properties an optimal solution have are required.
Pseudo-Boolean criteria use a PB function to define an optimal solution.

\begin{defs}
A \textbf{pseudo-Boolean criterion} $\mathfrak{crit}$ is a tuple consisting of a pseudo-Boolean function $f$,
a relation over integers $R$ that is either $<$ or $>$, and a SAT+PB formula $I$,
i.e. $\mathfrak{crit} = \langle f, R , I \rangle$.
\end{defs}
The formula $I$ is used to define the auxiliary variables that represent values within the problem, but do not alter the problem.
Auxiliary variables have been used before in similar implementations \citep{argelich2010solving}.


\modelimpl uses lexicographically ordered PB criteria to find an optimal solution.
The lexicographic order is defined $(a,b) > (a',b')$ iff $a$ is greater than $a'$ or $(a$ equals $a'$ and $b$ is greater than $b')$.
These terms are translated to the \modelimpl domain.
\begin{defs}
Given a SAT+PB formula $F$, a pseudo-Boolean criteria $\langle f,R, I \rangle$, and two sets of literals $P$ and $P'$, 
$P$ and $P'$ are \textbf{equal} w.r.t. $\langle f,R, I \rangle$
iff $P$ and $P'$ are solutions to $F \cup I$ and $f(P) = f(P')$.
\end{defs}
Note that both $P$ and $P'$ must be solutions to the formula $F \cup I$, not just the formula $F$.
This is done to ensure that the auxiliary variables required by the criteria are available.

\begin{defs}
Given a SAT+PB formula $F$, a pseudo-Boolean criteria $\langle f,R, I \rangle$, and two sets of literals $P$ and $P'$, 
$P$ is \textbf{greater than}  $P'$ w.r.t. $\langle f,R, I \rangle$
iff $P$ and $P'$ are solutions to $F \cup I$ and $f(P')$ $R$ $f(P)$.
\end{defs}

These definitions are used to define the lexicographic order:
\begin{defs}
Given a formula $F$, lexicographically ordered PB criteria $\langle \mathfrak{crit}_1,\ldots,\mathfrak{crit}_n \rangle$, and two sets of literals $P$ and $P'$,
the $P$ is \textbf{lexicographically greater than}  $P'$ w.r.t. to $\langle \mathfrak{crit}_1,\ldots,\mathfrak{crit}_n \rangle$
iff there exists an $i$ between $1$ and $n$ where for all $j < i$, $P$ is equal to $P'$ w.r.t. to $\mathfrak{crit}_j$ and $P$ is greater than $P'$ w.r.t. $\mathfrak{crit}_i$.
\end{defs}

This lexicographic order is then used to define an optimal solution:
\begin{defs}
Given a formula $F$ and lexicographically ordered PB criteria $\langle \mathfrak{crit}_1,\ldots,\mathfrak{crit}_n \rangle$
an \textbf{optimal solution} is a solution $P$ to $F$ 
where no other solution $P'$ to $F$ exists such that $P'$ is lexicographically greater than $P$ w.r.t. to $\langle \mathfrak{crit}_1,\ldots,\mathfrak{crit}_n \rangle$. 
\end{defs}

A \modelimpl problem consists of:
\begin{itemize}
  \item a tuple of lexicographically ordered PB criteria $\langle \mathfrak{crit}_1,\ldots,\mathfrak{crit}_n \rangle$
  \item a SAT+PB formula $F$
\end{itemize}
A solution to \modelimpl problem is the optimal solution to $F$ w.r.t. to its PB criteria.

\subsection{Mapping \modelname Instance to \modelimpl Problem}
\label{impl.mapping}
Following from the definition of \modelname in section \ref{formal.step}, 
an instance of \modelname consists of a series of evolution steps at time $t_i$, where $i$ is from $1$ to $n$.
Each step consists of:
\begin{itemize}
  \item a time $t_i$
  \item the set of components $\mathbb{C}_{t_i}$ 
  \item an evolution problem $\delta_{t_i} \cup \omega_{t_i}$
  \item an evolution preference order $\prec_{\alpha_{t_{i-1}}}$
  \item a previous system $\alpha_{t_{i-1}}$.
\end{itemize}

To resolve a \modelname instance each step is mapped to a \modelimpl problem which consists of a SAT+PB formula $F$ 
and lexicographically ordered PB criteria $\langle \mathfrak{crit}_1,\ldots,\mathfrak{crit}_n \rangle$.

The set of components $\mathbb{C}_{t_i}$ are variables in the problem, i.e $\mathbb{C}_{t_i} \subseteq V_{t_i}$.

\begin{defs}
	A component system $\alpha_{t_{i-1}}$ is mapped to a set of literals where
   $\alpha_{t_{i-1}} := \alpha_{t_{i-1}} \cup \{\neg c \mid c \in \mathbb{C}_{t_i}$ and $ c \not \in \alpha_{t_{i-1}}\}$.
\end{defs}
A component system $\alpha_{t_{i-1}}$ is mapped to a set of literals that is the union of $\alpha_{t_{i-1}}$ and the set of negative literals of components not in $\alpha_{t_{i-1}}$.

The reverse mapping, from a set of literals to a component system is:
\begin{defs}
A set of literals $P$ is mapped to a component system $\beta$ such that $\beta := \{c \mid c \in \mathbb{C}_t$ and $x \in P\}$
\end{defs}
A component system is the set of components that are not negative in the set of literals.  
Note: the mapping from literals to components is surjective, and the mapping from components to literals is injective.


The evolution problem $\delta_{t_i} \cup \omega_{t_i}$ is mapped to the formula $F$
by mapping each constraint to a SAT clause or PB constraint:
\begin{enumerate}
  \item \textbf{Exclusion}: $\neg a := \{\neg a\}$
  \item \textbf{Conflict}: $a \rightarrow \neg c := \{\neg a, \neg c\}$ 
  \item \textbf{Inclusive Disjunction}: $a_1 \vee \ldots \vee a_n := \{a_1, \ldots,  a_n\}$ 
  \item \textbf{Dependence}: $a \rightarrow c_1 \vee \ldots \vee c_n := \{\neg a, c_1, \ldots, c_n\}$
  \item \textbf{Exactly One}: $a_1 + \ldots + a_n = 1 := $ a pseudo-Boolean constraint $\langle f,=, 1 \rangle$, 
  where $f$ is defined with the tuple of literals $\langle a_1 ,\ldots , a_n\rangle$ and the tuple of natural numbers $\langle 1_1,\ldots,1_n \rangle$.
\end{enumerate}


\subsubsection{Evolution Preference Order Mapping}
The evolution preference order $\prec_{\alpha_{t_{i-1}}}$ defined with a lexicographic composition of criteria $crit_{1} \oplus \ldots \oplus crit_{n}$ 
can be mapped to a tuple of PB criteria $\langle \mathfrak{crit}_1,\ldots,\mathfrak{crit}_n\rangle$
by mapping each criterion $crit_{i}$ to a PB criterion $\mathfrak{crit}_i$.

A criterion $\langle rank_{\alpha} ,\leq \rangle$ maps to a PB criteria $\langle f, R , I \rangle$ iff:
\begin{itemize}
  \item $R$ equals the strict order of $\leq$.
  \item given a solution $P$ to formula $I$, and $P$ maps to the component system $\beta$, $f(P) = rank_{\alpha}(\beta)$. 
\end{itemize} 

To map an evolution preference order to the PB criteria,
it must be defined with the lexicographically composed criteria.
To map a criterion to a PB criterion, it must satisfy the above constraints.
This means that:
\begin{itemize}
  \item not all evolution preference orders can be described with lexicographically ordered PB criteria
  \item not all criteria can be mapped to PB criteria
\end{itemize} 
Therefore, the mapping from evolution preference orders to PB criteria is a partial mapping.

The partial mapping from \modename criteria to PB criteria is not presented here.
This is because many of the \modename criteria that can be defined are not useful, 
e.g. a criteria that maximises the number of components whose name starts with the letter \texttt{a}.
Only specific criteria are mapped to PB criteria, these are presented in chapter \ref{strategies}. 

To further illustrate the mapping from a \modelname criteria to a PB criteria, an example is presented.
Consider two components $a$ and $b$, a criterion $\langle rank_{\alpha},< \rangle$ whose ranking function $rank_{\alpha}$ is defined as:

$rank_{\alpha}(\beta) = \begin{cases} 1 & a \in \beta \text{ or } b \in \beta\\ 0 & \text{otherwise} \end{cases}$

This criterion expresses the preference of having either components $a$ or $b$ (or both) in the system.

Further consider the pseudo-Boolean criterion $\langle f, < , I \rangle$.
The auxiliary variable $x$ is defined such that $x \Leftrightarrow a \in \beta \vee b \in \beta$.
This variable must be  converted to the set of CNF clauses, and included in $I$,
i.e. $I = \{\{\neg x, a,b\}, \{\neg a,x\}, \{\neg b, x \}\}$.
The PB function $f$ is defined with the tuple of literals $\langle x \rangle$ and natural numbers $\langle 1 \rangle$.

The criterion $\langle rank_{\alpha}, \leq \rangle$ maps to $\langle f, < , I \rangle$,
as the strict order $<$ from the criterion equals the order $<$ in the PB criterion.
Given a solution $P$ to $I$, where $P$ maps to the component system $\beta$, $f(P) = rank_{\alpha}(\beta)$.
This can is shown in table \ref{impl.critmapexmp}.
\begin{table}[h!]
\centering
\begin{tabular}{| c | c | c | c |}
\hline
$P$                                &    $\beta$            & $rank_{\alpha}(\beta)$     & $f(P)$\\ \hline    
$\{\neg a, \neg b, \neg x\}$     & $\{\}$                & 0                        & 0 \\
$\{\neg a,  b, x\}$             & $\{b\}$                & 1                        & 1 \\
$\{ a,  \neg b, x\}$             & $\{a\}$                & 1                        & 1 \\
$\{ a,  b, x\}$                 & $\{a,b\}$                & 1                        & 1 \\ \hline
\end{tabular}
\caption{Values to show $f$  maps to $rank_{\alpha}$}
\label{impl.critmapexmp}
\end{table}

The above example describes how a \modelname criterion can be mapped to a PB criterion.
In the following section, an algorithm that uses PB criteria to find optimal solutions to \modelimpl problems is presented. 

\section{Solving a \modelimpl problem}
\label{impl.algorithms}
Above a description is given how to map and instance of \modelname to \modelimpl problems.
This section describes the novel lexicographic iterative strengthening algorithms to solve \modelimpl problems.
This algorithm uses the DPLL algorithm \citep{Davis1960, davis1962machine} to find a solution to a SAT+PB formula,
and the iterative strengthening algorithm \citep{calistri1994iterative, le2010sat4j} to find an optimal solution to a SAT+PB problem given a  single PB criterion.


Finally, this section describes how a \modelname instance is resolved by mapping to \modelimpl problems.

\subsection{Davis-Putnam-Logemann-Loveland algorithm for SAT Solvers}
%%%A successful algorithm for solving SAT problems is the DPLL algorithm, here we describe it in overview
The Davis-Putnam-Logemann-Loveland (DPLL) algorithm \citep{Davis1960, davis1962machine} is a complete (meaning it will find a solution if one exists), 
backtracking-based search algorithm for solving SAT and SAT+PB problems.

DPLL takes a formula $F$ and a set of literals $P$ (described as a partial assignment), and returns a solution to $F$ if $P$ is a partial solution, 
otherwise returning \verb+UNSATISIFABLE+.
When \texttt{DPLL} is called without a value $P$, $P$ is defaulted to equal the empty set .
By first calling \texttt{DPLL} with $P$ as the empty set, then adding literals to $P$ and recursively calling itself; 
the DPLL function searches for whether a solution to the formula is satisfiable.
The DPLL algorithm in defined in figure \ref{impl.DPLL} (a slight modification of the algorithm presented in \citep{dixon2004automating}):
\begin{figure}[h]
\begin{center}
\begin{alltt}
function DPLL(\(F, P\)):
   \(P\) = unit-propagate(\(F, P\))
   if \(P\) is not consistent:
       then return UNSATISIFABLE;
   if \(P\) is a solution to \(F\):
       then return \(P\);
   \(l\) = decide\((P)\);
   \(answer\) = DPLL\((F, P \cup \{l\})\)
   if answer != UNSATISIFABLE 
       return answer
   else
       return DPLL\((F, P \cup \{\neg l\})\);
\end{alltt}
  \caption{Recursive DPLL algorithm}
  \label{impl.DPLL}
\end{center}
\end{figure}

\texttt{DPLL} first calls the \texttt{unit-propagation} function (further described in section \ref{impl.unit}) which derives literals that must be in $P$ if it is a solution.
Next DPLL checks whether $P$ is inconsistent, which means it is not a partial assignment.
Then DPLL checks if $P$ is a solution to $F$, at which point $P$ is returned.
The \texttt{decide} function (further discussed in section \ref{impl.litorder}) returns a literal $l$ that is not, nor whose negation is in $P$.
The literal $l$ is added to $P$, which is then checked to be a partial solution by recursively calling \texttt{DPLL}.
If $P$ with $l$ is a solution then the found solution is returned,
otherwise the search continues by adding $\neg l$ to $P$ and checking if it is a partial solution by calling \texttt{DPLL}.

\subsubsection{Unit Propagation}
\label{impl.unit}
The first line in the  DPLL algorithm calls the \texttt{unit-propagation} function.
This function uses the clauses in the formula, and the partial assignment to identify and add literals to $P$ that must be included if $P$ is to be a partial solution.

\begin{defs}
Given a partial assignment $P$, a clause $\mathcal{C}$ is called \textbf{unit} iff $\mathcal{C}$ is not satisfied by $P$, and $P$ contains all but one of the literals in $\neg \mathcal{C}$.
The literal whose negation is not in $P$ is called a \textbf{unit literal}. 
\end{defs}

For example, a clause $\{a,b,c\}$ is unit if the partial assignment contains $\neg b$ and $\neg c$ but neither $a$ or $\neg a$.
The literal $a$ is then a unit literal.

For a formula to be satisfiable given partial assignment, each unit literal must be included in the partial assignment,
because if their negation is included the clause is not satisfied by the partial assignment.
For example, given a formula $\{\mathcal{C}\}$, where $\mathcal{C} = \{a,b\}$;
given the assignment $\{\neg a\}$ the clause $\mathcal{C}$ is unit and unit literal is $b$.
If $\neg b$ were in the partial assignment, $\mathcal{C}$ would not be satisfied by $P$.
Therefore, $b$ must be in the $P$ for $\mathcal{C}$ to be satisfied.

The process of unit propagation is defined in figure \ref{impl.propagation}.
\begin{figure}[htp]
\begin{center}
\begin{alltt}
unit-propagate(\(F, P\)):
  while \(P\) is consistent and there exists a \(\mathcal{C} \in F\) that given \(P\) is unit:
    \(l\) = unit literal in \(\mathcal{C}\)
    \(P\) = \(P \cup \{l\}\)
  return \(P\)
\end{alltt}
  \caption{Pseudo code of Unit Propagation}
  \label{impl.propagation}
\end{center}
\end{figure}

\subsubsection{Decide}
\label{impl.litorder}
The function \verb+decide+ takes a partial assignmnet $P$ and returns a literal $l$ such that $l \not \in P$ and $\neg l \not \in P$.
That is, if $l =$ \verb+decide+$(P)$, then $\{l\} \not \in P$ and $\{\neg l\} \not \in P$.
This literal is the point which the algorithm branches.
The order in which the \verb+decide+ function selects literals to branch on is also known as the literal order.
This order greatly impacts the efficiency of DPLL, as selecting literals that are in a solution (if one exists) would quickly return the result.

\subsection{DPLL Advancements}
Though the DPLL algorithm is the basis of many modern SAT solvers, the actual implementations have been altered to increase efficiency.
Some changes, including the use of conflict learning, backjumping, and watched literals, are briefly described here.
This section is aimed at giving a broad overview of techniques used in current solvers.

\subsubsection{Conflict Learning and Backjumping}
Conflict learning \citep{stallman1976} is a technique to cache previously tried sets of assignments in order to stop re-solving the same sub-problems.
This is accomplished by remembering what clauses, also known as reasons, caused literals to be added to the partial assignment through unit-propagation. 
This process works by identifying a variable both inferred to be true and false,
then creating a new clause, known as the learnt clause, which stops that inconsistency being reached again.
This learnt clause is derived by disjoining the two reason clauses after removing both the references to the inconsistent variable.
This process is shown in figure \ref{impl.clauselearning}. 

\begin{figure}[htp]
\begin{center}
$\begin{array}{c}
\{a_1,\ldots,a_k, l\} \\
 \{b_1,\ldots,b_m,\neg l\}\\
\hline
\{a_1,\ldots,a_k, b_1,\ldots,b_m \}
\end{array}$
  \caption{Clause Learning. Where $\{a_1,\ldots,a_k, l\}$ is the reason for $l$, and $\{b_1,\ldots,b_m,\neg l\}$ is the reason for $\neg l$
   are used to create the learnt clause $\{a_1,\ldots,a_k, b_1,\ldots,b_m \}$.}
  \label{impl.clauselearning}
\end{center}
\end{figure}

For example, if the reason for the inferred literal $a$ is clause $\{a, b\}$, and the reason for $\neg a$ is clause $\{\neg a, c\}$,
then the learnt clause derived is $\{b,c\}$, and added to the formula.

Backjumping \citep{Gaschnig1979} is the technique which determines how far to up the search tree to backtrack when a conflict is found.
The higher up the tree the technique ``jumps'' to, the greater reduction of the search space.
The level at which the algorithm backjumps is typically the point at which the learnt clause becomes unit. 

More advanced methods of conflict learning occur by minimising the size of the learnt clauses, as presented in \citep{sorensson2009}.
This research describes search methods that use other reason clauses to find smaller, more succinct learnt clauses.
The smaller the clause, the more of the search tree is pruned and the more levels are backjumped through the search.

\subsubsection{Watched Literals}
As noted by studies into the efficiency of DPLL-based SAT solvers \citep{dixon2004automating}, unit propagation is where the bulk of the computation in DPLL occurs.
Attempts to increase the efficiency of this task was initially to find better heuristics \citep{JamesMCrawford1996} for the literal order, to encourage cascades of unit propagation.
These attempts were shown to work well on random SAT problems but be less efficient for large structured problems \citep{dixon2004automating}.

It was noted that within unit propagation most of the time was spent on identifying the unit clauses.
The naive approach to unit propagation is to examine every clause, and then every literal in the clause to find if it is unit or not.
A more efficient approach was proposed using watched literals \citep{Madigan2001}, where instead of examining each clause, 
the clauses maintain an index of all necessary literals and notify the algorithm when they become unit.
This ``don't call us, we will call you'' concept makes the efficiency of the unit propagation function less dependent on the amount of clauses in the formula.

Advances on watched literals have occurred through algorithms to maintain the index of literals, like that presented in \citep{Moskewicz2001}.
Such algorithms enable larger formulae to be solved without necessarily increasing the time to solve them.

\subsection{Iterative Strengthening}
The iterative strengthening algorithm  \citep{calistri1994iterative, le2010sat4j} 
is an anytime algorithm using constraint satisfaction to iteratively find better solutions to a SAT+PB formula w.r.t. a PB criteria.
This algorithm can be used to find optimal solutions to an evolution problem, given a pseudo-Boolean criterion.
This is done by first finding a solution, then iteratively adding constraints (created using the criterion) to ensure the next solution found will be better than the previous solution.
This is the strengthening process.
Strengthening continues until either the strengthened formula is found to be unsatisfiable, or the algorithm is interrupted, at which point the best solution currently found is returned. 
This algorithm is defined in figure \ref{impl.strength}.

\begin{figure}[htp]
\begin{center}
\begin{alltt}
iterative-strengthening(\(F\),\(\langle f\sb{\alpha}, R, I \rangle\)):
    \(F\) = \(F \cup I\)
    \(answer\) = DPLL(\(F\))
    if \(answer\) = UNSATISIFABLE:
        return UNSATISIFABLE
    do:
        \(model\) = \(answer\)
        \(J\) = strengthen(\(model\),\(\langle f\sb{\alpha}, R, I \rangle\))
        \(F\) = \(F \cup J\)
        \(answer\) = DPLL(\(F\))
    while not (interrupted() or  \(answer\) == UNSATISIFABLE)
    return \(model\) 
\end{alltt}
  \caption{Pseudo code of Iterative Strengthening Algorithm}
  \label{impl.strength}
\end{center}
\end{figure}

The first action in the \texttt{iterative-strengthening} is to include the formula $I$ that defines auxiliary variables used by the criterion.
This ensures that any solution returned by DPLL is also a solution to $I$.

The next action is to check if the formula is satisfiable.
This is accomplished by passing the formula to the \texttt{DPLL} function, and assigning its output to the variable $answer$.
If the output from \texttt{DPLL} is \texttt{UNSATISIFABLE}, then the algorithm stops and returns \texttt{UNSATISIFABLE}, as there are no solutions.

The main loop of this algorithm is then defined.
The first action in this loop is to assign the contents of the variable $answer$ to the variable $model$.
The variable $model$ is a set of literals, used as a store of the currently best found solution.

The function \texttt{strengthen} is then called to create a formula $J$.
The formula $J$ ensures that if \texttt{DPLL} is called with formula $F \cup J$, either:
\begin{itemize}
  \item a solution is returned that is better (w.r.t. the criterion) than the currently best found solution $model$. 
  \item \texttt{UNSATISIFABLE} is returned, showing that no better solution exists.
\end{itemize}

\begin{defs}
Given a set of literals $model$, and a criterion $\langle f, R, I \rangle$,
the function \texttt{strengthen} returns a formula $J$ consisting of a single pseudo-Boolean constraint, i.e. $ J = \{ \langle f,R,f(model) \rangle \}$.
\end{defs}
That is, \texttt{strengthen} returns a formula $J$,
that ensures any solution $P$, to the formula $F \cup J$, must have a better ( w.r.t. $R$) value of $f(P)$ than the previously best solutions value of $f(model)$.

The next steps are then to add the formula $J$ to $F$, then search for a new solution using \texttt{DPLL}.

The main loop will end given the condition that either the \texttt{interrupted} function returns $true$, or the \texttt{DPLL} function returns \texttt{UNSATISIFABLE}.
The \texttt{interrupted} method is typically defined to return false until some external input (like a user stopping the algorithm or a timer running out) is encountered.
The \texttt{interrupted} method has the additional responsibility of stopping the \texttt{DPLL} function, 
so that if at any point \texttt{interrupted} returns true the \texttt{DPLL} function immediately returns.
When the main loop ends, currently best found solution $model$ is returned.

\subsection{Lexicographic Optimisation}
\label{impl.lexiterstre}
The iterative strengthening algorithm can be used find optimal solutions to lexicographically ordered criteria
by iteratively strengthening the each criteria in order.
This lexicographic iterative strengthening algorithm is presented in figure \ref{impl.lexstrength}.

\begin{figure}[htp]
\begin{center}
\begin{alltt}
lexicographic-iterative-strengthening(\(F\),\(\langle{}\mathfrak{crit}\sb{1}, \ldots ,\mathfrak{crit}\sb{n}\rangle\)):  
    \(answer\) = DPLL(\(F\))
    if \(answer\) = UNSATISIFABLE:
        return UNSATISIFABLE
    \(i\) = 0
    \(model\) = \(answer\)
    do:
        \(i = i + 1\)
        \(K\) = lock(\(model\),\(\mathfrak{crit}\sb{i}\))
        \(F\) = \(F \cup K\)
        \(model\) = iterative-strengthening(\(F\),\(\mathfrak{crit}\sb{i}\))
    while not (interrupted() or \(i\) == \(n\))
    return \(model\) 
\end{alltt}
  \caption{Pseudo code of the Lexicographic Iterative Strengthening Algorithm}
  \label{impl.lexstrength}
\end{center}
\end{figure}

The first action of the \texttt{lexicographic-iterative-strengthening} algorithm is to check if the formula is satisfiable using the \texttt{DPLL} algorithm.
If it is unsatisfiable, this algorithm returns \texttt{UNSATISIFABLE}.

The variable $i$ is then defined, this variable is a counter used to select the criterion to be strengthened.
Also, $model$ is assigned to be the set of literals $answer$, and is used to store the currently best found solution.

The main loop of this algorithm is then defined.
This loop first increments the counter $i$, to select the appropriate criterion to be strengthened.

The function \texttt{lock} is then called to return a formula $K$.
The formula $K$ ensures that if \texttt{DPLL} is called with $F \cup K$:
\begin{itemize}
  \item a solution is returned that is not worse (w.r.t. the criterion $\mathfrak{crit}_i$) than the solution $model$. 
\end{itemize}

\begin{defs}
Given a set of literals $model$, and a criterion $\langle f, R, I \rangle$,
the function \texttt{lock} returns a formula consisting of a single pseudo-Boolean constraint, $\{ \langle f,=,f(model) \rangle \}$,
\end{defs}
That is, \texttt{lock} returns a formula $K$,
that ensures any solution $P$, to the formula $F \cup K$, must have the best value of $f$ found so far.

Note that $K$ does not effect the satisfiability of $F$, as $model$ is still a valid solution to $F \cup K$.

The formula $K$ is then added to the formula $F$, i.e. $F = F \cup K$,
then the \texttt{iterative-strengthening} algorithm is called to find an optimal solution to $F$ given the criterion $\mathfrak{crit}_i$.
As the formula $F$ is known at this point in the algorithm to be satisfiable, the only possible returned value from \texttt{iterative-strengthening}
is a solution that is no worse than $model$.
This means that the returned value could be equivalent to the previously defined solution, if there exists no better solution than what has already been found.

The main loop will iterate until either all the criteria have been optimised, or the function is interrupted.
When the loop ends, the currently best found solution $model$ will be returned.

Some enhancements to the implementation of the lexicographic iterative strengthening algorithm can be made.
For example, when the \texttt{iterative-strengthening} is called, it is known that $F$ is satisfiable. 
Therefore, checking its satisfiability again within the \texttt{iterative-strengthening} function is not necessary.

The lexicographic iterative strengthening algorithm is an anytime algorithm.
It has been designed to return a solution to a \modelimpl problem, even if it is interrupted.
If interrupted however, the returned solution may not be an optimal solution.
The reason for this anytime behaviour is that \modelimpl problems can be very difficult to solve.
This difficulty can make solving some problems take an impractical amount of time.
It is therefore practically necessary to limit the time this algorithm searches for an optimal solution, 
and interrupt it when this time limit is reached. 

\subsection{Resolving a \modelname instance}
Resolving a \modelname instance involves finding the series of component systems $\alpha_{t_1},\ldots,\alpha_{t_n}$.
To do this, each evolution step starting at $t_1$ and ending at $t_n$ is mapped to an \modelimpl problem and solved using the lexicographic iterative strengthening algorithm.
This resolver algorithm is presented in figure \ref{impl.resolver}.
\begin{figure}[h!t!]
\begin{center}
\begin{alltt}
resolver:  
    for \(t\sb{i}\) in \(t\sb{1}\ldots,t\sb{n}\):
        \(F\) and \(\langle{}\mathfrak{crit}\sb{1}, \ldots ,\mathfrak{crit}\sb{n}\rangle\) mapped from evolution step at \(t\sb{i}\)
        \(answer\) = lexicographic-iterative-strengthening(\(F\),\(\langle{}\mathfrak{crit}\sb{1}, \ldots ,\mathfrak{crit}\sb{n}\rangle\))
        if \(answer\) equals UNSATISFIABLE:
            \(\alpha\sb{t\sb{i}}\) = \(\alpha\sb{t\sb{i-1}}\)
        else:
            \(\alpha\sb{t\sb{i}}\) mapped from \(answer\)
    return \(\alpha\sb{t\sb{1}},\ldots,\alpha\sb{t\sb{n}}\) 
\end{alltt}
  \caption{Pseudo code of the Lexicographic Iterative Strengthening Algorithm}
  \label{impl.resolver}
\end{center}
\end{figure}

In this algorithm, the systems are calculated starting at time $t_1$ and stopping at time $t_n$.
For each evolution step at time $t_i$ is mapped to a SAT + PB formula $F$ and PB criteria $\langle \mathfrak{crit}_{1}, \ldots ,\mathfrak{crit}_{n} \rangle$.
The algorithm \texttt{lexicographic-iterative-strengthening} is then used to find an optimal solution to $F$ with respect to the PB criteria, and return $answer$.
Either $answer$ equals \texttt{UNSATISFIABLE} at which point the system $\alpha_{t_i}$ is assigned as the previous system $\alpha_{t_{i-1}}$ (according to ).
Otherwise, $answer$ is a set of literals that can be mapped back to the component system $\alpha_{t_i}$.
This algorithm, once completed, returns the set of component systems $\alpha_{t_1},\ldots,\alpha_{t_n}$.

\section{GJSolver}
\label{impl.gjsolver}
GJSolver is the implementation of the process from a CUDF* document to a resolved \modelname instance.
GJSolver grew through the course of this research to satisfy the need for an implementation to study CSE.
This implementation takes a CUDF* document, parses it to an instance of \modelname, which is then resolved by \modelimpl.

This process is described in figure \ref{impl.modelofgjsolver}.
\begin{figure}[htp]
\begin{center}
\digraph[scale=0.5]{implgjsolver}{
rankdir=LR;
subgraph cluster_0 {
label="GJSolver";
style=filled;
color=lightgrey;
FMI [label=<<TABLE  BORDER="0" CELLBORDER="1" CELLSPACING="5"><TR><TD WIDTH="150">:\modelnamewx</TD></TR></TABLE>> shape=none];
\modelimplwx [label=<<TABLE  BORDER="0" CELLBORDER="1" CELLSPACING="5"><TR><TD WIDTH="150">\modelimplwx</TD></TR></TABLE>> shape=none]
CMI[label=<<TABLE BORDER="0" CELLBORDER="1" CELLSPACING="5"><TR><TD WIDTH="150">:CUDF*</TD></TR></TABLE>> shape=none];
CMI -> FMI [ label="parsed to" ];
FMI -> \modelimplwx [ label="resolved by" ];
}
}
  \caption[labelInTOC]{GJSolver implementation description}
  \label{impl.modelofgjsolver}
\end{center}
\end{figure}

In this section the implementation and the validation of GJSolver are discussed.

\subsection{GJSolver Implementation}
\label{impl.gjsolverimpl}
The first decision made about the design of GJSolver was to base it on another similar implementation, Eclipse P2 \citep{le_berre_dependency_2009,leBerre2010}.
Basing the design on an existing implementation allowed the reuse of tools, and most importantly the reduction in risks during implementation.
The basis of GJSolver on Eclipse P2 lead to the following choices:
\begin{itemize}
  \item Java as the main implementation language
  \item SAT4J as the core SAT+PB solver
\end{itemize}

The main aspects where GJSolver does not reuse, or replicate Eclipse P2 is because P2 is designed especially for the OSGi and Eclipse component model, where GJSolver is designed for CUDF.
Some of the differences between Eclipse P2 and GJSolver are:
\begin{itemize}
  \item No OSGi or Eclipse specific code in GJSolver
  \item The internal representation of components is not based on OSGi
\end{itemize}

GJSolver, like Eclipse P2, uses iterative strengthening to find a solution.
However, Eclipse P2 represents all criteria as a single PB criterion, where GJSolver represents them as a tuple (as described in section \ref{impl.lexiterstre}).
How these two methods directly compare has not been explored in this research.

\subsubsection{SAT4J}
Given the use of SAT4J in GJSolver, a brief background of its development is presented here.

MiniSAT presented in \citep{een2003}, is a simple SAT solver implementation written in C, and designed for speed and extensibility.
It uses the DPLL based conflict driven algorithm as discussed in section \ref{impl.DPLL}.
This solver has become popular and is the basis of many other SAT solvers due to its open source distribution.
This has also lead to a track in the 2011 SAT competitions\footnote{http://www.satcompetition.org/2011/ accessed 6/3/2012} that deals with only altering MiniSAT to increase performance.
This means that MiniSAT has been repeatedly validated for performance by third parties across many different SAT problems. 

SAT4J \citep{le2010sat4j} is a Java re-implementation, and extension, of MiniSAT in the Java programming language.
The extensions SAT4J makes to MniSAT include the ability to find resolve pseudo-Boolean constraints.
SAT4J was developed in order to quickly test combinations of advancements in SAT solving technology.
This goal has created an easily modifiable and transparent implementation, able to be adapted to be used in various domains.
SAT4J in this right has been a success.

\subsection{Verification of GJSolver}
\label{impl.verif}
The GJSolver implementation can be easily modified to solve CUDF problems, as a CUDF problem can be seen as a CUDF* problem that has only one evolution step.
Using such a modification, GJSolver could then be entered into the Mancoosi International Solver Competition (MISC) competition.
MISC compares many CUDF solvers, and was created to promote interest in the component system evolution problems.
In MISC GJSolver will be required to correctly parse and resolve hundreds of CUDF problems.
MISC is therefore used as a third-party verification of GJSolver, by the creators of CUDF and MOF.

GJSolver was entered twice into MISC, firstly in a MISC Live event, which is an interim competition held during the year;
secondly at the MISC 2011 event\footnote{The results for MISC 2011 were announced at the Workshop on Logics for Component Configuration\footnote{http://www.pps.jussieu.fr/~treinen/lococo/2011/ accessed 6/3/2012}.}, 
which is the main competition. 

The main difference to GJSolver as described above, and the GJSolver entered into the MISC competition occurs when the evolution problem is unsatisfiable.
In the evolution step definition (\ref{formal.stepdef}) the component system $\alpha_{t_{i-1}}$ is returned if the evolution problem is unsatisfiable.
However, in this case, MISC requires that a file with only the text \texttt{FAIL} is written to state that no solution was found.
This is to correctly score a solver returning an incorrect solution to an evolution problem, 
and a solver finding a problem unsatisfiable.

\subsubsection{Mancoosi International Solver Competition}
\label{impl.MISCDEF}
Given a goal of the GJSolver implementation is to compete in the MISC, the interface and standards defined for this competition must be followed.
How the entered solvers are executed, what environment they are executed in, and the output required are all important aspects.

%%%They are executed on the command line
The way in which the entered solvers are executed is standardised to allow the automation of the competition.
This standard requires the entered solvers to be able to be executed on the command line with three arguments, \verb+cudfin+, \verb+cudfout+ and \verb+criteria+.
These arguments are defined as:
\begin{itemize}
  \item \verb+cudfin+: is a relative path to a CUDF document (as specified in section \ref{formal.cudf}) that describes the problem to be solver.
  \item \verb+cudfout+: is a relative path to a non-existent file, which is created by the solver to output the solution.
  \item \verb+criteria+: is a Mancoosi optimisation format (as described in section \ref{formal.mancoosioptimisationformat}) description of the criteria to select an optimal solution. 
\end{itemize}
The format of the output file, located at the path defined with \verb+cudfout+ argument, is a list of packages serialised as a list of stanzas with package and version properties.

%%%The environment POSIX, with 5minutes 1GB of memory
The environment in which the solver is executed is a virtual machine running a GNU/Linux system in a x86 architecture with 1GB of RAM.
It contains a Java runtime environment, allowing the use of Java as a primary language.
The time in which the solver is allowed to run is five minutes, after this time the solver will be forcibly executed.
This time limit ensures that the competition can be run in an acceptable time frame.

\subsubsection{Tracks and Scoring}
Each MISC competition is broken down into three possible tracks, where each track is defined by the criteria used.
The first basic track, is 'paranoid', the second more advanced track is 'trendy', and third track is 'user'.
Both 'paranoid' and 'trendy' have pre-defined criteria defined in MOF.
The 'user' track uses a set of pre-defined criteria, though the exact optimisation criteria is unknown before the competition.
This means that 'paranoid' and 'trendy' can have solvers tailored to their specific criteria, where the 'user' track cannot.
The exact criteria that is used for these tracks can be found on the MISC website\footnote{http://www.mancoosi.org/misc-2011/criteria/ accessed 12/5/2012}.

For each track, a set of solvers is entered.
Each track has a set of evolution problems defined in CUDF.
The solvers for each track are then called to return optimal solutions for all problems given the tracks criteria.
As MISC competitions were created to compare various solvers, a scoring system was developed. 

When a solver is given a CUDF problem and some criteria, the returned solution falls into one of three classes:
\begin{itemize}
  \item a \textbf{real solution} is any solution to the CUDF problem.
  \item \textbf{no solution} occurs when a solver finished without returning a solution. This can happen because of error, timeout, or there not being a satisfiable solution.
  \item an \textbf{incorrect solution} occurs when the solver returns an answer that is not a solution to the CUDF problem.
\end{itemize}

Given $m$ is the number of solvers that entered into the track, the scoring of a solvers solution to an individual CUDF problem is as follows:
\begin{itemize}
  \item a \textbf{real solution} is given $1$ point, with an additional $1$ point for every solver that found a better solution.
  \item for \textbf{no solution} $2\times m$ points are given
  \item for an \textbf{incorrect solution} $3 \times m$ points are given.
\end{itemize}
This means, if a solver returns an optimal solution to a CUDF problem, it will receive $1$ point.
However, if other better solutions are returned, then the solver could be given up to $m$ points.

For each track, all solvers in that track are assigned points based on their solutions to all problems in that track.
For a given track a solvers points are summed to give a final score.
If more than one solver has the same amount of points at the end of a track, then the time it took for them to find each solution is summed.
This total time value is used as the tie breaker.

\subsubsection{MISC Live}
%%%In the first competition we had only partially implemented much of the functionality, so we did not expect great results.
The MISC Live was entered when GJSolver was only partially implemented.
Therefore, the only track that was possible to enter was the 'paranoid' track.
The results for this track\footnote{http://mancoosi.org/misc-live/20101126/paranoid/ accessed 6/3/2012} where promising, though some improvements were necessary.
Due to the competition openly distributing all problems in each track, all the solutions of all solvers for all tracks, 
and the output from each solver;
GJSolver's deficiencies were easily identified and corrected.

\subsubsection{MISC}
The main verification of GJSolver was through the MISC 2011 event.
In this event GJSolver was entered into all tracks of this event.
The 'paranoid' track had a total of 5 solvers, the 'trendy' track had a total of 6 solvers, 
and the 'user' track had a total of 4 solvers.
Each track was also entered by the solver which GJSolver is based on, Eclipse P2, and another efficient solver aspuncud.
These two solvers will form the basis of GJSolver's comparison.

The scores and the times for each of the track compared to that from Eclipse P2 and aspuncud are in table \ref{impl.misc2011}.
\begin{table}
\begin{tabular}{| l | c | c | c | c |}\hline
Track & \# of Problems & GJSolver & P2 & aspuncud\\ \hline
paranoid & 129 & (190 : 5,294) & (181 : 4,646) & (147 : 1,035) \\ \hline
trendy & 129 & (197 : 13,073) & (232 : 13,435) & (151 : 1,767) \\ \hline
user & 400 & (656 : 73,522) & (1392 : 87,956) & (1215 : 39,905) \\ \hline
\end{tabular}
\caption{Results from MISC 2011, results are (score:time in seconds)}
\label{impl.misc2011}
\end{table}

The winner for both 'paranoid' and 'trendy' tracks was the aspuncud solver.
The winner for the 'user' track was GJSolver.

\subsubsection{Analysis}
The results from the MISC competition show:
\begin{itemize}
  \item During the competition GJSolver had very consistent results.
These results allowed it to compete with the other solvers, and even win the 'user' track.
 \item No CUDF problem in the competition was incorrectly solved by GJSolver. 
 This could be argued to show that the parsing of CUDF to \modelname, mapping to \modelimpl problems, and the implementations of the algorithms are correct.
 \item When compared to the similar implementation of Eclipse P2, GJSolver produces similar results, in a similar time. 
 As GJSolver was based on Eclipse P2, this is seen as a validation that the differences between the two are not detrimental, and possibly improvements. 
\end{itemize}

Given these reasons GJSolver is seen as a verified implementation.

\section{Summary}
This chapter described the \modelimpl problem and how it mapped to the evolution steps from a \modelname instance.
The algorithms used to solve a \modelimpl problem where also discussed.
The implementation GJSolver was also presented.
GJSolver takes a CUDF* document, parses it to a \modelname instance, and resolves it by mapping it to \modelimpl problems and solving them.
GJSolver was verified through the MISC competition, and was shown to perform well when compared against other solvers.

The following chapter discusses the user, and their strategies for evolving component systems.
It also describes various criteria, and their mappings between MOF, \modelname, and PB criteria in \modelimpl.
