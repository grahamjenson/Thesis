\chapter{Implementation}
\label{implementation}
\epigraph{What I cannot create, I do not understand.}
{\textit{Richard Feynman, 1988}}

%%%CDR Has been shown to be NP-Complete to find a solution and NP-Hard to find an optimial one.
As presented in the previous chapter, the problem of evolving a component system was shown to be NP-Complete, and the problem of finding an optimal evolution was shown to be NP-Hard.
Therefore, to automate this complex evolution process it will require an efficient algorithm and implementation to not only find satisfiable solutions, but also optimal ones. 

%%%The efficiency of the implementation is important as the problem can combinatorially grow into a hard problem 
The efficiency of the implementations is necessary for many instances of CDR.
The goal of many component models is to have large amounts of components with support creating multiple versions of each component.
This directly makes the complexity of evolution grow in a combinatorial manner, making any ad-hoc or simplistic CDR implementation quickly overwhelmed.
The CDR algorithm should then be implemented to allow 

%%%Formally it resembles the SAT problem, which already has efficient implementations, and has been used to solve this problem
The formal representation of this problem was presented as a set of constraints that must all be satisfied in order for a component relationships and the user request to be fulfilled.
This structure closely resembles the Boolean Satisfiability Problem (SAT), which has fast, robust solver implementations that can be used.
This has been noticed by other researchers \citep{leberre2008,Mancinelli2006} 
and the use of SAT solvers to implement CDR in both academia \citep{abate2011} and industry \citep{leBerre2010} has become common.

%%%Finding the optimial solutions requires extensions to SAT solvers
The finding of an optimal solution though is difficult when using a ``pure'' SAT solver, as it cannot easily represent constraints relating to criteria. 
However, through extending the SAT solver implementations to also handle other types of constraints, such as pseudo Boolean constraints, optimisation becomes significantly easier.

In this chapter the algorithms and implementation of CDR using SAT solvers extended with pseudo Boolean constraints, are discussed.
First the Davis-Putnam-Logemann-Loveland algorithm and its extensions, which are the basis for many current SAT solvers, are described.
This will give a basic understanding of the internal workings of current SAT solvers and why they provide a stable backbone for a CDR implementation.
The specific implementation of Eclipse P2 and P2CUDF by \cite{leBerre2010} is then described,
this is given as a comparison of a current technology used by CDR implementations.
Then the description of this researches CDR implementation GJSolver, is given.
This also describes the process in which it was validated and compared against other solvers in the MISC 2011 competition.







%%%Through a slight modification of these solvers to allow constraints with inequalities and cardinalities, Psuedo Boolean constraints,
%%%we can include optimisation for the required criteria using Pseudo Boolean Optimisation (PBO)

%%%There are other methods to find a solution, some of them faster, but SAT was chosen because of its simplicity and clear mapping to the core problem.

%%%We look at P2CUDF, an implementation by LeBerre and Rapicult using SAT with PBO to solve CUDF problems. 

%%%Finally, using this knowledge SAT solvers with PBO, and the format CUDF we were able to implement our own solver inspired by P2CUDF.
%%%We discuss its implementation, its differences from P2CUDF, and its validation in the MISC competition (August TODO)

%%%Here we discuss our method of implementation we used to solve CDR

%%%The back end model for this solver though was OSGi specific, we decided to replace the back model with a more CUDF specific one.

%%%Our model, expressed as a UML class diagram

%%%We have altered the parser to fit our model

%%%We have changed the mapping of their model to SAT, to our model to SAT

%%%We also refactored SAT4J, to SlimSAT, this is identicle to SAT4J, except we removed significant portions of unused code, retained for competitions 
%%%(i.e. MaxSat instances, and unused constraint implementations)


\section{CDR implementaion with Boolean Satisfiability (SAT) Solvers}
\label{impl.SAT}

%%%The definition of SAT has been around for a while, it was the first problem to be given the complexity NP-Complete

%%%SAT solvers have been investigated and found as a common good solution to CDR (EDOS PAPER)
Dependency Resolution is a NP-Complete problem, and NP-Hard given criteria to find an optimal solution.
This problem has been found in many areas, and there have been efforts to standardise the solution in an extensible way.
The EDOS project did a review of using SAT solvers, modified for optimisation, to solve dependecy resolution, and suggested that they were a satisfactory solution.
Today, most solvers use a SAT solver as they represent a quick extendible way to implement this functionality.

%%%SAT solvers are used to solve many problems, scheduling, model validity\ldots

%%%SAT solvers are very good at solving these kinds of problems because they are tested for performance against each other, to find what works empirically   

%%%We will breifly discuss their implementation and the algorithms associated, as it is the mechanism which we use to solve CDR problems

\subsection{Davis-Putnam-Logemann-Loveland algorithm for SAT Solvers}
%%%A successful algorithm for solving SAT problems is the DPLL algorithm, here we describe it in overview

%%%Some improvements over the core algorithm have been appended over the years since DPLL was first proposed.

\subsection{CHAFF Watched Literals}
%%%Through having clauses watch the literals, rather than the other way around, the most expencive step, the propogation, can be reduced significantly.
%TODO cite

\subsection{Conflict Learning}
%%%Simple resolution as proposed by Stallman was an effecient means to stop thrashing(looking at the same subtree repeatedly)

%%%Improvement of this resolution can be made by finding smaller constraints, this can be accomplished by eliminating literals in a constraint

%%%Further improvement can be made by searching for the smallest constraint through such variable elimination

\subsection{Literal Order}
%%%The order in which the literals are assumed in the DPLL algorithm, is heuristically accomplished

%%%The selection of a literal can be broken into two stages for modularity;
%%%first selecting a variable that is very volatile,
%%%second selecting a phase (negative or positive)

\subsection{Pseudo-Boolean Optimisation of SAT Solvers}
%%%Optimisation of SAT solvers is typically done through extending their possible constraints to include Psuedo Boolean inequalities

%%%Then through repeatdly finding a solution then adding a constraint to ensure the next solution is at least as good, the best solution is found

%%%Further optimisation can be made through quickly finding a satisfactory solution, this reduces the space in which to find a better solution

\subsection{Other Methods}
This \cite{Stuckenholz2007} study looks at using boolean optimisation with branch and bound as a solution, as does \cite{Jenson2010a}.


\subsubsection{Integer Programming}
%%%Discussion of this method as the best MISC solver uses this, it has a very complex implementation
\subsubsection{SMT Solvers}
%%%SMT Solver, a slightly higher logic than SAT uses; it has to broad a definition when SAT suffices
\subsubsection{Constraint Solver}
%%%We could just use Prolog, like SMT I think it is too broad when there are good SAT solvers





\subsection{Product and Lexicographic orders in Pseudo-Boolean Optimisation}
%%%Here we descirbe the mapping from our Optimisation framework to PBO, product order is easy, lexicographic requires some muddling

\subsection{Drawbacks of this Optimisation approach}
%%%There are a few drawbacks to this mapping;
%%%These simplifications are mostly necessary for this problem as it keeps the problem manageable,
%%%and including all aspects of our formal optimisation framework would be practically impossible

%%%The optimisation must be represented linearly
As noted in \cite{le_berre_dependency_2009} and \cite{leBerre2010} there is no easy solution to extending a SAT solver to handle non-linear constraints.

%%%Real numbers must be truncated to fit the integer representation. 

%%%Only one solutin can be chosen so product orders are randomly selected to a degree, this can be mitigated by having no stochastic elements in the algorithm

%%%No criterion can be of a partial order though through product composition the problem can be a partial order

%%%The only aggregation of numbers between integers is addition.

%%%It is too expencive to recalculate cardinalities for each component given a specific solution, therefore the cardinalities of a component should be solution independant

\section{GJSolver}
%%%My Implementation, cut the fat, straight forward

\subsection{Verification}
%%%We entered this solver into two Mancoosi MISC competitions

%%%In the first competition we had only partially implemented much of the functionality, so we did not expect great results.

%%%In some instances we where returing non optimal solutions, The bug where we had to add all package versions of all components. 

%%%These problems where fixed, through comparing the results we had gotten from the competition with those from other solvers.
%%%We created our own miny competition which we ran to also ensure that time limits where adhered to.

%%%In the second competition we had fully implemented the solver and this allowed us to enter all tracks with EXCELLENT results

%%%The paranoid track

%%%The trendy track

%%%The user track




