\chapter{Implementation}
\label{implementation}
%%%The implementation of CDR is also a very important aspect of the problem, as the queries can be very large and complex to solve given its NP-Hard nature.

%%%The implementation to these solvers is sometimes ad-hoc, this can be bad as the problem is similar across different domains, 
%%%ad-hoc solution decrease the possibility to share knowledge and solutions, or extend your system

%%%An efficient mechanism to find optimal solutions that is gaining popularity is through using a Boolean Satisfiability Solver (SAT)

%%%We have already reduced the problem to a SAT problem in the previous chapter to show the problem is NP-Complete

%%%Through a slight modification of these solvers to allow constraints with inequalities and cardinalities, Psuedo Boolean constraints,
%%%we can include optimisation for the required criteria using Pseudo Boolean Optimisation (PBO)

%%%There are other methods to find a solution, some of them faster, but SAT was chosen because of its simplicity and clear mapping to the core problem.

%%%We discuss the format specified by the Mancoosi project, Common Upgradeability Description Format (CUDF),
%%%which gives us a unified syntax and semantics to map many real world problems, like Debian and OSGi, to our formal definition.

%%%We look at P2CUDF, an implementation by LeBerre and Rapicult using SAT with PBO to solve CUDF problems. 

%%%Finally, using this knowledge SAT solvers with PBO, and the format CUDF we were able to implement our own solver inspired by P2CUDF.
%%%We discuss its implementation, its differences from P2CUDF, and its validation in the MISC competition (August TODO)

%%%Here we discuss our method of implementation we used to solve CDR

%%%The back end model for this solver though was OSGi specific, we decided to replace the back model with a more CUDF specific one.

%%%Our model, expressed as a UML class diagram

%%%We have altered the parser to fit our model

%%%We have changed the mapping of their model to SAT, to our model to SAT

%%%We also refactored SAT4J, to SlimSAT, this is identicle to SAT4J, except we removed significant portions of unused code, retained for competitions 
%%%(i.e. MaxSat instances, and unused constraint implementations)


\subsection{Debian Model to CUDF mapping}
%%%The modelling of Debain packages to CUDF is very similar 
The mapping of the Debian dpkg component meta-data to CUDF is mostly a direct process as the meta data is very similar. 
However, there are a few instances where the Debian semantic causes complication with the CUDF format, and in this section we describe these in detail.
The first of these complications occuurs with versioning, as in Debian the version model is different to the CUDF model.
The second instance is because of the special relationships that virtual packages have in the Debian model, 
these must be intergrated into the CUDF mapping. 
Lastly the priority ranking, recommends, suggests and other extra information that is not standard in the CUDF format,
but with CUDF's extencibility can be represented and used in the resolution process.
The one difference we have from the Debian semantic is the ability to have multiple versions of the same package installed, this is impossible in debian, but we see it as a simplification of the problem.

%%%How versions are handeled in this mapping, ordering all versions in a list and giving them the version of their index
The versions in Debian follow a model that first describes the epoch,
the upstream version, then the Debian revision (further described in the Debian policy manual). %TODO cite debian package manager
When comparing two versions these values are compared lexicographically such that
if the epoch is equal then the upstream versions are compared, 
and if these are equal then the Debian revision is compared.
As the CUDF version model is merely a single integer number, 
the Debian versions are not easily mapped.
To map these versions we order all Debian versions that are referenced in a repository into a single list, 
such that the least version has the index 0, and the last element in the list is the greatest version.
The index of the a Debian version in this list is then used as the CUDF version.

%%%Virtual Packages must be handeled, there are some specific debian semantics that are particularly important
A virtual package in

%%%Priority ranking also must be handeled, as some packages are absolutly required to be in a system, these can be maked similarly in CUDF

%%%We allow multiple versions of the same package to be installed, this is different from the debian 

\subsection{OSGi Component Model to CUDF Mapping}

%%%How versions are handeled, similar to the Debian model



\subsection{Product and Lexicographic orders in Pseudo-Boolean Optimisation}
%%%Here we descirbe the mapping from our Optimisation framework to PBO, product order is easy, lexicographic requires some muddling

\subsection{Drawbacks of this Optimisation approach}
%%%There are a few drawbacks to this mapping;
%%%These simplifications are mostly necessary for this problem as it keeps the problem manageable,
%%%and including all aspects of our formal optimisation framework would be practically impossible

%%%Real numbers must be truncated to fit the integer representation. 

%%%Only one solutin can be chosen so product orders are randomly selected to a degree, this can be mitigated by having no stochastic elements in the algorithm

%%%No criterion can be of a partial order though through product composition the problem can be a partial order

%%%The only aggregation of numbers between integers is addition.

%%%It is too expencive to recalculate cardinalities for each component given a specific solution, therefore the cardinalities of a component should be solution independant



\section{Validation}
%%%We entered this solver into a Mancoosi MISC competition, speed doesn't matter for these results, but the returned and quality of the solutions does.
%%%MISC competitions delibratly create very difficult problems, so I doubt we will get the best solutions in most, and may fail a few. 
%%%What I expect are consistent results that are comparable to other solvers.