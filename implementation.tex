\chapter{Implementation}
\label{implementation}
%%%In this chapter we discuss our specific implementation of CDR, which is based on the P2CUDF implementation of a CUDF solver 

\section{Implementation with Boolean Satisfiability (SAT) Solvers}
%%%The implementation to these solvers is sometimes ad-hoc, though in recent times they have been moving to a more standard solution, the SAT solver.
Dependency Resolution is a NP-Complete problem, and NP-Hard given criteria to find an optimal solution.
This problem has been found in many areas, and there have been efforts to standardise the solution in an extensible way.
The EDOS project did a review of using SAT solvers, modified for optimisation, to solve dependcy resolution, and suggested that they were a satisfactory solution.
Today, most solvers use a SAT solver as they represent a quick extendible way to implement this functionality.

%%%In this chapeter we describe an effecient and popular solution to the CDR problem, the SAT solver (EDOS PAPER)

%%%First we define the SAT problem with respect to the formal definition, this is straight forward.

%%%Then discuss its Complexity (NP complete to find a solution, NP-Hard to find an optimal solution)

\subsection{Davis-Putnam-Logemann-Loveland algorithm for SAT Solvers}
%%%A successful algorithm for solving SAT problems is the DPLL algorithm, here we describe it in overview

%%%Some improvements over the core algorithm have been appended over the years since DPLL was first proposed.

\subsection{CHAFF Watched Literals}
%%%Through having clauses watch the literals, rather than the other way around, the most expencive step, the propogation, can be reduced significantly.
%TODO cite

\subsection{Conflict Learning}
%%%Simple resolution as proposed by Stallman was an effecient means to stop thrashing(looking at the same subtree repeatedly) constraints

%%%Improvement of this resolution can be made by finding smaller constraints, this can be accomplished by eliminating literals in a constraint

%%%Further improvement can be made by searching for the smallest constraint through such variable elimination

\subsection{Literal Order}
%%%The order in which the literals are assumed in the DPLL algorithm, is heuristically accomplished


\subsection{Optimisation with SAT solvers}
%%%Optimisation of SAT solvers it typically done through extending their possible constraints to include Psuedo Boolean inequalities

%%%Then through repeatdly finding a solution then adding a constraint to ensure the next solution is at least as good, the best solution is found

%%%Further optimisation can be made through quickly finding a satisfactory solution, this reduces the space in which to find a better solution



\section{Debian Model to CUDF mapping}
%%%The modelling of Debain packages to CUDF is very similar 
The mapping of the Debian dpkg component meta-data to CUDF is mostly a direct process as the meta data is very similar. 
However, there are a few instances where the Debian semantic causes complication with the CUDF format, and in this section we describe these in detail.
The first of these complications occuurs with versioning, as in Debian the version model is different to the CUDF model.
The second instance is because of the special relationships that virtual packages have in the Debian model, 
these must be intergrated into the CUDF mapping. 
Lastly the priority ranking, recommends, suggests and other extra information that is not standard in the CUDF format,
but with CUDF's extencibility can be represented and used in the resolution process.
The one difference we have from the Debian semantic is the ability to have multiple versions of the same package installed, this is impossible in debian, but we see it as a simplification of the problem.

%%%How versions are handeled in this mapping, ordering all versions in a list and giving them the version of their index
The versions in Debian follow a model that first describes the epoch,
the upstream version, then the Debian revision (further described in the Debian policy manual). %TODO cite debian package manager
When comparing two versions these values are compared lexicographically such that
if the epoch is equal then the upstream versions are compared, 
and if these are equal then the Debian revision is compared.
As the CUDF version model is merely a single integer number, 
the Debian versions are not easily mapped.
To map these versions we order all Debian versions that are referenced in a repository into a single list, 
such that the least version has the index 0, and the last element in the list is the greatest version.
The index of the a Debian version in this list is then used as the CUDF version.

%%%Virtual Packages must be handeled, there are some specific debian semantics that are particularly important
A virtual package in

%%%Priority ranking also must be handeled, as some packages are absolutly required to be in a system, these can be maked similarly in CUDF

%%%We allow multiple versions of the same package to be installed, this is different from the debian 

\section{OSGi Component Model to CUDF Mapping}

%%%How versions are handeled, similar to the Debian model

\section{P2CUDF based implementation}
%%%Our implementation is based off of Daniel Le Berre and Rapicult P2CUDF, which uses SAT4J a SAT and PB solver, tested and validated in competitions.
The Mancoosi organisation who have created the CUDF standard have also organised competitions for the solvers.
One implementation of note is the P2CUDF implementation, that uses SAT

\subsection{Changes}
%%%The back end model for this solver though was OSGi specific, and as most of our problems are Debian, we decided to replace the back model.

%%%Our model, expressed as a UML class diagram

%%%We have altered the parser to our model

%%%We have changed the mapping of their model to SAT, to our model to SAT

%%%We also refactored SAT4J, to SlimSAT, this is identicle to SAT4J, except we removed significant portions of unused code, retained for competitions 
%%%(i.e. MaxSat instances, and unused constraint implementation)

\subsection{Validation}
%%%We entered this solver into a Mancoosi MiSC competition, it was tested against other solvers and altough errors were found generally found equivilent results (just a bit slower).


