\chapter{Implementation}
\label{implementation}
%%%This should be about the lower level implementation of CDR to evolve a system

The problem of finding the necessary changes to the system is NP-Complete, and as there can be many different possible solutions, optimising this problem is NP-Hard.
Therefore, the implementation of CDR requires to be robust and fast.
Recently, the use of Boolean satisfaction (SAT) solvers extended to handle pseudo Boolean constraints for optimisation, has become popular.
This method takes a set of constraints that describe the problem and using a set of powerful tools quickly finds solutions to that satisfy all constraints.



%%%The implementation of CDR is also a very important aspect of the problem, as the queries can be very large and complex to solve given its NP-Hard nature.

%%%The implementation to these solvers is sometimes ad-hoc, this can be bad as the problem is similar across different domains, 
%%%ad-hoc solution decrease the possibility to share knowledge and solutions, or extend your system

%%%An efficient mechanism to find optimal solutions that is gaining popularity is through using a Boolean Satisfiability Solver (SAT)

%%%We have already reduced the problem to a SAT problem in the previous chapter to show the problem is NP-Complete

%%%Through a slight modification of these solvers to allow constraints with inequalities and cardinalities, Psuedo Boolean constraints,
%%%we can include optimisation for the required criteria using Pseudo Boolean Optimisation (PBO)

%%%There are other methods to find a solution, some of them faster, but SAT was chosen because of its simplicity and clear mapping to the core problem.

%%%We discuss the format specified by the Mancoosi project, Common Upgradeability Description Format (CUDF),
%%%which gives us a unified syntax and semantics to map many real world problems, like Debian and OSGi, to our formal definition.

%%%We look at P2CUDF, an implementation by LeBerre and Rapicult using SAT with PBO to solve CUDF problems. 

%%%Finally, using this knowledge SAT solvers with PBO, and the format CUDF we were able to implement our own solver inspired by P2CUDF.
%%%We discuss its implementation, its differences from P2CUDF, and its validation in the MISC competition (August TODO)

%%%Here we discuss our method of implementation we used to solve CDR

%%%The back end model for this solver though was OSGi specific, we decided to replace the back model with a more CUDF specific one.

%%%Our model, expressed as a UML class diagram

%%%We have altered the parser to fit our model

%%%We have changed the mapping of their model to SAT, to our model to SAT

%%%We also refactored SAT4J, to SlimSAT, this is identicle to SAT4J, except we removed significant portions of unused code, retained for competitions 
%%%(i.e. MaxSat instances, and unused constraint implementations)


\section{CDR implementaion with Boolean Satisfiability (SAT) Solvers}
\label{impl.SAT}

%%%The definition of SAT has been around for a while, it was the first problem to be given the complexity NP-Complete

%%%SAT solvers have been investigated and found as a common good solution to CDR (EDOS PAPER)
Dependency Resolution is a NP-Complete problem, and NP-Hard given criteria to find an optimal solution.
This problem has been found in many areas, and there have been efforts to standardise the solution in an extensible way.
The EDOS project did a review of using SAT solvers, modified for optimisation, to solve dependecy resolution, and suggested that they were a satisfactory solution.
Today, most solvers use a SAT solver as they represent a quick extendible way to implement this functionality.

%%%SAT solvers are used to solve many problems, scheduling, model validity\ldots

%%%SAT solvers are very good at solving these kinds of problems because they are tested for performance against each other, to find what works empirically   

%%%We will breifly discuss their implementation and the algorithms associated, as it is the mechanism which we use to solve CDR problems

\subsection{Davis-Putnam-Logemann-Loveland algorithm for SAT Solvers}
%%%A successful algorithm for solving SAT problems is the DPLL algorithm, here we describe it in overview

%%%Some improvements over the core algorithm have been appended over the years since DPLL was first proposed.

\subsection{CHAFF Watched Literals}
%%%Through having clauses watch the literals, rather than the other way around, the most expencive step, the propogation, can be reduced significantly.
%TODO cite

\subsection{Conflict Learning}
%%%Simple resolution as proposed by Stallman was an effecient means to stop thrashing(looking at the same subtree repeatedly)

%%%Improvement of this resolution can be made by finding smaller constraints, this can be accomplished by eliminating literals in a constraint

%%%Further improvement can be made by searching for the smallest constraint through such variable elimination

\subsection{Literal Order}
%%%The order in which the literals are assumed in the DPLL algorithm, is heuristically accomplished

%%%The selection of a literal can be broken into two stages for modularity;
%%%first selecting a variable that is very volatile,
%%%second selecting a phase (negative or positive)

\subsection{Pseudo-Boolean Optimisation of SAT Solvers}
%%%Optimisation of SAT solvers is typically done through extending their possible constraints to include Psuedo Boolean inequalities

%%%Then through repeatdly finding a solution then adding a constraint to ensure the next solution is at least as good, the best solution is found

%%%Further optimisation can be made through quickly finding a satisfactory solution, this reduces the space in which to find a better solution

\subsection{Other Methods}
This \cite{Stuckenholz2007} study looks at using boolean optimisation with branch and bound as a solution.


\subsubsection{Integer Programming}
%%%Discussion of this method as the best MISC solver uses this, it has a very complex implementation
\subsubsection{SMT Solvers}
%%%SMT Solver, a slightly higher logic than SAT uses; it has to broad a definition when SAT suffices
\subsubsection{Constraint Solver}
%%%We could just use Prolog, like SMT I think it is too broad when there are good SAT solvers


\section{Debian Model to CUDF mapping}
\label{DebToCUDF}
%%%The modelling of Debain packages to CUDF is very similar 
The mapping of the Debian dpkg component meta-data to CUDF is mostly a direct process as the meta data is very similar. 
However, there are a few instances where the Debian semantic causes complication with the CUDF format, and in this section we describe these in detail.
The first of these complications occuurs with versioning, as in Debian the version model is different to the CUDF model.
The second instance is because of the special relationships that virtual packages have in the Debian model, 
these must be intergrated into the CUDF mapping. 
Lastly the priority ranking, recommends, suggests and other extra information that is not standard in the CUDF format,
but with CUDF's extencibility can be represented and used in the resolution process.
The one difference we have from the Debian semantic is the ability to have multiple versions of the same package installed, this is impossible in debian, but we see it as a simplification of the problem.

%%%How versions are handeled in this mapping, ordering all versions in a list and giving them the version of their index
The versions in Debian follow a model that first describes the epoch,
the upstream version, then the Debian revision (further described in the Debian policy manual). %TODO cite debian package manager
When comparing two versions these values are compared lexicographically such that
if the epoch is equal then the upstream versions are compared, 
and if these are equal then the Debian revision is compared.
As the CUDF version model is merely a single integer number, 
the Debian versions are not easily mapped.
To map these versions we order all Debian versions that are referenced in a repository into a single list, 
such that the least version has the index 0, and the last element in the list is the greatest version.
The index of the a Debian version in this list is then used as the CUDF version.

%%%Virtual Packages must be handeled, there are some specific debian semantics that are particularly important
A virtual package in

%%%Priority ranking also must be handeled, as some packages are absolutly required to be in a system, these can be maked similarly in CUDF

%%%We allow multiple versions of the same package to be installed, this is different from the debian 

\subsection{OSGi Component Model to CUDF Mapping}

%%%How versions are handeled, similar to the Debian model



\subsection{Product and Lexicographic orders in Pseudo-Boolean Optimisation}
%%%Here we descirbe the mapping from our Optimisation framework to PBO, product order is easy, lexicographic requires some muddling

\subsection{Drawbacks of this Optimisation approach}
%%%There are a few drawbacks to this mapping;
%%%These simplifications are mostly necessary for this problem as it keeps the problem manageable,
%%%and including all aspects of our formal optimisation framework would be practically impossible

%%%Real numbers must be truncated to fit the integer representation. 

%%%Only one solutin can be chosen so product orders are randomly selected to a degree, this can be mitigated by having no stochastic elements in the algorithm

%%%No criterion can be of a partial order though through product composition the problem can be a partial order

%%%The only aggregation of numbers between integers is addition.

%%%It is too expencive to recalculate cardinalities for each component given a specific solution, therefore the cardinalities of a component should be solution independant



\section{Verification}
%%%We entered this solver into two Mancoosi MISC competitions

%%%In the first competition we had only partially implemented much of the functionality, so we did not expect great results.

%%%In some instances we where returing non optimal solutions, The bug where we had to add all package versions of all components. 

%%%These problems where fixed, through comparing the results we had gotten from the competition with those from other solvers.
%%%We created our own miny competition which we ran to also ensure that time limits where adhered to.

%%%In the second competition we had fully implemented the solver and this allowed us to enter all tracks with EXCELLENT results

%%%The paranoid track

%%%The trendy track

%%%The user track


