\section{Criteria}
The two main criteria considered during component system evolution are to maximise the versions of individual components, 
while minimising the change caused by the evolution to the system. 
These two criteria are conflicting as increasing the version of a component is a change to the system.
They are also not strictly defined, as the version of the components must be aggregated to measure the entire system,
and the amount a system is changed can be measured in different ways.
The way in which the criteria relate to each other is different for different users.
For example, a server administrator will likely change as little as possible rather than risk a fault, 
where a developer/debugger will always wants the newest versions of components to stay up to date.

\subsection{Version vs. Minimal Change}
\quote{Why is having the newest version of a component important?}

A newer version exists because the component has changed to be better in some way.
This may be through a bug being fixed, a security hole being patched, or the functionality being extended.
Having a newer version of a component in the system, may also make all of the other components that depend on it better as well,
causing a propagation of system improvement with the upgrading of one component.

\quote{Why would you not want the newest version then?}

The change to the system that is caused when a newer version is installed may cause harm to your system.
In the same way that a version upgrade can propagate benefits through the system, 
friction or errors can propagate and cause a faulty or not functional system.

\subsection{Definitions}
\quote{How can we measure the version of a system from the versions of installed components?}

To answer this question over a set of components that are probably versioned differently, 
we need to explore functions that can aggregate the versions of different components together in a meaningful way.

Each component must be versioned to conform to a versioning model defined by the component model, 
however the way in which a developer uses this model to version their component is not usually strictly defined.
Each component is designed to be an independent unit, as such developers of components are separate from one another,
and the way in which they version their components can be different.
Therefore, version comparison is only useful between different versions of the same component;
e.g. a spell-checker component can be version 10 but a separate and superior spell-checker component may be only version 1.
This makes using component versions to decide between components impossible.


The Mancoosi organisation uses a metric that minimises the number of components in a system that have better versions, 
e.g. a system $a-1,b-1$ if $a-2$ exists is $1$ out of date. 
The Eclipse P2 implementation counts the amount of versions that are better for each component,
e.g. a system $a-1,b-1$ if $a-2$ and $a-3$ exist, is $2$ out of date.
Both of these take into account only the component and not the components that depend on it.

The measurement of change that a system goes through during evolution is also difficult to define.
The added, removed, updated, total changed, have all been considered as metrics before. 
As with the version metrics, none of these consider the dependencies when looking at the change that is performed on the system.


\subsection{The Gap}
Each time a user decides to evolve a component system, the decision must be made about the risks of the evolution.
In an environment which is mission critical, all risk is eliminated and an unecessary change to the system is too risky.
In a development environment where the user may be trying to fix potential problem, 
or test different packages, then the risk is accepted as the system is essentially disposable, and a complete re-installation is not out of the question.
These two strategies are represented in by the current strategies used, however very little middle ground is avaiable for the customisation of applications.
The user may want 