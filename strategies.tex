\chapter{User's Evolution Strategies}
\label{strategies}
\epigraph{Motion or change, and identity or rest, are the first and second secrets of nature: Motion and Rest. 
The whole code of her laws may be written on the thumbnail, or the signet of a ring.}
{\textit{Ralph Waldo Emerson in "Nature", Essays, Second Series (1844)}}

%%%Yet defined the user
Up till this point in this thesis the user has been left disembodied and abstract.
However, given the aims of this research are to look at not only the process of component system evolution, but also the consequences of different approaches.
As the user is the actor that defines the approach taken to evolve a component system, this user will need to be described and explored.

%%%The user evolves the system, they are important
Lehman laws on software evolution state ``the system must continually grow to maintain user satisfaction''.
In systems that are not component based, this evolution process was done completely by a third party.
What extra functionality is included, what bugs are important and should be fixed, what font the buttons have. 
However, in component systems some of these decisions are given to the user, and therefore are out of the developers control.
For instance, a user of a component system may experience issues with a particular component, 
and may decide to upgrade, or downgrade that component to fix these issues.

%%%What possible decisions can they make? Add, remove, upgrade, and criteria
A developer of a component can change the component at the code level, however the user does not have the ability to be that precise in their actions.
Some of the possible actions a user can take to evolve their system have been described in the previous chapter,
where the user can request a component to be installed, removed or upgraded.
This limited set of actions can provide a great deal of choice when evolving a system, as their can be many components available to act upon.
As any action can be accomplished with various solutions, the user must choose the criteria by which to judge and select a resulting component system.
This criteria will guide the systems evolutions through returning solutions that have attributes the user desires.

%%%What drives the users decisions?
This user of a component system then has the power to change the system they are using.
How do they use this power, what drives the decisions that they make?
A fundamental influence on how the user would select a to evolve their system is the objectives of the system.
These objectives determine the included functionality and as the objectives change the way in which this functionality is altered.  
Another influence on what actions a user takes is the perceived risk of taking an action, or not taking an action.
For example, upgrading a system may introduce new bugs and problems, yet not upgrading may let old vulnerabilities compromise the system.

%%%What are strategies, Plans to employ to evolve a component system
The choices the user makes to evolve the component system is described as the users evolution strategy.
By strategy, it is meant the plan or pattern employed by a user to evolve a system to attain the systems objectives.

%%%In this chapter\ldots
In this chapter, the users that evolve component systems are described, and their choices of criteria defined.
Firstly, a survey that was given to users in order to determine their strategies of how they evolve their component systems is discussed in section \ref{strat.usersurvey}.
This survey was conducted in order to illuminate general user strategies and discuss aspects like interactions while evolving component systems.
The criteria a user judges solutions by are then discussed, the reasons and system objectives they fulfil are described.
Each criteria is mapped to the formal description given in chapter \ref{formal} and the implementation description given in chapter \ref{implementation}.
This chapter is finished with a brief discussion on how criteria can be composed to fulfil different user objectives. 

\section{User Survey}
\label{strat.usersurvey}
%%%The survey used to validate and refine the model
To describe and define the strategies that different users employ to evolve their component systems an online survey was conducted.
This survey targeted users of GNU/Linux distributions, specifically Ubuntu, and also server administrators through the online forum reddit\footnote{http://reddit.com}.
In this context the way in which component systems are evolved is through package managers, as described in chapter \ref{background}.
It was completed by 59 users, who answered questions about them selves, the system they are evolving, and the way in which they evolve it.
It also involved the submission of package manager log files, which enable the processing for real update and install probabilities.
These logs are not analysed here, but are used further in chapter \ref{ubunutsimulation}.

In this section a brief description of the survey and an analysis of what was learnt is given.
The full set of questions in the survey is presented in section \ref{apx.survey}. 

\subsection{Questions}
%%%The goals of the survey:
There are two types of questions in the survey; a set to identify the type of user, and a set to describe their interactions with package managers.

A set of questions used to identify the user are:
\begin{itemize}
  \item How experienced with package managers are you? 
  \item What system are you using?
  \item What package manager are you using?
\end{itemize}
These can be used to categorise the type of user and put into context the answers that they give.
They can also be used to weigh their answers for credibility and potentially exclude results from novice or inexperienced users. 

A set of questions asked about their use of package mangers are:
\begin{itemize}
  \item Describe your initial interaction with the package manager.
  \item Describe your day to day interactions with the package manager.
  \item What usage life cycle do you have with the package manager.
  \item Describe an unusual scenario in which the package manager was used.
\end{itemize}
The main focus of these questions is to identify the life-cycle of interactions that the user has when evolving a system.
This is mainly of interest latter in chapters \ref{simulation} and \ref{ubunutsimulation} when these variables must be defined.
However, it also provides us with reasons for these actions to occur, and illuminates the users objectives and strategies.

The survey finished with the question:
\begin{itemize}
  \item What other questions should I have asked?
\end{itemize}
This question tried to illicit comments and possible information that I could of gathered.
It also provided a small verification of the survey, as to see if anything was missing that should of been asked.

\subsection{Results}
%%%The results are summarised as:
The type of user that submitted the survey is important to be able to put in context their replies.
Most users (29/59) used dpkg component model either in Debian or Ubuntu systems, and the majority of those uses used apt-get as their package manager.
The next largest component model used was ArchLinux\footnote{http://www.archlinux.org/} (13/59) each one using the package manager pacman\footnote{http://www.archlinux.org/pacman/}.
Other represented component models and package mangers include, Fedora with the rpm component model and yum package manger,
Slackware with pkgtools, and Gentoo with portage.

The users mean experience was recorded as 3.9/5.
This is of course a subjective measure but describes the confidence in which the participants answered the questions. 

The life cycle questions have been summarised into the frequency of each action in table \ref {strat.tblaction}.

\begin{table}[htp]
\begin{tabular}{l | c | c | c | c |}
Request & Init. & Daily & Weekly & Monthly \\
Upgrade  & 45 & 27 & 16 & 0 \\
Install & 49 & 6 & 17 & 3 \\
Remove & 6 & 4 & 1 & 0\\
\end{tabular}
\caption{Summary of the frequency of user actions with package managers}
\label{strat.tblaction}
\end{table}

This table shows the amount of users from the survey who perform the actions of upgrading their system, installing or removing a package 
initially, when the system is first created, daily, weekly or monthly.
It shows that the vast majority of users when they create a system upgrade the system and install required packages.
This also shows that most users upgrade their system daily, and if they will likely install a package weekly.

The unusual scenarios which the user described using the package manager included 
11 of the 59 users stating that they had installed a set of packages to fulfil a specific task only to remove them the next day.
This is described by the users response ``I sometimes install lots of packages very quickly as I need to accomplish a task, then remove them once that task has finished.''
Also, 3 of the users stated that use of the package manager broke their system, which then required to be fixed through the package manager.

In the final question asked if there is any more questions the general themes include, 
the mitigation of failed actions, installing multiple versions of packages, and using a graphical user interface v.s. console based package manager.
The majority (37/59) users did not fill out this option in the survey, hopefully showing that the majority expressed all they wished throughout the survey.
One user even remarked ``Quite an all encompassing survey!'' in this field.

\subsection{Progressive vs. Conservative Users}
The main outcome of this survey was the identification of different user attitudes towards evolving a component system.
These attitudes create user stereotypes which here are described as either \textbf{conservative} or \textbf{progressive}.
These terms come from the domain of politics where conservatism is the philosophy that emphasises minimal and gradual change in society,
where progressivism promotes change and reform.
These ideologies are caused because of a conflicting perception of risk; the risk of change introducing new problems, and the risk of not changing having old problems persist.
They then must be resolved, joined together in a way which is acceptable to the parties involved.

These ideologies are analogous to component system evolution where there is a force that wishes to reduce the risk to a system by not altering it,
and one to reduce risk by installing new versions of components.
The majority of users from the survey found some middle ground in which to mitigate both types of risk.

For example, a users response that express a slight conservative attitude:
\begin{quotation}
In production I rarely remove packages (easier to leave software as-is than risk breaking stuff).
\end{quotation}
That is they are more likely not to change the system, just in case it leads to a fault. 

Another example of a users response expressing a slight progressive attitude:
\begin{quotation}
I update my packages whenever I log in each day
\end{quotation}
Updating when they log in each day ensures the system is up to date, 

Both of these ideologies have extremes though, users who try to eliminate all risk of one of the opposing ideology.

For example, a user's response in the survey with an extreme progressive attitude:
\begin{quotation}
I do run an unstable system all the time, I help mitigate this with some redundancy in my most frequently used components, 
using packages which perform the same function, but have different dependencies, since it's less likely to have multiple packages break at the same time. 
If something is rather buggy for me, I tend to update on a more frequent basis to check for the next stable point to jump into.
\end{quotation}
This user has components in their system that are so new as to not be fully tested, these are described as unstable packages.
To lower the risk that such packages have on the function of the system, this user has redundant functionality installed in their system to ensure that it can be used.
This users system will almost certainly be completely up to date, as any new component versions will be immediately integrated into their system.

An example of an extremely conservative user's response when asked about the frequency with which they interact with the package manager:
\begin{quotation}
As little as possible. I like build my box into whatever I'll need in the first couple of weeks after an install. 
Following the configuration and construction, only the occasional upgrade is necessary. 
Unless, of course, I receive a security notice about something.
\end{quotation}
So after the setting up of a system, this user will not evolve the system unless there is a direct security risk.
This non-change will result in the system quickly becoming out of date.

%%%The reasons for keeping a system up-to-date; the fixing of bugs security, the adding of functionality, 
The reasons for these progressive attitudes of users is that maintaining an up-to-date system will eliminate known security exploits against the system,
and also introduce more efficient or new functionality into the system.
%%%The reasons for minimal change; through change unknown bugs could be introduced, the act of changing can create bugs, the effort of changing can consume resources  (e.g. network traffic).
Where the conservative attitudes come from the wither the perceived risk that unknown bugs could be introduced into the system, the act of changing a system can cause faults,
or the consumed resources (e.g. time, network traffic) are to expensive for the benefits.

Both concerns are valid assessments of the risk of component system evolution, the user must decide with respect to the system objectives what they require. 
For example, a server administrator that is running a mission critical system will likely change the system begrudgingly as any fault could cause massive damage.
However, a user running a desktop personal computer system may be more interested in new functionality than the up-time of the computer, so would change more readily.

\section{Criteria}
%%%What do we mean by criteria
Any requested change to a system may be satisfied by many possible solutions.
When a user is confronted with many solutions to choose from, they are forced to judging, then selecting a system that suites their requirements.
The criteria used to judge and select the system therefore will have a great effect on the evolution of a component system.

Selecting the criteria, and composing them in a meaningful way in which the resulting solutions is a difficult challenge.
This is because there is no clear way to version a component system, making the definition of a criterion that maximises versions difficult.
Also as change is a necessary part of the system, minimising to zero is impossible, and a criterion that attempted to do this counter productive.
As any user, progressive or conservative, wants minimal change and/or the latest version, defining criteria to satisfy these requirements is a challenge.

%%%There is no way to version a component system
Given most pieces of software, the higher the version means the more ``up-to-date'' it is.
This ``up-to-dateness'' shows that the software is more recent and incorporates the latest bug fixes and features that have been developed. 
A problem occurs when trying to version a component system, as each component has a different version and they can be combined in many different ways.
For example, given two components each with two versions $a_1,a_2,b_1,b_2$, which of these systems is more up-to-date $\{a_1,b_2\}$ or $\{a_2,b_1\}$.
This measurement of up-to-date is then difficult to define, and thus difficult to create criteria for.

%%%Change is necessary, simply definition are do not accuratly represent the problem
Minimising system changes also creates difficulties when trying to define criteria.
Simply, a component system can have a component added or removed, where to update of a component is the removal of the old version and the addition of a new one.
This does not seem an entirely genuine definition of change as an update is seen as a less risky action than a component removal by users in the survey.  
Therefore, different changes have different risks associated with them, and simply addition and removal criteria are not necessary accurate depictions of this risk.

%%%In this section
%%%Here we specifically define different criteria/heuristics 
%%%All defined formally, and ready for use for the simulation in the next chapter
In this section the definition of different criteria used to select solution is defined and their positive and negative implications are discussed.
Each criteria is defined as a pseudo-Boolean equation that is represented as a set of literals, and a set of coefficients, as described in chapter \ref{implementation}.  
The criteria that are defined are from academia, industry, and other domains.
Finally in this section the discussion of the use of these criteria, how they relate each other and the possible actions the user can take to evolve their component systems.  

%%%TODO Dynamic criteria vs Static criteria, and conservative vs Progressive
\subsection{Hamming}
The first criteria that will be defined is based on the \textbf{hamming} code distance metric \cite{hamming1950error}.
This metric defines the distance between two sets by counting the number of elements that have been added and removed.
This can be calculated by measuring the cardinality of their symmetric difference.

To find the hamming distance between two sets of literals using a psuedo-Boolean equation, all negations of the literals in the initial set can be counted.
$Rank^{max}(l_1,l_2) = f(l_2) = [(1,\neg x) \mid x \in l_1] $ 
The list of literals that make up the pseudo-Boolean equation that define 
the hamming criteria are the negations of all literals in the previous solution, and the list of coefficients is  

This conservative criteria defines change as any addition or removal of a component from the resulting solution.
It is a simply definition, lumping all types of change into the fundamental alteration of the set of components in the resulting system.
As discussed above this is an inaccurate representation of the risks of changing a system, as adding a component is seen as less risky than removing one.

\subsection{Mancoosi Criteria}
%%%Here we define the criteria from Mancoosi

The Mancoosi organisation uses a metric that minimises the number of components in a system that have better versions, 
e.g. a system $a-1,b-1$ if $a-2$ exists is $1$ out of date. 
The Eclipse P2 implementation counts the amount of versions that are better for each component,
e.g. a system $a-1,b-1$ if $a-2$ and $a-3$ exist, is $2$ out of date.
Both of these take into account only the component and not the components that depend on it.
%%%not up to date

%%%removed

%%%new

%%%Reccommends

%%%Trendy which is lex(removed, not up to date, reccommends, new)

The \textbf{Paranoid} distance function, 
defined by the Mancoosi (\textit{MANaging the COmplexity of the Open Source Infrastructure}) project\footnote{http://www.mancoosi.org/}, 
is the lexicographic composition of two distance functions $removed$ and $changed$.
It is defined such that each component has a name $C \rightarrow Name$,
where the function $V: 2^C \times Name \rightarrow 2^C$ returns all components with a name in a set of components 
(these are the different versions of a component).
They are defined such that $removed(C_1,C_2)$ $=$ $|\{name \mid V(C_1,name) $ is nonempty and $V(C_2,name)$ is empty $\}|$,
and $changed(C_1,C_2)$ $=$ $|\{name \mid V(C_1,name)$ is different to $V(C_2,name)\}|$.
The removed function therefore only considers when all components of a name are removed. 

The distance function is then defined $d_P(C_1,C_2)$ to return a pair $(a,b)$ such that $a = removed(C_1,C_2)$ and $b = changed(C_1,C_2)$.
The distance order $\leq_{P}$ is lexicographically defined with respect to $C_R(X)$ as given two models $C_1,C_2$,
$(a,b)$ equals $d_P(C_R(X),C_1)$ and $(a',b')$ equals $d_P(C_R(X),C_2)$ then
$C_1 \leq_{P} C_2 $ iff $a < a' \vee (a = a' \wedge b \leq b')$.
This definition states that removing a component is infinitely worse than adding one, 
therefore we should expect this to generate larger solutions.

\subsection{Lehman}
%%%Lehman has outlined laws of evolution though empirical research, we can adapt these laws to see if they hold true and to what degree in component systems

\subsection{JDepend}
%%%Coupling 

%%%Instability

\subsection{P2}
%%%Looking at the criteria from the P2 solver
Eclipse \textbf{P2} \cite{le_berre_dependency_2009,leBerre2010} is the provisioning system for the Eclipse IDE platform.
Its optimisation function minimises the removed components, while maximising the version of installed components, 
we denote it's distance function as $d_{P2}$.
This function is fully described by Le Berre and Parrin in \cite{leBerre2010}.
The goal of combining these two criteria is to simultaneously update components while altering the system.
This strategy can be seen as a preemptive change, so that a user will not need to later update currently installed components,
therefore minimising future change.
As this is the only minimal criteria that includes the goal to maximise the currently installed version 
we expect more change during evolution.

\subsection{Propagation Based Criteria}
%%%We can create more informative criteria by analyising progation effects.\\
{}A components dependence on another component creates a tangible connection that should be considered when evolving a system.
{}This connection can be seen as a form of trust, given a developer selects the components to have their components depend on,
{}or as a measure of importance to a system, as a component that is highly depended on has more responsibility to the system.
{}This should be considered when making the choice to either remove or add a component to a system.
{}By analysing dependencies between components we can give a weight to a component-based on the structure of its relationships.

%%%Page rank as a metric, calculate page rank value for all 
The structure of component dependencies can be abstracted to a graph, 
and by analysing the importance of nodes in this graph using the \textbf{PageRank} with priors function \cite{White:2003:AER:956750.956782}, 
we attempt to quantify the value of a component in a system.
PageRank with priors estimates the probability of stopping on a node in a random walk over a directed graph given a set of starting nodes.
We see this as an approximation to the probability that a component is depended on in a system.
A directed graph $G = (V,E)$ is generated from the
dependency rules such that $V$ is the set of components, and $(a,b) \in E$ iff there is a dependency constraint in $R$ 
where $a \rightarrow c_1 \vee \ldots \vee c_n$ where $b = c_i$ for some $i$.
The function $PR(a)$ denotes the PageRank of $a$,
so given the set $C_R(X) \cup \{\Delta\}$ is the starting set of nodes, and the generated graph $G$,
the distance function $d_{PR}(C_1,C_2) = \sum_{a \in (C_1 \ominus C_2)} PR(a)$,
i.e. the distance is the sum of the PageRank values in the symmetric difference of the systems.
This distance is the only one to consider the components relationships when calculating the effect of removing or adding them.
Our hope is that by minimising the impact on the structure of the system, 
this will minimise the necessary changes over a long period of time.

%%%HITS, where we can identify hubs and authorities of packages and use this as criteria

%%%Propagation of positive and negative, changin a package that has very little depending on it should be better than changing a large package

\section{Optimisation}
%%%What can be optimised? Here we go over these criteria and discuss given the limitation that PBO imposes on optimisation, how we can optimise.

\section{Other Criteria}
{}There are many other types of criteria that can be considered when judging the optimality of a solution.
{}As we are trying to stay component model agnostic, the only information that can be used comes from the definition of components and component models laid out in Chapter \ref{background}.
{}However, there are other criteria that maybe component model dependent from information in component meta-data (e.g., size, vendor and licence),
{}component contracts and composition testing (e.g., reliability and speed),
{}and community sourced meta-data stored in repositories (e.g., popularity).

%%%Discuss information from component met-data

%%%Discuss information from component testing (e.g. treaty, unit tests)

%%%Discuss community stored information, e.g. app-install-data, reccommendation systems, community forums\ldots

\subsection{Criteria Composition}
The use of these criteria must be 

\section{Summary}

