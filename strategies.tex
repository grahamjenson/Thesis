\chapter{User's Evolution Strategies}
\label{strategies}
\epigraph{Motion or change, and identity or rest, are the first and second secrets of nature: Motion and Rest. 
The whole code of her laws may be written on the thumbnail, or the signet of a ring.}
{\textit{Ralph Waldo Emerson in "Nature", Essays, Second Series (1844)}}
The previous chapters have left the role a user plays in the evolution of their component system unexplored.
This chapter describes the motivations and strategies for users to evolve their component systems.

A strategy is the plan or pattern employed by a user to evolve a system.
A fundamental influence on the user's strategy is their perception of risk.
Each change to the system the user requests, and the criteria used to accomplish this change is effected by the risk of that change.
For example, upgrading a system may introduce new bugs and problems, yet not upgrading may let old vulnerabilities compromise the system.

To explore the users role in CSE a survey was given to users, the results are discussed in section \ref{strat.usersurvey}.
This survey was conducted in order to illuminate general user strategies and discuss aspects like interactions while evolving component systems.
The criteria a user judges solutions by are then discussed, the reasons and system objectives they fulfil are described.
Each criteria is mapped to the pseudo-Boolean function to be either minimised or maximised as discussed in chapter \ref{implementation}.
This chapter is finished with a brief discussion on how criteria can be composed to fulfil different user objectives. 

\section{User Survey}
\label{strat.usersurvey}
%%%The survey used to validate and refine the model
To describe and define the strategies that different users employ to evolve their component systems an online survey was conducted.
This survey targeted users of GNU/Linux distributions (specifically Ubuntu), and server administrators through the online forum reddit\footnote{http://reddit.com accessed 6/3/2012}.
In this context the way in which component systems are evolved is through package managers, as described in chapter \ref{background}.
It was completed by 59 users, who answered questions about themselves, the system they are evolving, and the way in which they evolve it.
It also involved the submission of package manager log files, which through analysis can provide greater detail of their behaviours.
These logs are not analysed here, but are used further discussed in chapter \ref{ubunutsimulation}.

In this section a brief description of the survey and an analysis of responses is given.
The full set of questions in the survey is presented in section \ref{apx.survey}. 

\subsection{Questions}
%%%The goals of the survey:
There are two types of questions in the survey; a set to identify the type of user, and a set to describe their interactions with package managers.

A set of questions used to identify the user are:
\begin{itemize}
  \item How experienced with package managers are you? 
  \item What system are you using?
  \item What package manager are you using?
\end{itemize}
These can be used to categorise the type of user and put into context the answers that they give.
They can also be used to weigh their answers for credibility and potentially exclude results from novice or inexperienced users. 

A set of questions asked about their use of package mangers are:
\begin{itemize}
  \item Describe your initial interaction with the package manager.
  \item Describe your day to day interactions with the package manager.
  \item What usage life cycle do you have with the package manager?
  \item Describe an unusual scenario in which the package manager was used.
\end{itemize}
The main focus of these questions is to identify the life-cycle of interactions that the user has when evolving a system.
The responses will provide reasons for these actions to occur, and illuminates the users objectives and strategies.

The survey finished with the question:
\begin{itemize}
  \item What other questions should I have asked?
\end{itemize}
This question tried to illicit comments and possible information that could of been gathered.
It also provided a small verification of the survey, as to see if anything was missing that should of been asked.

\subsection{Results}
%%%The results are summarised as:
The type of user that submitted the survey is important to be able to put in context their replies.
Most users (29/59) used the dpkg component model, either in Debian or Ubuntu systems.
The majority of these users used apt-get as their package manager.
The next largest component model used was ArchLinux\footnote{http://www.archlinux.org/ accessed 6/3/2012} (13/59),
all using the package manager pacman\footnote{http://www.archlinux.org/pacman/ accessed 6/3/2012}.
Other represented component models and package mangers include, Fedora with the rpm component model and the yum package manger,
Slackware with pkgtools, and Gentoo with portage.

The users mean experience was recorded as 3.9/5.
This is of course a subjective measure but describes the confidence in which the participants answered the questions. 

The life cycle questions have been summarised into the frequency of each action in table \ref{strat.tblaction}.

\begin{table}[htp]
\begin{tabular}{l | c | c | c | c |}
Request & Init. & Daily & Weekly & Monthly \\
Upgrade  & 45 & 27 & 16 & 0 \\
Install & 49 & 6 & 17 & 3 \\
Remove & 6 & 4 & 1 & 0\\
\end{tabular}
\caption{Summary of the frequency of user actions with package managers}
\label{strat.tblaction}
\end{table}

This table shows the amount of users from the survey who perform the actions of upgrading their system, installing or removing a package 
initially (when the system is first created), daily, weekly or monthly.
It shows that the vast majority of users when they create a system upgrade the system and install required packages.
This also shows that most users upgrade their system daily, and if they will likely install a package weekly.

The unusual scenarios which the user described using the package manager included 
11 of the 59 users stating that they had installed a set of packages to fulfil a specific task only to remove them the next day.
This is described by the users response 
\begin{quote}
``I sometimes install lots of packages very quickly as I need to accomplish a task, then remove them once that task has finished.''
\end{quote}

Also, 3 of the users stated that the package manager broke their system at some point, which then required to be fixed through the package manager.

In the final question asked if there is any more questions the general themes of responses include:
\begin{itemize}
  \item the mitigation of failed actions
  \item installing multiple versions of packages
  \item using a graphical user interface v.s. console based package manager
\end{itemize} 
The majority (37/59) users did not fill out this option in the survey, a potential indicator that the survey was complete.
One user even remarked to this question:
\begin{quote}
``Quite an all encompassing survey!''
\end{quote}

\subsection{Progressive vs. Conservative Users}
The main outcome of this survey was the identification of different user attitudes towards evolving a component system.
These attitudes have been used to define user stereotypes, which are described as either \textbf{conservative} or \textbf{progressive}.
These terms come from the domain of politics where conservatism is the philosophy that emphasises minimal and gradual change in society,
where progressivism promotes change and reform.
These ideologies can be caused because of a conflicting perception of risk; the risk of change introducing new problems, and the risk of not changing having old problems persist.

These ideologies are analogous to component system evolution where there is a force that wishes to reduce the risk to a system by not altering it,
and one to reduce risk by installing new versions of components.
The majority of users from the survey found some middle ground in which to mitigate both types of risk.

For example, a users response that express a slight conservative attitude:
\begin{quotation}
In production I rarely remove packages (easier to leave software as-is than risk breaking stuff).
\end{quotation}
That is they are more likely not to change the system, even though it may be beneficial as it may lead to a fault. 

Another example of a users response expressing a slight progressive attitude:
\begin{quotation}
I update my packages whenever I log in each day
\end{quotation}
Upgrading the system each day will ensure that no packages with fixed bugs will be installed, though may require significant change.

Both of these ideologies have extremes though, where users who try to eliminate all of a risk.

For example, a user's response in the survey with an extreme progressive attitude:
\begin{quotation}
I do run an unstable system all the time, I help mitigate this with some redundancy in my most frequently used components, 
using packages which perform the same function, but have different dependencies, since it's less likely to have multiple packages break at the same time. 
If something is rather buggy for me, I tend to update on a more frequent basis to check for the next stable point to jump into.
\end{quotation}
This user has components in their system that are so new as to not be fully tested, which are described as unstable packages.
To lower the risk that such packages have on the function of the system, this user has redundant functionality installed in their system to ensure that it can be used.
This users system will almost certainly be completely up to date, as any new component versions will be immediately integrated into their system.

An example of an extremely conservative user's response when asked about the frequency with which they interact with the package manager:
\begin{quotation}
As little as possible. I like build my box into whatever I'll need in the first couple of weeks after an install. 
Following the configuration and construction, only the occasional upgrade is necessary. 
Unless, of course, I receive a security notice about something.
\end{quotation}
So after the setting up of a system, this user will not evolve the system unless there is a direct security risk.
This lack of change will result in the system quickly becoming out of date.

%%%The reasons for keeping a system up-to-date; the fixing of bugs security, the adding of functionality, 
The reasons for these progressive attitudes of users is that maintaining an up-to-date system will eliminate known security exploits against the system,
and also introduce more efficient or new functionality into the system.
%%%The reasons for minimal change; through change unknown bugs could be introduced, the act of changing can create bugs, the effort of changing can consume resources  (e.g. network traffic).
Where the conservative attitudes come from the wither the perceived risk that unknown bugs could be introduced into the system, the act of changing a system can cause faults,
or the consumed resources (e.g. time, network traffic) are to expensive compared to the benefits.

Both concerns are valid assessments of the risk of component system evolution, the user must decide with respect to the system objectives what they require. 
For example, a server administrator that is running a mission critical system will likely change the system begrudgingly as any fault could cause massive damage.
However, a user running a desktop personal computer system may be more interested in new functionality than the up-time of the computer, so would change more readily.

\section{Criteria}
In previous chapters the exact criteria that can be used has not been defined.
This section describes various criteria that can be used and discusses their applicability to be used in CSE.
Then a selection of these criteria are mapped to MOF criteria names and PB criteria for use in the simulation of CSE. 

\subsection{Change Criteria}
Simple definitions of criteria can often have negative effects during CSE.
Some simple criteria are defined that minimise change and maximise versions, and their potential effects discussed.

The three most direct measurement of change of a component system is the measurement of the total changed components.
\begin{defs}
	The \textbf{changed components} criteria is defined as $crit_{changec} = \langle rank^{changec}_{\alpha}, \leq \rangle$,
	where $rank^{changec}_{\alpha}(\beta) = |\alpha \Delta \beta|$.
\end{defs}
That is, the number of components in the symmetric difference between component systems is the minimised with this criterion.
This criterion's measurements are an inaccurate representation of the risks of changing a system.
For example, a component being replaced by another version of itself is less risky than it being replaced with an entirely different component.  

To create a change criterion that takes into account changing between similar components is less risky, a components name can be considered.
For this purpose the function $V$ is defined as: 
\begin{defs}
The function $V: 2^{\mathbb{C}} \times \mathcal{N}$ takes a set of components $\alpha$ and a component name $n$, and returns a set of components with name $n$ that are in $\alpha$,
i.e. $V(\alpha,n) = \{\langle n',v \rangle \mid \langle n',v \rangle \in \alpha $ and $ n' = n \}$
\end{defs}

This function can be used to define a criterion that considers the name of a component:
\begin{defs}
	The \textbf{change} criterion is defined as $crit_{change} = \langle rank^{change}_{\alpha}, \leq \rangle$,
	where $rank^{change}_{\alpha}(\beta) = |\{n \mid n \in \mathcal{N}$ and $V(\alpha,n) \neq V(\beta,n) \}|$.
\end{defs}

This criterion can be altered to also consider new and removed components:
\begin{defs}
	The \textbf{new} criterion is defined as $crit_{new} = \langle rank^{new}_{\alpha}, \leq \rangle$,
	where $rank^{new}_{\alpha}(\beta) = |\{n \mid n \in \mathcal{N}$ and $V(\alpha,n) = \emptyset$ and $V(\beta,n) \neq \emptyset\}|$.
\end{defs}

\begin{defs}
	The \textbf{removed} criterion is defined as $crit_{removed} = \langle rank^{removed}_{\alpha}, \leq \rangle$,
	where $rank^{removed}_{\alpha}(\beta) = |\{n \mid n \in \mathcal{N}$ and $V(\alpha,n) \neq \emptyset$ and $V(\beta,n) =\emptyset\}|$.
\end{defs}

These criteria were defined by Mancoosi for MISC.
They can be used as a representation of the risk that change has to a system.

\subsubsection{Version criteria}
%%%Maximise version, just sum up all versions and maximise their value
The problems with measuring the up-to-dateness of a component system (as described above), and this leads to difficulty in defining appropriate criteria.
The simplest criterion that can be defined to keep the system up to date, would be to simply maximise the sum of the versions.
This criteria is defined:

\begin{defs}
	The version criterion is defined to maximise the pseudo-Boolean function $f_{\alpha}(\beta) = a_1$.\verb+version+$.a_1 + \ldots + a_n$.\verb+version+$.a_n$
	where $\{a_1,\ldots,a_n\} = \{x \mid x \in \mathbb{C}\}$.
	That is, it maximises the sum of versions of components in the system.
	This criterion is defined in the MOF as \verb!+version!.
\end{defs}

This is only possible in the CUDF component model as the versions are integers, therefore easily added in the pseudo-Boolean function.
Other component model's versioning models may require to be converted into integers.

%%%Problem is some versions jump further, like av1, av10, av20, vs component cv1,cv2,cv3
The core issue with this criterion, is that different components can use a version model in different manners, making the summation of two different component versions meaningless.
For example, a component $a$ may version their components by factors of $10$, e.g. $a_{10},1_{20},a_{30}$, 
and another component $b$ may version their components by factors of $1$, e.g. $b_1,b_2,b_3$.
A situation may arise where a system can evolve to either include $a_20$ and $b_1$, or $a_10$ and $b_9$.
This criterion would select the former solution although $a_10$ is only one version out of date, and $b_1$ is eight versions out of date. 

Another problem with this criterion is that it optimises for large solutions where two older versions can be measured as better than a single newer version.
For example, a system with only the component $b_4$ is deemed less optimal that a system with both $b_2$ and $b_3$.

These problems make the use of this criterion very difficult, although it initially may seem a reasonable definition of a criterion.   


\subsection{Mancoosi Criteria}
The Mancoosi organisation for its MISC competitions (discussed in section \ref{impl.verif}) defined a set of criteria in order to compare different solvers.
Three types of criteria where defined, types that measure change, types that measure version, and an aggregating criteria. 

\subsubsection{Change}
The Mancoosi criteria use an abstraction of a component, a component name. 
As a component is defined as a name version pair ($\langle n,v \rangle$), a component name is just the name ($n$) element of the component. 
This means that the change of a system can be measured by the change of component names in the system.
The implications of such an abstraction are that updating a component will not add a component name to the system so can be ignored.
It also means that adding all versions of a component will not change the name, so such criteria must be used carefully.

%%%Initial constraints to define literals\
The first step that must be taken to include this criteria is to define literals that represent a component name.
In section \ref{impl.lexstrength} the function of \verb+initial-constraints+ was described to allow criteria to contribute constraints to the formula.
Such constraints let the criteria define literals to be able to optimise the solution.
Given all components with name $n$ are denoted as $a^n_1,\ldots,a^n_k$,
what is required is a literal $d_n$ such that iff any component $a^n_i$ is positive in a set of literals, then $d_n$ is positive.

This can be represented by the constraint $d_n \Leftrightarrow a^n_1 \vee \ldots \vee a^n_k$, which
is equivalent to $d_n \rightarrow a^n_1 \vee \ldots \vee a^n_k \bigwedge a^n_1 \vee \ldots \vee a^n_k \rightarrow d_n$.
The left term can create the CNF clause $\neg d_n \vee a^n_1 \vee \ldots \vee a^n_k$;
the right term is equal to $\neg(a^n_1 \vee \ldots \vee a^n_k) \vee d_n$,
through De Morgans laws $(\neg a^n_1 \wedge \ldots \wedge \neg a^n_k) \vee d_n$,
and through distributivity equals $\neg a^n_1 \vee d_n \bigwedge \ldots \bigwedge \neg a^n_k \vee d_n$.      
For every component name in the set of components, these clauses are added to the formula.

%%%removed and new

Given the set of all names $N$ and the function $Name$ which takes a set of literals and returns all names of components that are positive,
two criteria for minimising the newly added and removed names are defined.
\begin{defs}
The Mancoosi removed criterion is then defined using the pseudo-Boolean function
represented by the set of pairs $[(1,\neg d_n) \mid n \in N(\alpha)]$.
This criterion is defined in the MOF as \verb+-removed+.
\end{defs}

\begin{defs}
The Mancoosi changed criterion is then defined using the pseudo-Boolean function
 represented by the set of pairs $[(1,d_n) \mid n \in N \wedge n \not \in N(\alpha)]$.
This criterion is defined in the MOF as \verb+-new+.
\end{defs}

The last change based Mancoosi criterion to describe the component names that have changed.
This criterion minimises the amount of names that have had a component with that name either be removed or added.
For example, if a component of name $c$ is removed, and replaced with two components of name $c$, then this is only one component name changed.

To measure this change some constraints from the function \verb+initial-constraints+ must be defined.
What is required is a literal for each component name that is true if no literal of that component name is altered between solutions.
That is, given the name $n$, the previous solution $\alpha$, and the literals $a^n_1, \ldots , a^n_k$ that are all literals with name $n$ (this includes negative literals);
the literal $h_n$ for a given name $n$ is defined to be true if no component of name $n$ changes from the initial system $\alpha$.

That is $h_n \Leftrightarrow a^n_1 \wedge \ldots \wedge a^n_k$, 
which equals $h_n \rightarrow a^n_1 \wedge \ldots \wedge a^n_k \bigwedge a^n_1 \wedge \ldots \wedge a^n_k \rightarrow h_n$.
The left term equals $\neg h_n  \vee (a^n_1 \wedge \ldots \wedge a^n_k)$,
through distribution equals the CNF clauses $\neg h_n \vee a^n_1 \bigwedge \ldots \bigwedge \neg h_n \vee a^n_k$.
The right term equals $\neg(a^n_1 \wedge \ldots \wedge a^n_k) \vee h_n$,
which equals the CNF clause $\neg a^n_1 \vee \ldots \vee \neg a^n_k \vee h_n$.
For every component name, this set of constrains must be added to the formula in order for this criterion to function.

\begin{defs}
The Mancoosi changed criterion is then defined using the pseudo-Boolean function
that sums all literals $h_n$ that are negated in the changed system. 
This function is represented by the set of pairs $[(1,\neg h_n) \mid n \in N]$.
This criterion is defined in the MOF as \verb+-changed+.
\end{defs}

\subsubsection{Up-to-Date}
The criteria that Mancoosi defined in order to maximise the up-to-dateness of the system is the \verb+-notuptodate+ 
criterion that minimises the amount of component names that are included but do not have their newest version installed.

To define this criterion a variable is required that describes whether a name of a component is installed but it does not have the newest version installed.
For this, the component $b_n$ is defined as the highest version of the components of name $n$,
and the use of the variable $d_n$ defined previously to be positive iff a component with name $n$ is in the proposed system.

A set of constraints for the function \verb+initial-constraints+ are defined
such that a variable $u_n$ is positive if the name $n$ is in the system, and the component $b_n$ is not.
That is, $u_n \Leftrightarrow d_n \wedge \neg b_n$, which equals
$u_n \rightarrow d_n \wedge \neg b_n \bigwedge (d_n \wedge \neg b_n) \rightarrow u_n$.
The left term equals $\neg u_n \vee (d_n \wedge \neg b_n)$, 
which with distributivity equals the two CNF clauses $\neg u_n \vee d_n \bigwedge \neg u_n \vee \neg b_n$.
The right term equals $\neg (d_n \wedge \neg b_n) \vee u_n$,
which with De Morgans laws equals the CNF clause $\neg d_n \vee b_n \vee u_n$. 

\begin{defs}
The Mancoosi not up to date criterion is then defined using the pseudo-Boolean function
represented by the set of pairs $[(1,\neg u_n) \mid n \in N]$.
This criterion is defined in the MOF as \verb+-notuptodate+.
\end{defs}


This progressive criterion optimises a system to have as little not up to date components as possible.
This can result in some un-intuitive results.
For example, given a set of component versions $c_1$, $c_2$ and $c_3$, if $c_3$ is the highest verison a and is not installed in the system, 
this criteria does not consider the better version between $c_1$ and $c_2$.
Therefore, this criteria will not try to maximise the versions in the system, merely try to make sure the maximum version is installed.


\subsection{P2}
%%%Looking at the criteria from the P2 solver
Eclipse \textbf{P2} \citep{le_berre_dependency_2009,leBerre2010} is the provisioning system for the Eclipse IDE platform.
Its optimisation, as described in chapter \ref{background}, are focused on minimising the amount of components with no dependencies, the removal of components,
the age of the installed components, and changing components unnecessarily.
These are mapped to pseudo-Boolean functions that are then added together to create a single function \citep{leBerre2010}.
This differs from the lexicographic relationship that is defined through our optimisation framework.

Most of P2's criteria focus on minimising change within the system which is analogous to the definition given previously.
However, the criterion to minimise the age of a component is the most interesting as it provides a definition that removes many of the problems
discussed with the  \verb!+version! and \verb+-notuptodate+ criteria.

\begin{defs}
Given a sorted list of all components of the same name by versions $[a_n,\ldots,a_0]$, where $a_0$ is the least version, and $a_n$ is the highest version,
the function $age$ is then defined to take a component and return its index from this list.
The criterion is then defined to minimise the function represented by the set of pairs $[(age(x), x) \mid x \in \mathbb{C}]$.
This criterion is defined in the MOF as \verb!-uptodateage+!.
\end{defs}

This age metric, eliminates the problem with the criteria, where versions can be dependent on a components versioning model.
This is done by creating a relative measure of what version of a component is, which is the number of newer components that exist.
This allows this method to compare components that version differently to determine the up-to-dateness of a system.
However, this criteria can still be mislead by different components.
For example, if a component constantly releases versions, with little changes or no changes, the age of a component can quickly force an update, 
although their may be little risk of not upgrading. 


\section{Summary}
In this chapter the strategies a user may employ in order to evolve their component systems were discussed.
These strategies, first elicited from a survey given to users of component systems, are defined into two sterotypes, progressive and conservative.
Both of these sterotypes are defined given some risk to the system, progressive users are more concerned with the risk of being not up-to-date,
and conservative users are more concerned with the risk of change to the system.
Criteria where defined that express these risks, and can be used to optimise the evolution of component systems.
Each criterion is defined using a pseudo-Boolean function, that can be used in the algorithms provided in the previous chapter to select systems that reflect the users goals.
In the following chapters, a simulation is defined to imitate the evolution of a system.
This will enable the testing and validation of these strategies and criteria, to find if the users goals are achieved through their use. 
