\chapter{User's Evolution Strategies}
\label{strategies}
\epigraph{Motion or change, and identity or rest, are the first and second secrets of nature: Motion and Rest. 
The whole code of her laws may be written on the thumbnail, or the signet of a ring.}
{\textit{Ralph Waldo Emerson in "Nature", Essays, Second Series (1844)}}

%%%Yet defined the user
Up till this point in this thesis the user has been left disembodied and abstract.
However, given the aims of this research are to look at not only the process of component system evolution, but also the consequences of different approaches.
As the user is the actor that defines the approach taken to evolve a component system, this user will need to be described and explored.

%%%The user evolves the system, they are important
Lehman laws on software evolution state ``the system must continually grow to maintain user satisfaction''.
In systems that are not component based, this evolution process was done completely by a third party.
What extra functionality is included, what bugs are important and should be fixed, what font the buttons have. 
However, in component systems some of these decisions are given to the user, and therefore are out of the developers control.
For instance, a user of a component system may experience issues with a particular component, 
and may decide to upgrade, or downgrade that component to fix these issues.

%%%What possible decisions can they make? Add, remove, upgrade, and criteria
A developer of a component can change the component at the code level, however the user does not have the ability to be that precise in their actions.
Some of the possible actions a user can take to evolve their system have been described in the previous chapter,
where the user can request a component to be installed, removed or upgraded.
This limited set of actions can provide a great deal of choice when evolving a system, as their can be many components available to act upon.
As any action can be accomplished with various solutions, the user must choose the criteria by which to judge and select a resulting component system.
This criteria will guide the systems evolutions through returning solutions that have attributes the user desires.

%%%What drives the users decisions?
This user of a component system then has the power to change the system they are using.
How do they use this power, what drives the decisions that they make?
A fundamental influence on how the user would select a to evolve their system is the objectives of the system.
These objectives determine the included functionality and as the objectives change the way in which this functionality is altered.  
Another influence on what actions a user takes is the perceived risk of taking an action, or not taking an action.
For example, upgrading a system may introduce new bugs and problems, yet not upgrading may let old vulnerabilities compromise the system.

%%%What are strategies, Plans to employ to evolve a component system
The choices the user makes to evolve the component system is described as the users evolution strategy.
By strategy, it is meant the plan or pattern employed by a user to evolve a system to attain the systems objectives.

%%%In this chapter\ldots
In this chapter, the users that evolve component systems are described, and their choices of criteria defined.
Firstly, a survey that was given to users in order to determine their strategies of how they evolve their component systems is discussed in section \ref{strat.usersurvey}.
This survey was conducted in order to illuminate general user strategies and discuss aspects like interactions while evolving component systems.
The criteria a user judges solutions by are then discussed, the reasons and system objectives they fulfil are described.
Each criteria is mapped to the formal description given in chapter \ref{formal} and the implementation description given in chapter \ref{implementation}.
This chapter is finished with a brief discussion on how criteria can be composed to fulfil different user objectives. 

\section{User Survey}
\label{strat.usersurvey}
%%%The survey used to validate and refine the model
To describe and define the strategies that different users employ to evolve their component systems an online survey was conducted.
This survey targeted users of GNU/Linux distributions, specifically Ubuntu, and also server administrators through the online forum reddit\footnote{http://reddit.com}.
In this context the way in which component systems are evolved is through package managers, as described in chapter \ref{background}.
It was completed by 59 users, who answered questions about them selves, the system they are evolving, and the way in which they evolve it.
It also involved the submission of package manager log files, which enable the processing for real update and install probabilities.
These logs are not analysed here, but are used further in chapter \ref{ubunutsimulation}.

In this section a brief description of the survey and an analysis of what was learnt is given.
The full set of questions in the survey is presented in section \ref{apx.survey}. 

\subsection{Questions}
%%%The goals of the survey:
There are two types of questions in the survey; a set to identify the type of user, and a set to describe their interactions with package managers.

A set of questions used to identify the user are:
\begin{itemize}
  \item How experienced with package managers are you? 
  \item What system are you using?
  \item What package manager are you using?
\end{itemize}
These can be used to categorise the type of user and put into context the answers that they give.
They can also be used to weigh their answers for credibility and potentially exclude results from novice or inexperienced users. 

A set of questions asked about their use of package mangers are:
\begin{itemize}
  \item Describe your initial interaction with the package manager.
  \item Describe your day to day interactions with the package manager.
  \item What usage life cycle do you have with the package manager.
  \item Describe an unusual scenario in which the package manager was used.
\end{itemize}
The main focus of these questions is to identify the life-cycle of interactions that the user has when evolving a system.
This is mainly of interest latter in chapters \ref{simulation} and \ref{ubunutsimulation} when these variables must be defined.
However, it also provides us with reasons for these actions to occur, and illuminates the users objectives and strategies.

The survey finished with the question:
\begin{itemize}
  \item What other questions should I have asked?
\end{itemize}
This question tried to illicit comments and possible information that I could of gathered.
It also provided a small verification of the survey, as to see if anything was missing that should of been asked.

\subsection{Results}
%%%The results are summarised as:
The type of user that submitted the survey is important to be able to put in context their replies.
Most users (29/59) used dpkg component model either in Debian or Ubuntu systems, and the majority of those uses used apt-get as their package manager.
The next largest component model used was ArchLinux\footnote{http://www.archlinux.org/} (13/59) each one using the package manager pacman\footnote{http://www.archlinux.org/pacman/}.
Other represented component models and package mangers include, Fedora with the rpm component model and yum package manger,
Slackware with pkgtools, and Gentoo with portage.

The users mean experience was recorded as 3.9/5.
This is of course a subjective measure but describes the confidence in which the participants answered the questions. 

The life cycle questions have been summarised into the frequency of each action in table \ref {strat.tblaction}.

\begin{table}[htp]
\begin{tabular}{l | c | c | c | c |}
Request & Init. & Daily & Weekly & Monthly \\
Upgrade  & 45 & 27 & 16 & 0 \\
Install & 49 & 6 & 17 & 3 \\
Remove & 6 & 4 & 1 & 0\\
\end{tabular}
\caption{Summary of the frequency of user actions with package managers}
\label{strat.tblaction}
\end{table}

This table shows the amount of users from the survey who perform the actions of upgrading their system, installing or removing a package 
initially, when the system is first created, daily, weekly or monthly.
It shows that the vast majority of users when they create a system upgrade the system and install required packages.
This also shows that most users upgrade their system daily, and if they will likely install a package weekly.

The unusual scenarios which the user described using the package manager included 
11 of the 59 users stating that they had installed a set of packages to fulfil a specific task only to remove them the next day.
This is described by the users response ``I sometimes install lots of packages very quickly as I need to accomplish a task, then remove them once that task has finished.''
Also, 3 of the users stated that use of the package manager broke their system, which then required to be fixed through the package manager.

In the final question asked if there is any more questions the general themes include, 
the mitigation of failed actions, installing multiple versions of packages, and using a graphical user interface v.s. console based package manager.
The majority (37/59) users did not fill out this option in the survey, hopefully showing that the majority expressed all they wished throughout the survey.
One user even remarked ``Quite an all encompassing survey!'' in this field.

\subsection{Progressive vs. Conservative Users}
The main outcome of this survey was the identification of different user attitudes towards evolving a component system.
These attitudes create user stereotypes which here are described as either \textbf{conservative} or \textbf{progressive}.
These terms come from the domain of politics where conservatism is the philosophy that emphasises minimal and gradual change in society,
where progressivism promotes change and reform.
These ideologies are caused because of a conflicting perception of risk; the risk of change introducing new problems, and the risk of not changing having old problems persist.
They then must be resolved, joined together in a way which is acceptable to the parties involved.

These ideologies are analogous to component system evolution where there is a force that wishes to reduce the risk to a system by not altering it,
and one to reduce risk by installing new versions of components.
The majority of users from the survey found some middle ground in which to mitigate both types of risk.

For example, a users response that express a slight conservative attitude:
\begin{quotation}
In production I rarely remove packages (easier to leave software as-is than risk breaking stuff).
\end{quotation}
That is they are more likely not to change the system, just in case it leads to a fault. 

Another example of a users response expressing a slight progressive attitude:
\begin{quotation}
I update my packages whenever I log in each day
\end{quotation}
Updating when they log in each day ensures the system is up to date, 

Both of these ideologies have extremes though, users who try to eliminate all risk of one of the opposing ideology.

For example, a user's response in the survey with an extreme progressive attitude:
\begin{quotation}
I do run an unstable system all the time, I help mitigate this with some redundancy in my most frequently used components, 
using packages which perform the same function, but have different dependencies, since it's less likely to have multiple packages break at the same time. 
If something is rather buggy for me, I tend to update on a more frequent basis to check for the next stable point to jump into.
\end{quotation}
This user has components in their system that are so new as to not be fully tested, these are described as unstable packages.
To lower the risk that such packages have on the function of the system, this user has redundant functionality installed in their system to ensure that it can be used.
This users system will almost certainly be completely up to date, as any new component versions will be immediately integrated into their system.

An example of an extremely conservative user's response when asked about the frequency with which they interact with the package manager:
\begin{quotation}
As little as possible. I like build my box into whatever I'll need in the first couple of weeks after an install. 
Following the configuration and construction, only the occasional upgrade is necessary. 
Unless, of course, I receive a security notice about something.
\end{quotation}
So after the setting up of a system, this user will not evolve the system unless there is a direct security risk.
This non-change will result in the system quickly becoming out of date.

%%%The reasons for keeping a system up-to-date; the fixing of bugs security, the adding of functionality, 
The reasons for these progressive attitudes of users is that maintaining an up-to-date system will eliminate known security exploits against the system,
and also introduce more efficient or new functionality into the system.
%%%The reasons for minimal change; through change unknown bugs could be introduced, the act of changing can create bugs, the effort of changing can consume resources  (e.g. network traffic).
Where the conservative attitudes come from the wither the perceived risk that unknown bugs could be introduced into the system, the act of changing a system can cause faults,
or the consumed resources (e.g. time, network traffic) are to expensive for the benefits.

Both concerns are valid assessments of the risk of component system evolution, the user must decide with respect to the system objectives what they require. 
For example, a server administrator that is running a mission critical system will likely change the system begrudgingly as any fault could cause massive damage.
However, a user running a desktop personal computer system may be more interested in new functionality than the up-time of the computer, so would change more readily.

\section{Criteria}
%%%What do we mean by criteria
Any requested change to a system may be satisfied by many possible solutions.
When a user is confronted with many solutions to choose from, they are forced to judging, then selecting a system that suites their requirements.
The criteria used to judge and select the system therefore will have a great effect on the evolution of a component system.

Selecting the criteria, and composing them in a meaningful way in which the resulting solutions is a difficult challenge.
This is because there is no clear way to version a component system, making the definition of a criterion that maximises versions difficult.
Also as change is a necessary part of the system, minimising to zero is impossible, and a criterion that attempted to do this counter productive.
As any user, progressive or conservative, wants minimal change and/or the latest version, defining criteria to satisfy these requirements is a challenge.

%%%There is no way to version a component system
Given most pieces of software, the higher the version means the more ``up-to-date'' it is.
This ``up-to-dateness'' shows that the software is more recent and incorporates the latest bug fixes and features that have been developed. 
A problem occurs when trying to version a component system, as each component has a different version and they can be combined in many different ways.
For example, given two components each with two versions $a_1,a_2,b_1,b_2$, which of these systems is more up-to-date $\{a_1,b_2\}$ or $\{a_2,b_1\}$.
This measurement of up-to-date is then difficult to define, and thus difficult to create criteria for.

%%%Change is necessary, simply definition are do not accuratly represent the problem
Minimising system changes also creates difficulties when trying to define criteria.
Simply, a component system can have a component added or removed, where to update of a component is the removal of the old version and the addition of a new one.
This does not seem an entirely genuine definition of change as an update is seen as a less risky action than a component removal by users in the survey.  
Therefore, different changes have different risks associated with them, and simply addition and removal criteria are not necessary accurate depictions of this risk.

%%%In this section
%%%Here we specifically define different criteria/heuristics 
%%%All defined formally, and ready for use for the simulation in the next chapter
In this section the definition of different criteria used to select solution is defined and their positive and negative implications are discussed.
Each criteria is defined as a pseudo-Boolean equation that is represented as a set of literals, and a set of coefficients, as described in chapter \ref{implementation}.  
The criteria that are defined are from academia, industry, and other domains.
Finally in this section the discussion of the use of these criteria, how they relate each other and the possible actions the user can take to evolve their component systems.  

\subsection{Simple Criteria}
There are simple definitions of criteria to minimise change and maximise versions.
These basic definitions should be intuitively correct to use, thought they can create complications.
Such criteria are defined in this section.

\subsubsection{Added, Removed and Changed Components}
The three most direct measurements of change of a system is through the summing the added, removed, or total changed components in the system.
These three measurements can be used to define criteria such that:
\begin{defs}
	  The added components criterion is defined to minimise the function
	represented by the set of pairs $[(1,x) \mid x \in \mathbb{C} \neg x \in l_1]$.
	That is, it sums the components that are not in the previous system, that are in the proposed solution.
	This criterion is defined in the Mancoosi optimisation format as \verb+-addedcomp+.

\end{defs}

\begin{defs}
	 The removed components criterion is defined to minimise the function 
	represented by the set of pairs $[(1,\neg x) \mid x \in \mathbb{C} x \in l_1]$.
	That is, it sums the components that are in the previous system, that are not in the proposed solution.
	This criterion is defined in the Mancoosi optimisation format as \verb+-removedcomp+.
\end{defs}

\begin{defs}
	 The changed components criterion is defined to minimise the function
	represented by the set of pairs $[(1,\neg x) \mid x \in \mathbb{C} x \in l_1] \cup [(1,x) \mid x \in \mathbb{C} \neg x \in l_1]$.
	That is, it sum both added and removed components as described above.
	This criterion is defined in the Mancoosi optimisation format as \verb+-changedcomp+.
\end{defs}

These criteria define change as addition or removal of a component to or from the resulting solution, the fundamental alterations of the system during evolution.
These measurements may be an inaccurate representation of the risks of changing a system.
This is best seen with the example of updating a component, which involves removing a old version, and adding a newer version of a component with the same name.
By many users the act of updating is seen as less risky than removing a component, as shown in the survey presented earlier in this chapter,
though here it is measured as twice the value.
These simple criteria do not take into account the name of a component, which is seen as (and may indeed) have an impact on the risk of an evolution.

\subsubsection{Maximise Version}
%%%Maximise version, just sum up all versions and maximise their value
The problems with measuring the up-to-dateness of a component system (as described above), and this leads to difficulty in defining appropriate criteria.
The simplest criterion that can be defined to keep the system up to date, would be to simply maximise the sum of the versions.
This criteria is defined:

\begin{defs}
	The version criterion is defined to maximise the pseudo-Boolean function 
	represented by the set of pairs $[(x$.\verb+version+$,x) \mid x \in \mathbb{C}]$.
	That is, it maximises the sum of versions of components in the system.
	This criterion is defined in the Mancoosi optimisation format as \verb!+version!.
\end{defs}

This is only possible in the CUDF component model as the versions are integers, therefore easily added in the pseudo-Boolean function.
Other component model's versioning models may require to be converted into integers.

%%%Problem is some versions jump further, like av1, av10, av20, vs component cv1,cv2,cv3
The core issue with this criterion, is that different components can use a version model in different manners, making the summation of two different component versions meaningless.
For example, a component $a$ may version their components by factors of $10$, e.g. $a_{10},1_{20},a_{30}$, 
and another component $b$ may version their components by factors of $1$, e.g. $b_1,b_2,b_3$.
A situation may arise where a system can evolve to either include $a_20$ and $b_1$, or $a_10$ and $b_9$.
This criterion would select the former solution although $a_10$ is only one version out of date, and $b_1$ is eight versions out of date. 

Another problem with this criterion is that it optimises for large solutions where two older versions can be measured as better than a single newer version.
For example, a system with only the component $b_4$ is deemed less optimal that a system with both $b_2$ and $b_3$.

These problems make the use of this criterion very difficult, although it initially may seem a reasonable definition of a criterion.   


\subsection{Mancoosi Criteria}
The Mancoosi organisation for its MISC competitions (discussed in section \ref{impl.verif}) defined a set of criteria in order to compare different solvers.
Three types of criteria where defined, types that measure change, types that measure version, and an aggregating criteria. 

\subsubsection{Change}
The Mancoosi criteria use an abstraction of a component, a component name. 
As a component is defined as a name version pair ($\langle n,v \rangle$), a component name is just the name ($n$) element of the component. 
This means that the change of a system can be measured by the change of component names in the system.
The implications of such an abstraction are that updating a component will not add a component name to the system so can be ignored.
It also means that adding all versions of a component will not change the name, so such criteria must be used carefully.

%%%Initial constraints to define literals\
The first step that must be taken to include this criteria is to define literals that represent a component name.
In section \ref{impl.lexstrength} the function of \verb+initial-constraints+ was described to allow criteria to contribute constraints to the formula.
Such constraints let the criteria define literals to be able to optimise the solution.
Given all components with name $n$ are denoted as $a^n_1,\ldots,a^n_k$,
what is required is a literal $d_n$ such that iff any component $a^n_i$ is positive in a set of literals, then $d_n$ is positive.

This can be represented by the constraint $d_n \Leftrightarrow a^n_1 \vee \ldots \vee a^n_k$, which
is equivalent to $d_n \rightarrow a^n_1 \vee \ldots \vee a^n_k \bigwedge a^n_1 \vee \ldots \vee a^n_k \rightarrow d_n$.
The left term can create the CNF clause $\neg d_n \vee a^n_1 \vee \ldots \vee a^n_k$;
the right term is equal to $\neg(a^n_1 \vee \ldots \vee a^n_k) \vee d_n$,
through De Morgans laws $(\neg a^n_1 \wedge \ldots \wedge \neg a^n_k) \vee d_n$,
and through distributivity equals $\neg a^n_1 \vee d_n \bigwedge \ldots \bigwedge \neg a^n_k \vee d_n$.      
For every component name in the set of components, these clauses are added to the formula.

%%%removed and new

Given the set of all names $N$ and the function $Name$ which takes a set of literals and returns all names of components that are positive,
two criteria for minimising the newly added and removed names are defined.
\begin{defs}
The Mancoosi removed criterion is then defined using the pseudo-Boolean function
represented by the set of pairs $[(1,\neg d_n) \mid n \in N(l_1)]$.
This criterion is defined in the Mancoosi optimisation format as \verb+-removed+.
\end{defs}

\begin{defs}
The Mancoosi changed criterion is then defined using the pseudo-Boolean function
 represented by the set of pairs $[(1,d_n) \mid n \in N \wedge n \not \in N(l_1)]$.
This criterion is defined in the Mancoosi optimisation format as \verb+-new+.
\end{defs}

The last change based Mancoosi criterion to describe the component names that have changed.
This criterion minimises the amount of names that have had a component with that name either be removed or added.
For example, if a component of name $c$ is removed, and replaced with two components of name $c$, then this is only one component name changed.

To measure this change some constraints from the function \verb+initial-constraints+ must be defined.
What is required is a literal for each component name that is true if no literal of that component name is altered between solutions.
That is, given the name $n$, the previous solution $l_1$, and the literals $a^n_1, \ldots , a^n_k$ that are all literals with name $n$ (this includes negative literals);
the literal $h_n$ for a given name $n$ is defined to be true if no component of name $n$ changes from the initial system $l_1$.

That is $h_n \Leftrightarrow a^n_1 \wedge \ldots \wedge a^n_k$, 
which equals $h_n \rightarrow a^n_1 \wedge \ldots \wedge a^n_k \bigwedge a^n_1 \wedge \ldots \wedge a^n_k \rightarrow h_n$.
The left term equals $\neg h_n  \vee (a^n_1 \wedge \ldots \wedge a^n_k)$,
through distribution equals the CNF clauses $\neg h_n \vee a^n_1 \bigwedge \ldots \bigwedge \neg h_n \vee a^n_k$.
The right term equals $\neg(a^n_1 \wedge \ldots \wedge a^n_k) \vee h_n$,
which equals the CNF clause $\neg a^n_1 \vee \ldots \vee \neg a^n_k \vee h_n$.
For every component name, this set of constrains must be added to the formula in order for this criterion to function.

\begin{defs}
The Mancoosi changed criterion is then defined using the pseudo-Boolean function
that sums all literals $h_n$ that are negated in the changed system. 
This function is represented by the set of pairs $[(1,\neg h_n) \mid n \in N]$.
This criterion is defined in the Mancoosi optimisation format as \verb+-changed+.
\end{defs}

\subsubsection{Up to Date}
The criteria that Mancoosi defined in order to maximise the up-to-dateness of the system is the \verb+-notuptodate+ 
criterion that minimises the amount of component names that are included but do not have their newest version installed.

To define this criterion a variable is required that describes whether a name of a component is installed but it does not have the newest version installed.
For this, the component $b_n$ is defined as the highest version of the components of name $n$,
and the use of the variable $d_n$ defined previously to be positive iff a component with name $n$ is in the proposed system.

A set of constraints for the function \verb+initial-constraints+ are defined
such that a variable $u_n$ is positive if the name $n$ is in the system, and the component $b_n$ is not.
That is, $u_n \Leftrightarrow d_n \wedge \neg b_n$, which equals
$u_n \rightarrow d_n \wedge \neg b_n \bigwedge (d_n \wedge \neg b_n) \rightarrow u_n$.
The left term equals $\neg u_n \vee (d_n \wedge \neg b_n)$, 
which with distributivity equals the two CNF clauses $\neg u_n \vee d_n \bigwedge \neg u_n \vee \neg b_n$.
The right term equals $\neg (d_n \wedge \neg b_n) \vee u_n$,
which with De Morgans laws equals the CNF clause $\neg d_n \vee b_n \vee u_n$. 

\begin{defs}
The Mancoosi not up to date criterion is then defined using the pseudo-Boolean function
represented by the set of pairs $[(1,\neg u_n) \mid n \in N]$.
This criterion is defined in the Mancoosi optimisation format as \verb+-notuptodate+.
\end{defs}


This progressive criterion optimises a system to have as little not up to date components as possible.
This can result in some un-intuitive results.
For example, given a set of component versions $c_1$, $c_2$ and $c_3$, if $c_3$ is the highest verison a and is not installed in the system, 
this criteria does not consider the better version between $c_1$ and $c_2$.
Therefore, this criteria will not try to maximise the versions in the system, merely try to make sure the maximum version is installed.

\subsubsection{Sum}
The final Mancoosi defined criteria are functions that either minimises or maximises the sum of a property of the installed components. 
The property is left as a variable, and as long as each component has a value for that property the criteria can be used.

These are defined as:
\begin{defs}
The criterion to maximise a property $X$ is defined by the pseudo-Boolean function 
represented by the set of pairs $[(c.X, c) \mid c \in \mathbb{C}]$.
This criterion is defined in the Mancoosi optimisation format as \verb!+sum(!$X$\verb+)+.
\end{defs}

\begin{defs}
The criterion to minimise a property $X$ is defined by the pseudo-Boolean function 
represented by the set of pairs $[(c.X, c) \mid c \in \mathbb{C}]$.
This criterion is defined in the Mancoosi optimisation format as \verb+-sum(+$X$\verb+)+.
\end{defs}

The property $X$ is arbitrary though practically is must be defined in the CUDF document.
For example, the property $size$ that defines the size in kB of the component could be minimised with the criteria definition \verb+-sum(+$size$\verb+)+.
Using the expendable nature of the CUDF specification many various properties of a component could have can be represented and optimised for.
Some such properties that can be used, like PageRank or instability, are defined later in this section.

\subsection{P2}
%%%Looking at the criteria from the P2 solver
Eclipse \textbf{P2} \cite{le_berre_dependency_2009,leBerre2010} is the provisioning system for the Eclipse IDE platform.
Its optimisation, as described in chapter \ref{background}, are focused on minimising the amount of components with no dependencies, the removal of components,
the age of the installed components, and changing components unnecessarily.
These are mapped to pseudo-Boolean functions that are then added together to create a single function \citep{leBerre2010}.
This differs from the lexicographic relationship that is defined through our optimisation framework.

Most of P2's criteria focus on minimising change within the system which is analogous to the definition given previously.
However, the criterion to minimise the age of a component is the most interesting as it provides a definition that removes many of the problems
discussed with the  \verb!+version! and \verb+-notuptodate+ criteria.

\begin{defs}
Given a sorted list of all components of the same name by versions $[a_n,\ldots,a_0]$, where $a_0$ is the least version, and $a_n$ is the highest version,
the function $age$ is then defined to take a component and return its index from this list.
The criteria is then defined to minimise the function represented by the set of pairs $[(age(x), x) \mid x \in \mathbb{C}]$.
\end{defs}

This age metric, eliminates the problem with the criteria, where versions can be dependent on a components versioning model.
This is done by creating a relative measure of what version of a component is, which is the number of newer components that exist.
This allows this method to compare components that version differently to determine the up-to-dateness of a system.
However, this criteria can still be mislead by different components.
For example, if a component constantly releases versions, with little changes or no changes, the age of a component can quickly force an update, 
although their may be little risk of not upgrading. 





\subsection{Dependency Based Criteria}
A components dependence on another component creates a tangible connection that should be considered when evolving a system.
This connection can be seen as a form of trust, given a developer selects the components to have their components depend on,
or as a measure of importance to a system, as a component that is highly depended on has more responsibility to the system.
This should be considered when making the choice to either remove or add a component to a system.
By analysing dependencies between components we can give a weight to a component-based on the structure of its relationships.

The structure of component dependencies can be abstracted to a graph.
A directed graph $G = (V,E)$ is generated from the
dependency rules such that $V$ is the set of components, and $(a,b) \in E$ iff there is a dependency constraint in $R$ 
where $a \rightarrow c_1 \vee \ldots \vee c_n$ where $b = c_i$ for some $i$.


\subsubsection{Matrin Metrics}
Presented in \cite{} are metrics to measure the nature of classes in a

%%%Afferent coupling
number of in edges

%%%Efferent Coupling
Number of out edged

%%%Coupling 


%%%Instability
efferent coupling/ efferent coupling plus afferent coupling

\subsubsection{PageRank}

%%%Page rank as a metric, calculate page rank value for all 
and by analysing the importance of nodes in this graph using the \textbf{PageRank} with priors function \cite{White:2003:AER:956750.956782}, 
The function $PR(a)$ denotes the PageRank of $a$,
so given the set $C_R(X) \cup \{\Delta\}$ is the starting set of nodes, and the generated graph $G$,
the distance function $d_{PR}(C_1,C_2) = \sum_{a \in (C_1 \ominus C_2)} PR(a)$,
i.e. the distance is the sum of the PageRank values in the symmetric difference of the systems.
This distance is the only one to consider the components relationships when calculating the effect of removing or adding them.
Our hope is that by minimising the impact on the structure of the system, 
this will minimise the necessary changes over a long period of time.

%%%HITS, where we can identify hubs and authorities of packages and use this as criteria

%%%Propagation of positive and negative, changin a package that has very little depending on it should be better than changing a large package

\section{Optimisation}
%%%What can be optimised? Here we go over these criteria and discuss given the limitation that PBO imposes on optimisation, how we can optimise.

\section{Other Criteria}
{}There are many other types of criteria that can be considered when judging the optimality of a solution.
{}As we are trying to stay component model agnostic, the only information that can be used comes from the definition of components and component models laid out in Chapter \ref{background}.
{}However, there are other criteria that maybe component model dependent from information in component meta-data (e.g., size, vendor and licence),
{}component contracts and composition testing (e.g., reliability and speed),
{}and community sourced meta-data stored in repositories (e.g., popularity).

%%%Discuss information from component met-data

%%%Discuss information from component testing (e.g. treaty, unit tests)

%%%Discuss community stored information, e.g. app-install-data, reccommendation systems, community forums\ldots

\subsection{Criteria Composition}
The use of these criteria must be 

\section{Summary}

