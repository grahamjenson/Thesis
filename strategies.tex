\chapter{User's Evolution Strategies}
\label{strategies}
\epigraph{Motion or change, and identity or rest, are the first and second secrets of nature: Motion and Rest. 
The whole code of her laws may be written on the thumbnail, or the signet of a ring.}
{\textit{Ralph Waldo Emerson in "Nature", Essays, Second Series (1844)}}

%%%Yet defined the user
Up till this point in this thesis the user has been left disembodied and abstract.
However, given the aims of this research are to look at not only the process of component system evolution, but also the consequences of different approaches.
As the user is the actor that defines the approach taken to evolve a component system, this user will need to be described and explored.

%%%The user evolves the system, they are important
Lehman laws on software evolution state ``the system must continually grow to maintain user satisfaction''.
In systems that are not component based, this evolution process was done completely by a third party.
What extra functionality is included, what bugs are important and should be fixed, what font the buttons have. 
However, in component systems some of these decisions are given to the user, and therefore are out of the developers control.
For instance, a user of a component system may experience issues with a particular component, 
and may decide to upgrade, or downgrade that component to fix these issues.

%%%What possible decisions can they make? Add, remove, upgrade, and criteria
A developer of a component can change the component at the code level, however the user does not have the ability to be that precise in their actions.
Some of the possible actions a user can take to evolve their system have been described in the previous chapter,
where the user can request a component to be installed, removed or upgraded.
This limited set of actions can provide a great deal of choice when evolving a system, as their can be many components available to act upon.
As any action can be accomplished with various solutions, the user must choose the criteria by which to judge and select a resulting component system.
This criteria will guide the systems evolutions through returning solutions that have attributes the user desires.

%%%What drives the users decisions?
This user of a component system then has the power to change the system they are using.
How do they use this power, what drives the decisions that they make?
A fundamental influence on how the user would select a to evolve their system is the objectives of the system.
These objectives determine the included functionality and as the objectives change the way in which this functionality is altered.  
Another influence on what actions a user takes is the perceived risk of taking an action, or not taking an action.
For example, upgrading a system may introduce new bugs and problems, yet not upgrading may let old vulnerabilities compromise the system.

%%%What are strategies, Plans to employ to evolve a component system
The choices the user makes to evolve the component system is described as the users evolution strategy.
By strategy, it is meant the plan or pattern employed by a user to evolve a system to attain the systems objectives.
This term is taken from the domain of game theory, 
in that area a strategy is defined as a plan of action for whatever situation might arise, which fully determines the users behaviour.

%%%In this chapter\ldots
In this chapter, the users that evolve component systems are described, and their choices of criteria defined.
Firstly, a survey that was given to users in order to determine their strategies of how they evolve their component systems is discussed in section \ref{strat.usersurvey}.
This survey was conducted in order to illuminate general user strategies and discuss aspects like interactions while evolving component systems.
The criteria a user judges solutions by are then discussed, the reasons and system objectives they fulfil are described.
Each criteria is mapped to the formal description given in chapter \ref{formal} and the implementation description given in chapter \ref{implementation}.
This chapter is finished with a brief discussion on how criteria can be composed to fulfil different user objectives. 

\section{User Survey}
\label{strat.usersurvey}
%%%The survey used to validate and refine the model
To describe and define the strategies that different users employ to evolve their component systems an online survey was conducted.
This survey targeted users of GNU/Linux distributions, specifically Ubuntu, and also server administrators through the online forum reddit\footnote{http://reddit.com accessed 6/3/2012}.
In this context the way in which component systems are evolved is through package managers, as described in chapter \ref{background}.
It was completed by 59 users, who answered questions about them selves, the system they are evolving, and the way in which they evolve it.
It also involved the submission of package manager log files, which enable the processing for real update and install probabilities.
These logs are not analysed here, but are used further in chapter \ref{ubunutsimulation}.

In this section a brief description of the survey and an analysis of what was learnt is given.
The full set of questions in the survey is presented in section \ref{apx.survey}. 

\subsection{Questions}
%%%The goals of the survey:
There are two types of questions in the survey; a set to identify the type of user, and a set to describe their interactions with package managers.

A set of questions used to identify the user are:
\begin{itemize}
  \item How experienced with package managers are you? 
  \item What system are you using?
  \item What package manager are you using?
\end{itemize}
These can be used to categorise the type of user and put into context the answers that they give.
They can also be used to weigh their answers for credibility and potentially exclude results from novice or inexperienced users. 

A set of questions asked about their use of package mangers are:
\begin{itemize}
  \item Describe your initial interaction with the package manager.
  \item Describe your day to day interactions with the package manager.
  \item What usage life cycle do you have with the package manager.
  \item Describe an unusual scenario in which the package manager was used.
\end{itemize}
The main focus of these questions is to identify the life-cycle of interactions that the user has when evolving a system.
This is mainly of interest latter in chapters \ref{simulation} and \ref{ubunutsimulation} when these variables must be defined.
However, it also provides us with reasons for these actions to occur, and illuminates the users objectives and strategies.

The survey finished with the question:
\begin{itemize}
  \item What other questions should I have asked?
\end{itemize}
This question tried to illicit comments and possible information that I could of gathered.
It also provided a small verification of the survey, as to see if anything was missing that should of been asked.

\subsection{Results}
%%%The results are summarised as:
The type of user that submitted the survey is important to be able to put in context their replies.
Most users (29/59) used dpkg component model either in Debian or Ubuntu systems, and the majority of those uses used apt-get as their package manager.
The next largest component model used was ArchLinux\footnote{http://www.archlinux.org/ accessed 6/3/2012} (13/59),
each one using the package manager pacman\footnote{http://www.archlinux.org/pacman/ accessed 6/3/2012}.
Other represented component models and package mangers include, Fedora with the rpm component model and yum package manger,
Slackware with pkgtools, and Gentoo with portage.

The users mean experience was recorded as 3.9/5.
This is of course a subjective measure but describes the confidence in which the participants answered the questions. 

The life cycle questions have been summarised into the frequency of each action in table \ref {strat.tblaction}.

\begin{table}[htp]
\begin{tabular}{l | c | c | c | c |}
Request & Init. & Daily & Weekly & Monthly \\
Upgrade  & 45 & 27 & 16 & 0 \\
Install & 49 & 6 & 17 & 3 \\
Remove & 6 & 4 & 1 & 0\\
\end{tabular}
\caption{Summary of the frequency of user actions with package managers}
\label{strat.tblaction}
\end{table}

This table shows the amount of users from the survey who perform the actions of upgrading their system, installing or removing a package 
initially, when the system is first created, daily, weekly or monthly.
It shows that the vast majority of users when they create a system upgrade the system and install required packages.
This also shows that most users upgrade their system daily, and if they will likely install a package weekly.

The unusual scenarios which the user described using the package manager included 
11 of the 59 users stating that they had installed a set of packages to fulfil a specific task only to remove them the next day.
This is described by the users response ``I sometimes install lots of packages very quickly as I need to accomplish a task, then remove them once that task has finished.''
Also, 3 of the users stated that use of the package manager broke their system, which then required to be fixed through the package manager.

In the final question asked if there is any more questions the general themes include, 
the mitigation of failed actions, installing multiple versions of packages, and using a graphical user interface v.s. console based package manager.
The majority (37/59) users did not fill out this option in the survey, hopefully showing that the majority expressed all they wished throughout the survey.
One user even remarked ``Quite an all encompassing survey!'' in this field.

\subsection{Progressive vs. Conservative Users}
The main outcome of this survey was the identification of different user attitudes towards evolving a component system.
These attitudes create user stereotypes which here are described as either \textbf{conservative} or \textbf{progressive}.
These terms come from the domain of politics where conservatism is the philosophy that emphasises minimal and gradual change in society,
where progressivism promotes change and reform.
These ideologies are caused because of a conflicting perception of risk; the risk of change introducing new problems, and the risk of not changing having old problems persist.
They then must be resolved, joined together in a way which is acceptable to the parties involved.

These ideologies are analogous to component system evolution where there is a force that wishes to reduce the risk to a system by not altering it,
and one to reduce risk by installing new versions of components.
The majority of users from the survey found some middle ground in which to mitigate both types of risk.

For example, a users response that express a slight conservative attitude:
\begin{quotation}
In production I rarely remove packages (easier to leave software as-is than risk breaking stuff).
\end{quotation}
That is they are more likely not to change the system, just in case it leads to a fault. 

Another example of a users response expressing a slight progressive attitude:
\begin{quotation}
I update my packages whenever I log in each day
\end{quotation}
Updating when they log in each day ensures the system is up to date, 

Both of these ideologies have extremes though, users who try to eliminate all risk of one of the opposing ideology.

For example, a user's response in the survey with an extreme progressive attitude:
\begin{quotation}
I do run an unstable system all the time, I help mitigate this with some redundancy in my most frequently used components, 
using packages which perform the same function, but have different dependencies, since it's less likely to have multiple packages break at the same time. 
If something is rather buggy for me, I tend to update on a more frequent basis to check for the next stable point to jump into.
\end{quotation}
This user has components in their system that are so new as to not be fully tested, these are described as unstable packages.
To lower the risk that such packages have on the function of the system, this user has redundant functionality installed in their system to ensure that it can be used.
This users system will almost certainly be completely up to date, as any new component versions will be immediately integrated into their system.

An example of an extremely conservative user's response when asked about the frequency with which they interact with the package manager:
\begin{quotation}
As little as possible. I like build my box into whatever I'll need in the first couple of weeks after an install. 
Following the configuration and construction, only the occasional upgrade is necessary. 
Unless, of course, I receive a security notice about something.
\end{quotation}
So after the setting up of a system, this user will not evolve the system unless there is a direct security risk.
This non-change will result in the system quickly becoming out of date.

%%%The reasons for keeping a system up-to-date; the fixing of bugs security, the adding of functionality, 
The reasons for these progressive attitudes of users is that maintaining an up-to-date system will eliminate known security exploits against the system,
and also introduce more efficient or new functionality into the system.
%%%The reasons for minimal change; through change unknown bugs could be introduced, the act of changing can create bugs, the effort of changing can consume resources  (e.g. network traffic).
Where the conservative attitudes come from the wither the perceived risk that unknown bugs could be introduced into the system, the act of changing a system can cause faults,
or the consumed resources (e.g. time, network traffic) are to expensive for the benefits.

Both concerns are valid assessments of the risk of component system evolution, the user must decide with respect to the system objectives what they require. 
For example, a server administrator that is running a mission critical system will likely change the system begrudgingly as any fault could cause massive damage.
However, a user running a desktop personal computer system may be more interested in new functionality than the up-time of the computer, so would change more readily.

\section{Criteria}
%%%What do we mean by criteria
Any requested change to a system may be satisfied by many possible solutions.
When a user is confronted with many solutions to choose from, they are forced to judging, then selecting a system that suites their requirements.
The criteria used to judge and select the system therefore will have a great effect on the evolution of a component system.

Selecting the criteria, and composing them in a meaningful way in which the resulting solutions is a difficult challenge.
This is because there is no clear way to version a component system, making the definition of a criterion that maximises versions difficult.
Also as change is a necessary part of the system, minimising to zero is impossible, and a criterion that attempted to do this counter productive.
As any user, progressive or conservative, wants minimal change and/or the latest version, defining criteria to satisfy these requirements is a challenge.

%%%There is no way to version a component system
Given most pieces of software, the higher the version means the more ``up-to-date'' it is.
This ``up-to-dateness'' shows that the software is more recent and incorporates the latest bug fixes and features that have been developed. 
A problem occurs when trying to version a component system, as each component has a different version and they can be combined in many different ways.
For example, given two components each with two versions $a_1,a_2,b_1,b_2$, which of these systems is more up-to-date $\{a_1,b_2\}$ or $\{a_2,b_1\}$.
This measurement of up-to-date is then difficult to define, and thus difficult to create criteria for.

%%%Change is necessary, simply definition are do not accuratly represent the problem
Minimising system changes also creates difficulties when trying to define criteria.
Simply, a component system can have a component added or removed, where to update of a component is the removal of the old version and the addition of a new one.
This does not seem an entirely genuine definition of change as an update is seen as a less risky action than a component removal by users in the survey.  
Therefore, different changes have different risks associated with them, and simply addition and removal criteria are not necessary accurate depictions of this risk.

%%%In this section
%%%Here we specifically define different criteria/heuristics 
%%%All defined formally, and ready for use for the simulation in the next chapter
In this section the definition of different criteria used to select solution is defined and their positive and negative implications are discussed.
Each criteria is defined as a pseudo-Boolean equation that is represented as a set of literals, and a set of coefficients, as described in chapter \ref{implementation}.  
The criteria that are defined are from academia, industry, and other domains.
Finally in this section the discussion of the use of these criteria, how they relate each other and the possible actions the user can take to evolve their component systems.  

\subsection{Simple Criteria}
There are simple definitions of criteria to minimise change and maximise versions.
These basic definitions should be intuitively correct to use, thought they can create complications.
Such criteria are defined in this section.

\subsubsection{Added, Removed and Changed Components}
The three most direct measurements of change of a system is through the summing the added, removed, or total changed components in the system.
These three measurements can be used to define criteria such that:
\begin{defs}
	  The added components criterion is defined to minimise the function
	represented by the set of pairs $[(1,x) \mid x \in \mathbb{C} \neg x \in l_1]$.
	That is, it sums the components that are not in the previous system, that are in the proposed solution.
	This criterion is defined in the Mancoosi optimisation format as \verb+-addedcomp+.

\end{defs}

\begin{defs}
	 The removed components criterion is defined to minimise the function 
	represented by the set of pairs $[(1,\neg x) \mid x \in \mathbb{C} x \in l_1]$.
	That is, it sums the components that are in the previous system, that are not in the proposed solution.
	This criterion is defined in the Mancoosi optimisation format as \verb+-removedcomp+.
\end{defs}

\begin{defs}
	 The changed components criterion is defined to minimise the function
	represented by the set of pairs $[(1,\neg x) \mid x \in \mathbb{C} x \in l_1] \cup [(1,x) \mid x \in \mathbb{C} \neg x \in l_1]$.
	That is, it sum both added and removed components as described above.
	This criterion is defined in the Mancoosi optimisation format as \verb+-changedcomp+.
\end{defs}

These criteria define change as addition or removal of a component to or from the resulting solution, the fundamental alterations of the system during evolution.
These measurements may be an inaccurate representation of the risks of changing a system.
This is best seen with the example of updating a component, which involves removing a old version, and adding a newer version of a component with the same name.
By many users the act of updating is seen as less risky than removing a component, as shown in the survey presented earlier in this chapter,
though here it is measured as twice the value.
These simple criteria do not take into account the name of a component, which is seen as (and may indeed) have an impact on the risk of an evolution.

\subsubsection{Maximise Version}
%%%Maximise version, just sum up all versions and maximise their value
The problems with measuring the up-to-dateness of a component system (as described above), and this leads to difficulty in defining appropriate criteria.
The simplest criterion that can be defined to keep the system up to date, would be to simply maximise the sum of the versions.
This criteria is defined:

\begin{defs}
	The version criterion is defined to maximise the pseudo-Boolean function 
	represented by the set of pairs $[(x$.\verb+version+$,x) \mid x \in \mathbb{C}]$.
	That is, it maximises the sum of versions of components in the system.
	This criterion is defined in the Mancoosi optimisation format as \verb!+version!.
\end{defs}

This is only possible in the CUDF component model as the versions are integers, therefore easily added in the pseudo-Boolean function.
Other component model's versioning models may require to be converted into integers.

%%%Problem is some versions jump further, like av1, av10, av20, vs component cv1,cv2,cv3
The core issue with this criterion, is that different components can use a version model in different manners, making the summation of two different component versions meaningless.
For example, a component $a$ may version their components by factors of $10$, e.g. $a_{10},1_{20},a_{30}$, 
and another component $b$ may version their components by factors of $1$, e.g. $b_1,b_2,b_3$.
A situation may arise where a system can evolve to either include $a_20$ and $b_1$, or $a_10$ and $b_9$.
This criterion would select the former solution although $a_10$ is only one version out of date, and $b_1$ is eight versions out of date. 

Another problem with this criterion is that it optimises for large solutions where two older versions can be measured as better than a single newer version.
For example, a system with only the component $b_4$ is deemed less optimal that a system with both $b_2$ and $b_3$.

These problems make the use of this criterion very difficult, although it initially may seem a reasonable definition of a criterion.   


\subsection{Mancoosi Criteria}
The Mancoosi organisation for its MISC competitions (discussed in section \ref{impl.verif}) defined a set of criteria in order to compare different solvers.
Three types of criteria where defined, types that measure change, types that measure version, and an aggregating criteria. 

\subsubsection{Change}
The Mancoosi criteria use an abstraction of a component, a component name. 
As a component is defined as a name version pair ($\langle n,v \rangle$), a component name is just the name ($n$) element of the component. 
This means that the change of a system can be measured by the change of component names in the system.
The implications of such an abstraction are that updating a component will not add a component name to the system so can be ignored.
It also means that adding all versions of a component will not change the name, so such criteria must be used carefully.

%%%Initial constraints to define literals\
The first step that must be taken to include this criteria is to define literals that represent a component name.
In section \ref{impl.lexstrength} the function of \verb+initial-constraints+ was described to allow criteria to contribute constraints to the formula.
Such constraints let the criteria define literals to be able to optimise the solution.
Given all components with name $n$ are denoted as $a^n_1,\ldots,a^n_k$,
what is required is a literal $d_n$ such that iff any component $a^n_i$ is positive in a set of literals, then $d_n$ is positive.

This can be represented by the constraint $d_n \Leftrightarrow a^n_1 \vee \ldots \vee a^n_k$, which
is equivalent to $d_n \rightarrow a^n_1 \vee \ldots \vee a^n_k \bigwedge a^n_1 \vee \ldots \vee a^n_k \rightarrow d_n$.
The left term can create the CNF clause $\neg d_n \vee a^n_1 \vee \ldots \vee a^n_k$;
the right term is equal to $\neg(a^n_1 \vee \ldots \vee a^n_k) \vee d_n$,
through De Morgans laws $(\neg a^n_1 \wedge \ldots \wedge \neg a^n_k) \vee d_n$,
and through distributivity equals $\neg a^n_1 \vee d_n \bigwedge \ldots \bigwedge \neg a^n_k \vee d_n$.      
For every component name in the set of components, these clauses are added to the formula.

%%%removed and new

Given the set of all names $N$ and the function $Name$ which takes a set of literals and returns all names of components that are positive,
two criteria for minimising the newly added and removed names are defined.
\begin{defs}
The Mancoosi removed criterion is then defined using the pseudo-Boolean function
represented by the set of pairs $[(1,\neg d_n) \mid n \in N(l_1)]$.
This criterion is defined in the Mancoosi optimisation format as \verb+-removed+.
\end{defs}

\begin{defs}
The Mancoosi changed criterion is then defined using the pseudo-Boolean function
 represented by the set of pairs $[(1,d_n) \mid n \in N \wedge n \not \in N(l_1)]$.
This criterion is defined in the Mancoosi optimisation format as \verb+-new+.
\end{defs}

The last change based Mancoosi criterion to describe the component names that have changed.
This criterion minimises the amount of names that have had a component with that name either be removed or added.
For example, if a component of name $c$ is removed, and replaced with two components of name $c$, then this is only one component name changed.

To measure this change some constraints from the function \verb+initial-constraints+ must be defined.
What is required is a literal for each component name that is true if no literal of that component name is altered between solutions.
That is, given the name $n$, the previous solution $l_1$, and the literals $a^n_1, \ldots , a^n_k$ that are all literals with name $n$ (this includes negative literals);
the literal $h_n$ for a given name $n$ is defined to be true if no component of name $n$ changes from the initial system $l_1$.

That is $h_n \Leftrightarrow a^n_1 \wedge \ldots \wedge a^n_k$, 
which equals $h_n \rightarrow a^n_1 \wedge \ldots \wedge a^n_k \bigwedge a^n_1 \wedge \ldots \wedge a^n_k \rightarrow h_n$.
The left term equals $\neg h_n  \vee (a^n_1 \wedge \ldots \wedge a^n_k)$,
through distribution equals the CNF clauses $\neg h_n \vee a^n_1 \bigwedge \ldots \bigwedge \neg h_n \vee a^n_k$.
The right term equals $\neg(a^n_1 \wedge \ldots \wedge a^n_k) \vee h_n$,
which equals the CNF clause $\neg a^n_1 \vee \ldots \vee \neg a^n_k \vee h_n$.
For every component name, this set of constrains must be added to the formula in order for this criterion to function.

\begin{defs}
The Mancoosi changed criterion is then defined using the pseudo-Boolean function
that sums all literals $h_n$ that are negated in the changed system. 
This function is represented by the set of pairs $[(1,\neg h_n) \mid n \in N]$.
This criterion is defined in the Mancoosi optimisation format as \verb+-changed+.
\end{defs}

\subsubsection{Up-to-Date}
The criteria that Mancoosi defined in order to maximise the up-to-dateness of the system is the \verb+-notuptodate+ 
criterion that minimises the amount of component names that are included but do not have their newest version installed.

To define this criterion a variable is required that describes whether a name of a component is installed but it does not have the newest version installed.
For this, the component $b_n$ is defined as the highest version of the components of name $n$,
and the use of the variable $d_n$ defined previously to be positive iff a component with name $n$ is in the proposed system.

A set of constraints for the function \verb+initial-constraints+ are defined
such that a variable $u_n$ is positive if the name $n$ is in the system, and the component $b_n$ is not.
That is, $u_n \Leftrightarrow d_n \wedge \neg b_n$, which equals
$u_n \rightarrow d_n \wedge \neg b_n \bigwedge (d_n \wedge \neg b_n) \rightarrow u_n$.
The left term equals $\neg u_n \vee (d_n \wedge \neg b_n)$, 
which with distributivity equals the two CNF clauses $\neg u_n \vee d_n \bigwedge \neg u_n \vee \neg b_n$.
The right term equals $\neg (d_n \wedge \neg b_n) \vee u_n$,
which with De Morgans laws equals the CNF clause $\neg d_n \vee b_n \vee u_n$. 

\begin{defs}
The Mancoosi not up to date criterion is then defined using the pseudo-Boolean function
represented by the set of pairs $[(1,\neg u_n) \mid n \in N]$.
This criterion is defined in the Mancoosi optimisation format as \verb+-notuptodate+.
\end{defs}


This progressive criterion optimises a system to have as little not up to date components as possible.
This can result in some un-intuitive results.
For example, given a set of component versions $c_1$, $c_2$ and $c_3$, if $c_3$ is the highest verison a and is not installed in the system, 
this criteria does not consider the better version between $c_1$ and $c_2$.
Therefore, this criteria will not try to maximise the versions in the system, merely try to make sure the maximum version is installed.

\subsubsection{Sum}
The final Mancoosi defined criteria are functions that either minimises or maximises the sum of a property of the installed components. 
The property is left as a variable, and as long as each component has a value for that property the criteria can be used.

These are defined as:
\begin{defs}
The criterion to maximise a property $X$ is defined by the pseudo-Boolean function 
represented by the set of pairs $[(c.X, c) \mid c \in \mathbb{C}]$.
This criterion is defined in the Mancoosi optimisation format as \verb!+sum(!$X$\verb+)+.
\end{defs}

\begin{defs}
The criterion to minimise a property $X$ is defined by the pseudo-Boolean function 
represented by the set of pairs $[(c.X, c) \mid c \in \mathbb{C}]$.
This criterion is defined in the Mancoosi optimisation format as \verb+-sum(+$X$\verb+)+.
\end{defs}

The property $X$ is arbitrary though practically is must be defined in the CUDF document.
For example, the property $size$ that defines the size in kB of the component could be minimised with the criteria definition \verb+-sum(+$size$\verb+)+.
Using the expendable nature of the CUDF specification many various properties of a component could have can be represented and optimised for.
Some such properties that can be used, like PageRank or instability, are defined later in this section.

\subsubsection{Added, Removed, and Changed Properties}
Three further functions, added, removed, and changed, that are useful to define criteria are defined.
These were not defined in by the Mancoosi group, but they are similar to the definition of the sum functions, therefore are presented here..
The added criteria sums the values of a property added to a system, 
the removed criteria sums the properties removed from the system,
 and changed criteria sums the properties changed in the system. 
Each of these is used to define two criteria, to either maximise or to minimise the function.

\begin{defs}
The criterion to maximise the added value of a property $X$ is defined by the pseudo-Boolean function 
represented by the set of pairs $[(c.X, c) \mid c \in \mathbb{C} \wedge \neg c \in l_1]$.
This criterion is defined in the Mancoosi optimisation format as \verb!+added(!$X$\verb+)+.
\end{defs}

\begin{defs}
The criterion to minimise the added value of a property $X$ is defined by the pseudo-Boolean function 
represented by the set of pairs $[(c.X, c) \mid c \in \mathbb{C} \wedge \neg c \in l_1]$.
This criterion is defined in the Mancoosi optimisation format as \verb!-added(!$X$\verb+)+.
\end{defs}

\begin{defs}
The criterion to maximise the removed value of a property $X$ is defined by the pseudo-Boolean function 
represented by the set of pairs $[(c.X, \neg c) \mid c \in \mathbb{C} \wedge  c \in l_1]$.
This criterion is defined in the Mancoosi optimisation format as \verb!+removed(!$X$\verb+)+.
\end{defs}

\begin{defs}
The criterion to minimise the added value of a property $X$ is defined by the pseudo-Boolean function 
represented by the set of pairs $[(c.X, \neg c) \mid c \in \mathbb{C} \wedge c \in l_1]$.
This criterion is defined in the Mancoosi optimisation format as \verb!-removed(!$X$\verb+)+.
\end{defs}

\begin{defs}
The criterion to maximise the changed value of a property $X$ is defined by the pseudo-Boolean function 
represented by the set of pairs $[(c.X,\neg c) \mid c \in \mathbb{C} c \in l_1] \cup [(c.X,c) \mid c \in \mathbb{C} \neg c \in l_1]$.
This criterion is defined in the Mancoosi optimisation format as \verb!+changed(!$X$\verb+)+.
\end{defs}

\begin{defs}
The criterion to minimise the changed value of a property $X$ is defined by the pseudo-Boolean function 
represented by the set of pairs $[(c.X,\neg c) \mid c \in \mathbb{C} c \in l_1] \cup [(c.X,c) \mid c \in \mathbb{C} \neg c \in l_1]$.
This criterion is defined in the Mancoosi optimisation format as \verb!-changed(!$X$\verb+)+.
\end{defs}

These criteria, like the sum criteria, can be used in a versatile manner to optimise for various component properties.

\subsection{P2}
%%%Looking at the criteria from the P2 solver
Eclipse \textbf{P2} \citep{le_berre_dependency_2009,leBerre2010} is the provisioning system for the Eclipse IDE platform.
Its optimisation, as described in chapter \ref{background}, are focused on minimising the amount of components with no dependencies, the removal of components,
the age of the installed components, and changing components unnecessarily.
These are mapped to pseudo-Boolean functions that are then added together to create a single function \citep{leBerre2010}.
This differs from the lexicographic relationship that is defined through our optimisation framework.

Most of P2's criteria focus on minimising change within the system which is analogous to the definition given previously.
However, the criterion to minimise the age of a component is the most interesting as it provides a definition that removes many of the problems
discussed with the  \verb!+version! and \verb+-notuptodate+ criteria.

\begin{defs}
Given a sorted list of all components of the same name by versions $[a_n,\ldots,a_0]$, where $a_0$ is the least version, and $a_n$ is the highest version,
the function $age$ is then defined to take a component and return its index from this list.
The criterion is then defined to minimise the function represented by the set of pairs $[(age(x), x) \mid x \in \mathbb{C}]$.
This criterion is defined in the Mancoosi optimisation format as \verb!-uptodateage+!.
\end{defs}

This age metric, eliminates the problem with the criteria, where versions can be dependent on a components versioning model.
This is done by creating a relative measure of what version of a component is, which is the number of newer components that exist.
This allows this method to compare components that version differently to determine the up-to-dateness of a system.
However, this criteria can still be mislead by different components.
For example, if a component constantly releases versions, with little changes or no changes, the age of a component can quickly force an update, 
although their may be little risk of not upgrading. 


\subsection{Dependency Based Criteria}
A components dependence on another component creates a tangible connection that should be considered when evolving a system.
This connection can be seen as a form of trust, given a developer selects the components to have their components depend on,
or as a measure of importance to a system, as a component that is highly depended on has more responsibility to the system.
Such metrics of a component could be considered when making the choice to either remove or add a component to a system.

Many such metrics are based on dependency graph analysis, that is the study of the graph caused by the dependency relationships between components. 
To use such metrics, the structure of component dependencies must be abstracted to a directed graph $G = (V,E)$;
such that the vertices $V$ are a set of components from $\mathbb{C}$, 
and the edges are created from the dependency rules where $(a,b) \in E$ iff there is a dependency constraint in $R$ 
where $a \rightarrow c_1 \vee \ldots \vee c_n$ where $b = c_i$ for some $i$.

%%%What set of components is used to create the graph
The set of components used to create this dependency graph is defined as the set of all components.
This implies that given the set of all components does not change, the following metrics presented will be invariable.
That is, the dependency graph that is referred to is not created with a subset of components, such as the previous system.
Using all components has one significant practical benefit, it makes recalculations of metrics unnecessary.
If each metric was calculated with respect to the graph of the previous solution, 
it would require that each problem using the same set of components recalculate possibly expensive metrics to be used in optimisation.

%%%Metrics that return Real Numbers not integers for Pseudo Boolean function, must be scaled by multiplication and truncation.
Another aspect of note is that some of the presented metrics return real numbers not integers which are required for pseudo-Boolean functions.
This is solved by scaling the values of these metrics by multiplying with a large number and then rounding the result to an integer.
The selection of this large integer, is made per metric, and is selected to provide the required resolution to make the metric useful.

\subsubsection{Martin Metrics}
The first metric that is defined is based on the ``instability'' metric presented in \citep{martin2003}.
This metric was created to measure the a components resistance to change using the incoming and outgoing edges of a package.

\begin{defs}
The number of components that depend on a component, the incoming edges of a node in a dependency graph, is described as the afferent couplings, denoted as $Ca$.
The number of components that a component depends on, the outgoing edges of a node in a dependency graph, is described as the efferent couplings, denoted as $Ce$. 
The instability of a component is then the ratio of efferent couplings to to total couplings, that is $Ce/(Ce+Ca)$.
\end{defs}

This metric could be said to measure the unimportance of a component, or the relative safety of changing a component.
For example, given a component $a$ depends on no other components and has three other components depending on it, $a$'s ``instability'' would be $0$.
The component $a$ is then important and also may be a risk to change in the system, as it may effect components that depend upon it.
This is opposed to a component $b$ that is not depended upon by any components but depends on three other components, $b$'s ``instability'' would be $1$.
That is to say that is is unimportant to other components, but has little to no risk when changing as any change will only effect itself.

This criteria can then be used by a conservative user to minimise the risk of a change by minimising the removed stability,
that is by maximising the removed instability.
Given the instability of a component is assigned to the property \verb+instability+,
the removed instability can be maximised with the criteria \verb!+removed(instability)!.

\subsubsection{PageRank}
The measurement of the instability of a component only takes into consideration other components that are directly connected to it.
Such a metric, does not take into consideration the entire structure of a graph, therefore can give only local information about a component.

PageRank, presented in \citep{page1998}, is a link analysis algorithm designed to measure the importance of a node in a directed graph.
This algorithm, originally designed to rank the popularity of web pages in returned results from a search engine.
It can also be used over a dependency graph to measure a components relative importance.
It propagates values though the graph, meaning that the importance of a component will depend on importance of components that do not directly upon it. 

This PageRank function is defined;
Given a node in a graph $a$, the function $PR(a)$ returns the PageRank of $a$, 
the function $L(a)$ returns the number of outbound links from $a$, 
and the function $I(a)$ returns the set of nodes with edges incoming to $a$.
The PageRank of a node $a$ is then $PR(a) = 1-d + d\sum\limits_{v \in I(a)} \frac{PR(v)}{L(v)}$,
where $d$ is the damping factor (typically set to $.85$).
Also to note, a node that has no outbound edges, i.e. $L(a) = 0$, is assumed to link to all nodes (including itself) in the graph.
This function is iteratively applied and normalised so the sum of all PageRanks equals $1$, until it stabilises.
The specific implementation used to calculate PageRank is from the library networkx\footnote{http://networkx.lanl.gov/ accessed 6/3/2012}.

Like the instability metric, the PageRank of a component represents the risk of changing a component.
The higher the PageRank, the more depended upon it could be in a given system.
If given the choice in the system between removing a component that is highly depended upon, or one that is less so,
the clear choice would be removing the latter as it will potentially effect less of the other components in the system.
Therefore given the PageRank a component is assigned to the property \verb+pagerank+, the criteria to minimise the removed PageRank is defined as \verb!-removed(pagerank)!.


\subsubsection{HITS}
The HITS algorithm, like PageRank, is a link analysis algorithm that returns two metrics for each component, hubs and authority measures.
The hub metric measures the amount a component depends on authorities, and the authorities measures the amount it is depended on by hubs.

This recursive definition can be defined:
given the function $auth(a)$ returns the authority metric of node $a$, $hub(a)$ returns the hub metric of node $a$,
$I(a)$ returns the set of nodes with edges incoming to $a$, and $O(a)$ returns the set of nodes with edges outgoing from $a$;
$auth(a) = \sum \limits_{i \in I(a)} hub(i)$ and  $hub(a) = \sum \limits_{i \in O(a)} auth(i)$.
To calculate these values, they are itertivly applied till they stabalise.
The specific implementation used to calculate HITs values is from the library networkx\footnote{http://networkx.lanl.gov/ accessed 6/3/2012}.

The authority metric this is similar to the PageRank and instability metrics, in that it can be used as a measure of risk in changing a component.
Removing a component that has a high authority may increase the risk of change in the system.
Therefore, given the authority measure is assigned to property \verb+auth+, the criteria to minimise the removed authority is defined as \verb!-removed(auth)!.

\subsection{Other Criteria}
There are many other types of criteria that can be considered when judging the optimality of a solution.
Criteria that maybe component model dependent, that use properties located in component meta-data (e.g., size, vendor and licence),
generated through component contracts and composition testing (e.g., reliability and speed),
or community sourced meta-data stored in repositories (e.g., popularity) could be used through optimisation.

%%%Discuss information from component met-data
Component meta-data such as the examples presented in the chapter \ref{background}, can be an ample source of information when evolving a system.
Users may have preferences on any range of contained information that could be extracted, such as licence agreements, developers, vendors,
or other more specific information like date of release or certification.
This information may effect the desirability of a system, therefore could be considered. 
For example, there are many users of systems that have a preference for open source software, 
which can be released under licences like the GNU General Public Licence\footnote{http://www.gnu.org/copyleft/gpl.html accessed 6/3/2012} (GPL).
This preference could come from the moral decision that freed software is better or from some business rule stating that GPL licences conform to a business model.
Therefore, a component that has such a licence is preferred over one that does not.
Allowing the specification of such criteria may allow more users to evolve systems to be more suited to their needs.

%%%Discuss information from component testing (e.g. treaty, unit tests)
The functional testing of components, through predefined test cases or component contracts, may allow for functional and non-functional metrics to be included optimised.
Some components make public test suites that are used in order to show the process by which they are developed,
such test suites could be used to compare versions of the same component, or competing component with the same functionality in order to select the best component.
Implemented component contracts, which verify the interaction between components, could also be used with different components in order to select the correct one. 
For example, given a test suite has been developed to test spell checkers, 
this suite could be run against various spell checker components and the number of passed tests and the time it took to pass them measured.
Then a criteria could be developed in order to select the spell checker that passed the most tests, then took the least average time.

%%%Discuss community stored information, e.g. app-install-data, reccommendation systems, community forums\ldots
Community efforts to rank and review different components could also be used in order to optimise evolution.
Many such communities already exist that discuss and rate components, they provide a unique source of information that the user may use to evolve their system.
For example, the Ubuntu popularity contest\footnote{http://popcon.ubuntu.com/ accessed 6/3/2012} is an automated survey that collects information from the community to find popular components.
If such information was used, more popular components could be installed with the assumption they are more developed and maintained.

%%%Why have we not defined such criteria
There are two core reasons why these types of criteria have not been fully defined in this chapter,
they are difficult to implement, and they may be impossible to validate within the scope of this research.
The discussed criteria in this chapter may require large amount of effort, including coding, testing and specification to implement them.
Even if this i accomplished, the scope of this defined project, which does not deal with the specific implementation details of a component model,
may make the validation of such criteria difficult or impossible.
Therefore, these criteria may be used and be useful in the future, but in this project are not further defined.

\subsection{Criteria Composition}
The composition of criteria, the way in which they are lexicographically related through the Mancoosi optimisation format,
will effect the selected solution.
Each different action that a user can take, e.g. add a component, remove a component or upgrade a component, may have a different composition of criteria to optimise its evolutionary step.

Defining such compositions must be carefully accomplished as sometimes intuitively correct criteria may result in unforeseen complications.
For example, when defining the criteria to optimise the upgrade action a users goals may be to minimise the changed components during the upgrade.
With the composition \verb+-changedcomp,-uptodateage+, the system may never upgrade anything, as the upgrade command (as defined in CUDF) does not require any component to change.
Another example would be to set the install instructions to minimise the size of installed components then minimise change,
e.g. \verb!-sum(size),-changedcomp!, this may remove much of the system as the size of most components is above zero.

How the criteria are ordered, is just as important as the criteria selected, and he consequences of incorrectly defining a composition can be significant.

\section{Summary}
In this chapter the strategies a user may employ in order to evolve their component systems were discussed.
These strategies, first elicited from a survey given to users of component systems, are defined into two sterotypes, progressive and conservative.
Both of these sterotypes are defined given some risk to the system, progressive users are more concerned with the risk of being not up-to-date,
and conservative users are more concerned with the risk of change to the system.
Criteria where defined that express these risks, and can be used to optimise the evolution of component systems.
Each criterion is defined using a pseudo-Boolean function, that can be used in the algorithms provided in the previous chapter to select systems that reflect the users goals.
In the following chapters, a simulation is defined to imitate the evolution of a system.
This will enable the testing and validation of these strategies and criteria, to find if the users goals are achieved through their use. 
