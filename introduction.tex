\chapter{Introduction}
\label{introduction}
\epigraph{E pluribus unum -- Latin for "Out of many, one"}
{\textit{de facto motto of the United States 1782 - 1956}}

%%%The start of this thesis leads the reader to the idea that when building a complex system, breaking the probelm into parts is a natural and beneficial instinct
When confronted with building a complex system, an analytical person's first instinct is often to break the system into smaller, simpler components. 
These components can be defined by their contribution to the whole system and their relationships to other components.
Through such a ``divide and conquer'' method, the design and construction of a complex system becomes a manageable task.

%%%The metaphor of building a car to explain breaking systems into components
This method of breaking a system into smaller components has been used numerous times to construct complex systems.
For example, to manufacture a car it is broken into parts for design and assembly.
Such a complex system that is manufactured by breaking it into parts for design and construction.
It requires a body, electrical system, interior, suspension, steering, engine \ldots. 
The engine can be further broken into other parts like cooling, oil system, exhaust, intake, fuel, carburettor and so on.
Each of these parts can be defined by their provided function to the engine, and their relationships to other engine components.
For instance, the \textit{carburettor} is the fuel delivery system that blends the air from the \textit{intake} with petrol from the \textit{fuel system}.

%%%Software is complex and components can be used to manage their complexity.
Software systems are also complex as they have many intricate, and interrelated parts, that when combined should provide a function.
An objective of software engineering is to manage this complexity through various techniques like the hierarchical decomposition of object orientation \citep{goldberg1983smalltalk}, 
the decoupling of relationships through dependency inversion \citep{martin1996dependency}, 
separation of concerns through aspect-oriented programming \citep{Kiczales1997},
and the abstraction of knowledge through model driven engineering \citep{schmidt2006}. 
Another such method to manage the complexity of software is to break the system apart into independent units of composition called \textbf{software components} \citep{Szyperski2002}. 

%%%What are Software components, why use software components
The exactly what software components are is still in dispute (as further discussed in chapter \ref{background}),
though the one characterisation that is agreed upon ``software components are able to be composed''.
What else is agreed is that software components are composed together using a set of rules, known as the \textbf{component model}.
This component model is the core difference between other modularisation techniques as it constrains how component systems are built.

The key arguments for developers to construct a system using software components are enumerated in \citep{Szyperski2000} as:
\begin{enumerate}
	\item \textit{Extensibility}: a software system allowing the future addition of functionality
	\item \textit{Evolvability}: changing a software system to reflect a changing environment
\end{enumerate}

%%%This research is looking at the key arguments of evolvability and extensibility through software evolution
Extensibility and evolvability of component software come from the understanding that a system must change over time to be maintained, enhanced or fixed.
The easier it is to adapt a system to a user's needs, the more satisfied a user will be with that system.
Software extensibility, evolvability and maintenance can be put under the category of \textit{software evolution} \citep{lehman1980}, which is the repeated alteration of software after deployment.
Looking at component systems through the lens of software evolution is the focus of this thesis.

\section{Evolution}
%%%Biological evolution to software evolution
In biology the process of evolution is the change that occurs to life forms over generations through natural selection and mutation.
The evolution of organisms is constrained and guided by the environment in which they live.
This evolution is chaotic and disorganised.
Like organisms, software evolves and changes overtime that reveals emergent properties.
Researchers have further compared organic systems and their evolution in research present in \citep{Myers2003} and \citep{Yan2010}.
Versions are the generations of software, these are mutated through the developers alterations to code.
The environment that molds software is created through the user's and developer's requirements and constraints.

%%%Software evolution, Lehman
The fundamental investigations into the process of software evolution are presented by \citep{lehman1980}.
This empirical research shows that all software systems (above a certain complexity) must evolve to maintain user satisfaction.
It also shows the consequences of such evolution, like the increasing complexity and decreasing quality of the system over time.

%%%Software evolution to Component system evolution
The typical software evolution process is enacted by the developer.
How to change the system, when to change the system, and the order in which to change the system are all decided by the developer.
This typical evolution process is different from the evolution of component systems, 
where the user alters their system through a set of defined actions using a set of pre-developed components.
A user can install, remove or upgrade a component from a repository of provided components, without direct interaction with the developer.
This is evolution not directed by the developer, but by the user. 

%%%Terms
This user initiated evolution of component systems is the specific focus of this thesis, and is described with the term \textbf{component system evolution}.
This is opposed to the evolution of an individual component, described as \textbf{component evolution} whose properties are explored in \citep{vasa2007patterns} and \citep{Stuckenholz2005}.
The situation where a user requests an action to evolve their system is described as an \textbf{evolution problem} whose solution is the resulting system when that action is completed.
This evolution problem has been explored in research such as \citep{Ryan2005}, \citep{argelich2010solving} and \citep{di2010supporting}.
The emergent effects of evolving a component system by solving multiple evolution problems has not been explored as thoroughly.
Therefore, this research aims to investigate the process of component system evolution by searching for the rules or laws that govern it.

\subsection{Strategies}
%%%What is a strategy
The guiding plan that a user employs to evolve their system is described as their \textbf{strategy}.
In game theory \citep{rubinstein1991comments}, a strategy is a player's plan of action that determines behaviour, typically chosen to produce a desirable outcome.
In component system evolution, a strategy is the user's plan to maintain their satisfaction with the system through software evolution.

%%%A strategy includes\ldots
A strategy defines the actions that a user takes to evolve their system.
A strategy therefore selects when to evolve their system, what actions to use, how to select between multiple solutions, and many other behaviours.

%%%What is satisfaction
Strategies can differ between users depending on their systems objectives, and the user's perception of risk \citep{iso2009}.
The evolution of a system is often weighed against the risk of change or the risk of not changing.
Changing a system can introduce unknown errors, and not changing can let old errors linger. 
A strategy must take both the objectives and risk into account in order to satisfy the user.

%%%How to measure an effective strategy
The effectiveness of a strategy can be measured by comparing it to the satisfaction the user.
The user is satisfied if their objectives for the system are attained.
A strategy is defined with incomplete information because of the complex nature caused by the interaction between the system, developers, users and components.
Therefore the user must approximate their strategy using heuristics and half measures.
For example, if an objective of the system is to be small, and the user's strategy to accomplish this is to install every component, it can be said that this is a bad strategy. 
However, a strategy where the user attempts to remove unnecessary components and install new components sparingly would satisfy the user more and said to be better.

\subsection{Automation}
%%%The problem is difficult
In practise, a user rarely directly selects the components to add or remove from when evolving their system.
This is because any evolution action may involve many components, where each component can have multiple relationships to other components.
This makes many evolution problems complex to solve and satisfactory solutions difficult to find.

Often, an algorithm can be defined in order to find solutions to evolution problems.
This algorithm requires that components in the system explicitly state the relationships between one another, and there is a way to automatically manipulate the component system.
As many solutions may exist for an evolution problem, to find the best solution the user's strategy must be taken into account.
It must also consider practical concerns like time to find a solution, as the problem can be quite complex.
In this research such an algorithm is called \textbf{component dependency resolution} or \textbf{CDR}.

CDR takes a single evolutionary problem and attempts to return an evolved system given the user's strategy.
Over time, as the user requests many actions to evolve the system, the component system will resemble less and less the original system.
The way in which such a system evolves over time given the strategies the user employs has yet to be explored. 

\section{Research Goals}
The core themes of this thesis are component system evolution, user strategies and CDR.
The selected method to explore these themes is through the simulation of the environment in which component evolution occurs.
Various user strategies can be compared through altering the variables of the simulation and comparing their output.
The main research goal is then to:
\begin{quote}
Model component system evolution strategies and assess them using a simulation that has been developed.
\end{quote}

This goals leads to various lines of inquiry including component system evolution, component dependency resolution, user strategies, and the simulation of component system evolution.

The research questions related to component system evolution (and the chapters they are answered in) are:
\begin{itemize}
	\item What is the current state of component system evolution?; chapter \ref{background}
	\item What is required of a component model to allow for component system evolution?; chapter \ref{background}
	\item How can the evolution of a component system be formally defined?; chapter \ref{formal}
\end{itemize}

The research questions related to component dependency resolution are:
\begin{itemize}
  \item What algorithms can be used to implement CDR?; chapter \ref{implementation}
  \item How can a CDR implementation be validated?; chapter \ref{implementation}
\end{itemize}

The research questions related to user strategies are: 
\begin{itemize}
	\item How can a user strategies be optimised for in CDR?; chapter \ref{implementation}
	\item What general objectives are user strategies?;  chapter \ref{strategies}
	\item What criteria can be used in user strategies?; chapter \ref{strategies}
\end{itemize}

The research questions related to the simulation of component system evolution are: 
\begin{itemize}
	\item What is the method used to create a valid and verified simulation?;  chapter \ref{simulation}
	\item How can a simulation be implemented?;  chapter \ref{ubunutsimulation}
	\item What are the best strategies to be used given the objectives of a user?;  chapter \ref{ubunutsimulation}
\end{itemize}

\section{Contributions}
%%%TODO incite the user to read on and note when something important is described by giving a brief list of contributions

\section{Thesis Overview}
%%%A list and breif explination of each of the chapters and how they relate to our Research Goals
Towards the research goal, this thesis starts with an exploration of the background of software evolution and component based systems in chapter \ref{background}.
This chapter also attempts to give a suitable definition of what a software component is, and then examines different component models that fit such a definition.
Other concepts such as user strategies, software evolution and component system evolution are described in this chapter.

There are two core aspects of any component system evolution problem; 
finding a solution to an evolution problem, and finding an optimal solution to an evolution problem.
These two related problems are modeled in this research and this models syntax, semantics and implementation are each described.

In chapter \ref{formal} the modeled formal semantics of component evolution problem is defined using a set of constraints that ensure the resulting system satisfies the user's requested action.
The optimisation of this evolution problem is defined as a multi-criteria framework of lexicographically composed ranking systems over complete lattices.
The complexities of both these problems are discussed as they will impact the implementation of any algorithm required.

To syntactically represent the evolution problem and its optimisation the Common Upgradeability Description Format (CUDF) \citep{treinen2009common} and the Mancoosi Optimisation Format (MOF) are used.
These are both defined by the Mancoosi research project for use in the Mancoosi International Solver Competition (MISC), 
which was created to compare alternate CDR implementations.
Their syntax and their relation to the semantic definitions of the problem are also described.

The CDR implementation that takes an evolution problem (defined with CUDF) and a user strategy's criteria (defined in MOF) and finds a solution, is described in chapter \ref{implementation}.
This CDR implementation is based on a Boolean satisfiability (SAT) solver, 
whose optimisation is represented as a pseudo-Boolean optimisation problem which uses an algorithm called iterative strengthening to find solution.
The presented CDR implementation is validated by entering it into MISC where it was competed and compared against other solvers.

The various strategies and criteria that a user can employ are described in chapter \ref{strategies}.
An online survey was conducted over a targeted group of users to find what strategies they employ to evolve their systems.
These strategies where grouped into two stereotypes based on risk.
Progressive strategies attempt to minimise the risk of a system being out-of-date while conservative strategies try to minimise the risk of change to the system.
An assorted set of criteria is then presented and defined as pseudo-Boolean functions.
Each criteria is discussed for its positive and negative attributes that may effect evolution.

A simulation of component evolution is the selected method to explore the evolution of component systems.
This simulation is defined in chapter \ref{simulation} using a method presented in \citep{Law2005} to create a valid and credible simulation.
Firstly, the process by which simulation was selected is described and compared to using real systems or using a controlled environment.
Then the methodology is described; it involves creating a conceptual model that describes the aspects of reality which are to be simulated.
The validation of this simulation is accomplished through stakeholder meetings, and through the user survey.

Chapter \ref{ubunutsimulation} discusses the implementation of the simulation using the Debian component model \citep{Barth2005} with Ubuntu \citep{Hill2006} components. 
This simulation is used to study various evolution strategies and measure their effectiveness.
The assignment of variables in the conceptual model and the validation of this simulation are discussed.
The analysis of this simulation is accomplished through asking questions of interest like ``what are the consequences of using criteria from current CDR implementations?''.
The answers to these questions illuminate the consequences of evolving a component system using different strategies.

The concluding chapter (\ref{conclusion}) discusses the contributions of this research to component based software engineering and software evolution domains.
It also explores related research that parallels and intersects the research presented in this study.
This thesis concludes with potential future lines of research that can further contribute to the component system evolution domain. 