%%This is a very basic article template.
%%There is just one section and two subsections.
\documentclass{report}

\title{Component Dependency Resolution}

\begin{document}

\chapter{Introduction}


\begin{quotation}
\textbf{Man}: When you take apart a Lego house and mix the pieces into the bin, where does the house go?\\
\textbf{Woman}: It's in the bin.\\
\textbf{Man}: No, those are just pieces. They could become spaceships or trains. 
The house was just an arrangement. The arrangement doesn't stay with the pieces and it doesn't go anywhere else. It's just gone\\
--XKCD Lego
\end{quotation}

%%%The introduction leads to the idea that when building a complex system, breaking the probelm into parts is a natural instinct\\
{}When confronted with building a complex system, our first instinct in an attempt to construct the system is often to break it into smaller, simpler components. 
{}These components are defined by their goals in the overall system and their relationships to other components.
{}Through this ``divide and conquer'' method, the design and construction of a complex system is broken down into a manageable problems to solve.

%%%We use the metaphor of building a car to explain the benefits of breaking systems into components
When building a complex system like a car, you would not attempt to build the car as a whole, but break it into parts for design and construction.
A car requires a body, electrical system, interior, suspension and steering, engine \ldots. 
The engine can be further broken into other parts like cooling, oil system, exhaust and intake systems, fuel, and so on.
Each of these parts have relationships that lead to complex dependencies, for instance the carburettor blends the air from the intake with petrol from the fuel system.

%%%Generally we break apart systems for the benefits gained during design, implementation, maintenance and evolution. 
The benefits of breaking a system apart are gained through the entire product process; design, implementation, deployment, maintenance and evolution.

%%%During Design; planning (better plan the build), understanding the overall structure ("big picture"), 

%%%During implementation; specialization of people to tasks, concurent development, testing each part separtly

%%%During maintenance with well defined interactions a part can be replace without side effects, 
%%%or a problem can be detected and solved given its location in the system 
The apocryphal story of George Washington's axe which has three times had its handle replaces and twice its head replaced deomstrates the power of maintence on a system of parts.

%%%During Evolution, replacing an inferior part with a superior part can be accomplished as long as it fits the required specifications,
%%%extra parts can be added to improve and add functionality along with specifications

\section{Software Components}
{}The use of components in software systems has additional benefits over their use in physical systems.
{}Software components can be reused in different contexts, replaced ``on the fly" without interruption to the system, validated for correctness, 
{}and automatically building or modifying a system through resolving their defined dependencies.

%%%A software component can provide its services to many other components all for different purposes.
In a physical car there are pumps which accomplish many different tasks, pumping oil, air, water.
In a software system such replication is unnecessary as a single component could provide a service that pumps, 
and other components can use this service for many different purposes.
A software component, not bound by physical limitations, can be in many places at once, doing many similar jobs simultaneously.
A component providing a http server can be used for web site hosting, communication, internal and external web-sites, REST and SOAP communication.
This is done all by the same component, as the abstraction of the http service is broad enough to accomplish many tasks.

%%%Being able to change components while running the system is difficult but possible in software systems.
Replacing a tire or repairing a windshield while continuing to drive the car is at the very least difficult, if not impossible.
Inside a software system, where changes in state are accomplished so quickly that they are unperceivable, the replacement of parts of a system are easily accomplished while the system is running.

%%%Given the software component relationships are well defined, with contracts and requirements a system or component can be validated to be correct before use
If an enthusiast adds a turbo to a car, it may not work correctly in that context, it may create too much pressure and blow the engine.
A component can have complex mechanisms like contracts or strictly defined specifications to automatically detect these incompatibilities before they cause problems.

%%%Given the relationships in a software component system are strictly defined, we can use these to then find valid combinations given user requirements
Imagine being able to define the car you want by describing the functionality you require, and then a custom car, one that may exist no where else in the world,
is automatically built for you. 
While then driving this car your requirements change, you want to drive off road, then the car changes parts to adapt to your new requirements, new tires, engine, gearbox\ldots
This is the power that dependency resolution offers component systems, automatic resolution of a users requirements.

\section{Research Goals}
{}The aspect of the vast research areas of software components we will look at throughout this thesis is the final point made in the previous section, 
{}the automatic composition of software components through resolving component dependencies.
{}Specifically we will look at the requirements necessary for a component model to provide dependency resolution,
{}how to implement such functionality, the criteria that it must consider, and finally the effects that using dependency resolution (with different criteria) has on a system. 

%%%The requirements a component model needs to provide dependency resolution at design time, and at runtime, explicit requirements

%%%The implementation of component resolution, how it is a NP-Complete constraint problem

%%%The criteria that make Dependency resolution from a NP-Complete to NP-Hard constraint problem


\section{Overview of Thesis}
%%%This section just has an outline, and brief description of each of the chapters.

\input{background}

\input{cdr}

\input{implementation}

\input{investigations}

\input{criteria}

\input{simulation}

\input{conclusion}

\input{appendix}


\end{document}
