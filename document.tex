%%This is a very basic article template.
%%There is just one section and two subsections.
\documentclass{report}

\title{Component Dependency Resolution}

\begin{document}

\chapter{Introduction}


\begin{quotation}
\textbf{Man}: When you take apart a Lego house and mix the pieces into the bin, where does the house go?\\
\textbf{Woman}: It's in the bin.\\
\textbf{Man}: No, those are just pieces. They could become spaceships or trains. 
The house was just an arrangement. The arrangement doesn't stay with the pieces and it doesn't go anywhere else. It's just gone\\
--XKCD Lego
\end{quotation}

%%%The introduction leads to the idea that when building a complex system, breaking the probelm into parts is a natural instinct
{}When confronted with building a complex system, our first instinct in an attempt to understand and build the system is often to break it into smaller, simpler components. 
{}These components are defined by their goals in the overall system and their relationships to other components.
{}Through this ``divide and conquer'' method, the design and construction of a complex system is broken down into a manageable problems to solve.

%%%We use the metaphor of building a car to explain the benefits of breaking systems into components
When building a complex system like a car, you would not attempt to build the car as a whole, but break it into parts for design and construction.
A car requires a body, electrical system, interior, suspension and steering, engine \ldots. 
The engine can be further broken into other parts like cooling, oil system, exhaust and intake systems, fuel, and so on.
Each of these parts have relationships that lead to complex dependencies, for instance the carburetor blends the air from the intake with petrol from the fuel system.

%%%Generally we break apart systems for the benefits gained during design, implementation, maintenance and evolution. 
The benefits of breaking a system apart are gained through the entire product process; design, implementation, deployment, maintenance and evolution.

%%%During Design, planning, understanding the big picture,

%%%During implementation, specialization, concurent development, testing each part separtly

%%%During maintenance with well defined interactions a part can be replace without side effects, 
%%%or a problem can be detected and solved given its location in the system 
The apocryphal story of George Washington's axe which has three times had its handle replaces and twice its head replaced deomstrates the power of maintence on a system of parts.

%%%During Evolution, replacing an inferrior part with a superior part can be accomplished as long as it fits the required specifications

\section{Software Components}
{}There are more reasons for the use of components in software systems, additional benifits over their use in physical systems.
{}Software components can be reused, replaced ``on the fly" without interruption to the system, validated for correctness, 
{}and automatically building or modifying a system through resolving their defined dependencies.

%%%The reuse of services supplied by software components is a key driving force for use
In a physical car there are pumps which accomplish many different tasks, in a software system such replication is uneccesary so a single component can provide the servie to pump.

%%%Being able to change components while running the system is difficult but possible in software systems.
Replacing a tire or repairing a windshield while continueing to drive the car is impossible, but inside a software system it can be done.

%%%Given the software component relationsships are well defined, with contracts and requirements a system or component can be validated to be correct before use
If an enthusiast adds a turbo to a car, it may not work correctly in that context, it may create too much pressure and blow the engine.
A component can have complex mechanisms like contracts or strictly defined specifications to automatically detect these problems.

%%%Given the relationships in a software component system are strictly defined, we can use these to then find valid combinations given user requirements
Imagine being able to define the car you want by describing the functionality you require, and then a custom car, one that may exist no where else in the world,
is automatically built for you. 
While then driving this car your requirements change, then the car changes parts to adapt to your new requirements.
This is the power that dependency resolution offers component systems, automatic resolution of a users requirements.

\section{Research Goals}
{}The part of this vast research area we look at is the final point made in the previous section, 
{}the automatic composition of parts through resolving component dependencies and it's effects on a component system.


\section{Overview of Thesis}
%%%%This section just has an outline, and breif description of each of the chapters.


\input{background}

\input{cdr}

\input{criteria}


\section{Common Upgradeability Description Format}

\section{Ubuntu Component Model Mapping to CUDF}

\section{OSGi Component Model}
\subsection{Mapping to CUDF}

\section{Comparison}

\chapter{Investigations}

\section{Search Space Size}
%How big a search space are we looking at here

\section{SAT Optimisation}
%What is necessary in SAT
\subsection{Literal Order}
\subsection{Learning Choices}

\input{simulation}


\chapter{Conclusion}
\section{Related Work}
\section{Future Work}

\section{Glossary}
Composer: The user who creates or alters component systems (compositions)

Versioning Model: A method to define and compare versions
\end{document}
