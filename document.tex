%%This is a very basic article template.
%%There is just one section and two subsections.
\documentclass{report}

\title{Component Dependency Resolution}

\begin{document}

\chapter{Introduction}


\begin{quotation}
\textbf{Man}: When you take apart a Lego house and mix the pieces into the bin, where does the house go?\\
\textbf{Woman}: It's in the bin.\\
\textbf{Man}: No, those are just pieces. They could become spaceships or trains. 
The house was just an arrangement. The arrangement doesn't stay with the pieces and it doesn't go anywhere else. It's just gone\\
--XKCD Lego
\end{quotation}

%%%The introduction leads to the idea that when building a complex system, breaking the probelm into parts is a natural instinct
{}When confronted with building a complex system, our first instinct in an attempt to understand and build the system is often to break it into smaller, simpler components. 
{}These components are defined by their goals in the overall system and their relationships to other components.
{}Through this ``divide and conquer'' method, the design and construction of a complex system is broken down into a manageable problems to solve.

%%%We use the metaphor of building a car to explain the benefits of breaking systems into components
When building a complex system like a car, you would not attempt to build the car as a whole, but break it into parts for design and construction.
A car requires a body, electrical system, interior, suspension and steering, engine \ldots. 
The engine can be further broken into other parts like cooling, oil system, exhaust and intake systems, fuel, and so on.
Each of these parts have relationships that lead to complex dependencies, for instance the carburetor blends the air from the intake with petrol from the fuel system.

%%%Generally we break apart systems for understanding, specialization, maintenance, extension, problem detection, and concurrent development.
The are many reasons for breaking these systems apart, including understanding, specialization, maintenance, problem detection, and concurrent development.

%%%Understanding a system working as a whole allows us to convey information that may otherwise be difficult to grasp

%%%Specialization allows individual people to focus on their proficiencies when building a part of the system.
It allows specialization, by splitting the system into parts experts in those parts can focus on their own domain and only have to know how it interacts with other parts.

%%%The ability to maintain the system is increased as individual parts can be removed and replaced without changing the rest 
The apocryphal story of George Washington's axe which has three times had its handle replaces and twice its head replaced deomstrates the power of maintence on a system of parts.

%%%Being able to extend a system by adding new parts, as it will only effect the local parts of the system

%%%If a system has well defined relationships in it, detecting a problem and finding where it occurs is a much easier task

%%%Concurrent development allows different parts of the system to be developed and constructed simitaneously lowering time for development.

\section{Software Components}
%%%There are more reasons for the use of components in software systems, additional benifits.
%%%Software components can be reused, replaced ``on the fly" without interruption to the system, validated for correctness, 
%%%and automatically building or modifying a system through dependency resolution.
Component Software consolidates code into units

%%%The reuse of services supplied by software components is a key driving force for use
In a physical car there are pumps which accomplish many different tasks, in a software system such replication is uneccesary so a single component can provide the servie to pump.

%%%Being able to change components while running the system is difficult but possible in software systems.
Replacing a tire or repairing a windshield while continueing to drive the car is impossible, but inside a software system it can be done.

%%%Given the software component relationsships are well defined, with contracts and requirements a system or component can be validated to be correct before use
If an enthusiast adds a turbo to a car, it may not work correctly in that context, it may create too much pressure and blow the engine.
A component can have complex mechanisms like contracts or strictly defined specifications to automatically detect these problems.

%%%Given the relationships in a software component system are strictly defined, we can use these to then find valid combinations given user requirements
Imagine being able to define the car you want by describing the functionality you require, and then a custom car, one that may exist no where else in the world,
is automatically built for you. 
While then driving this car your requirements change, then the car changes parts to adapt to your new requirements.
This is the power that dependency resolution offers component systems, automatic resolution of a users requirements.

\section{Research Goals}
%%%Our research is in the area of dependency resolution, the finding valid systems, more specifically on the impact of its use during system evolution



\section{Overview of Thesis}
First Background,
Then define what a component is based on literature and examples


\input{background}

\input{cdr}

\input{criteria}






%Lexicographic operator

%formal Definition with Optimisation constraints
\section{CUDF}

\section{CUDF Mapping}



\chapter{Component Models}

\section{Common Upgradeability Description Format}

\section{Ubuntu Component Model Mapping to CUDF}

\section{OSGi Component Model}
\subsection{Mapping to CUDF}

\section{Comparison}

\chapter{Investigations}

\section{Search Space Size}
%How big a search space are we looking at here

\section{SAT Optimisation}
%What is necessary in SAT
\subsection{Literal Order}
\subsection{Learning Choices}

\input{simulation}


\chapter{Conclusion}
\section{Related Work}
\section{Future Work}

\section{Glossary}
Composer: The user who creates or alters component systems (compositions)

Versioning Model: A method to define and compare versions
\end{document}
